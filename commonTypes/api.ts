/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * API продавца
 * # Общее описание <style> .langChange {   text-align: left;   padding: 2px 222px 2px 18px; } </style> <style> .new {   display: inline-block;   padding: 2px 8px;   margin: 0;   background-color: #ffa500;   color: #ffffff;   font-size: 13px;   vertical-align: middle;   line-height: 1.6;   border-radius: 4px;   font-weight: 600;   font-size: 12px; } </style> <style> .newM {   padding: 5px 10px;   display: inline-block;   background-color: #ffa500;   color: #ffffff;   cursor: pointer;   text-align: center;   outline: none;   margin: 0 5px 5px 5px;   #border: 1px solid #07090b;   border-radius: 5px;   min-width: 60px;   font-size: 0.9em;   font-weight: bold; } </style>  Wildberries API предоставляет продавцам возможность управления магазином и получения оперативной и статистической информации по протоколу HTTP RestAPI. <br> Описание API предоставляется в формате [Swagger](https://swagger.io/) (Open API) и может быть использовано для импорта в другие инструменты (такие как PostMan) или генерации клиентского кода на различных языках программирования с помощью [Swagger CodeGen](https://swagger.io/tools/swagger-codegen/)  <ul> <li> Описание в оригинальном swagger-формате <a href=\"/swagger\">swagger</a> <li> OpenAPI-файл <a href=\"/swagger.yaml\">swagger.yaml</a> </ul>  <br> Для ручной проверки API вы можете использовать: <ul> <li> Под ОС Windows - [PostMan](https://www.postman.com/) <li> Под ОС Linux - [curl](https://curl.se/)  </ul> <br>  ## Поддержка Техническая поддержка осуществляется через диалоги в личном кабинете продавца. При создании нового обращения в техподдержку используйте категорию API. <br> Новости и изменения, касающиеся API, публикуются в [новостной ленте Wildberries](https://seller.wildberries.ru/news). <br> <br> <br>  ## Авторизация Авторизация осуществляется по токенам API, которые  владелец личного кабинета (главный пользователь) самостоятельно  генерирует в разделе   [Профиль --> Настройки --> Доступ к API](https://seller.wildberries.ru/supplier-settings/access-to-api).   <br>  <br>  Существует три типа токенов:   <ol>     <li>Стандартный. Используется для работы с методами из разделов: Цены, Промокоды и скидки, Контент, Marketplace, Рекомендации, Отзывы, Вопросы.</li>     <li>Статистика. Используется для работы с методами из раздела Статистика.</li>     <li>Реклама. Используется для работы с методами из раздела Реклама.</li>   </ol>    Обратите внимание, что токен отображается ТОЛЬКО в момент создания. Его надо сохранить, потому что больше его отобразить будет нельзя. <br>Созданный токен следует добавлять в каждый запрос, прибавляя к запросу заголовок (http-header) формата `Authorization: .........`. <br> <br> <br> ## Форматы ### Дата и время Во всех методах API статистики дата и время передаются в формате [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339).  <br> В большинстве случаев вы можете передать дату или дату со временем. Если время не указано, оно принимается равным 00:00:00. Время можно указывать с точностью до секунд или миллисекунд.  Литера `Z` в конце строки означает часовой пояс UTC. При ее отсутствии время считается в часовом поясе МСК (UTC+3). <br> Примеры: <ul> <li> `2019-06-20` <li> `2019-06-20T00:00:00Z` <li> `2019-06-20T23:59:59` <li> `2019-06-20T00:00:00.12345Z` <li> `2019-06-20T00:00:00.12345` <li> `2017-03-25T00:00:00` </ul> <br> ## Release Notes <p>Для просмотра обновлений перейдите по <span><a href=\"./releasenotes/index.html\" target=\"_blank\">ссылке</a></span>.</p> 
 *
 * OpenAPI spec version: 2.4
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "/".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 */
export type ActivityNomNotChanged = string
/**
 * 
 * @export
 */
export type ActivitySubjectGroupNotChanged = string
/**
 * 
 * @export
 * @interface Advv0allcpmCpm
 */
export interface Advv0allcpmCpm {
    /**
     * Размер ставки
     * @type {number}
     * @memberof Advv0allcpmCpm
     */
    cpm?: number;
    /**
     * Количество ставок
     * @type {number}
     * @memberof Advv0allcpmCpm
     */
    count?: number;
}
/**
 * 
 * @export
 * @interface Advv0intervalsIntervals
 */
export interface Advv0intervalsIntervals {
    /**
     * Время начала показов, по 24 часовой схеме (\"begin\": 15)
     * @type {number}
     * @memberof Advv0intervalsIntervals
     */
    begin?: number;
    /**
     * Время окончания показов, по 24 часовой схеме (\"end\": 21)
     * @type {number}
     * @memberof Advv0intervalsIntervals
     */
    end?: number;
}
/**
 * 
 * @export
 * @interface Advv0nmactiveActive
 */
export interface Advv0nmactiveActive {
    /**
     * Артикул WB (`nmId`)
     * @type {number}
     * @memberof Advv0nmactiveActive
     */
    nm?: number;
    /**
     * Новое состояние (`true` - сделать номенклатуру активной или `false` - сделать номенклатуру неактивной)
     * @type {boolean}
     * @memberof Advv0nmactiveActive
     */
    active?: boolean;
}
/**
 * 
 * @export
 */
export type AmountNotChanged = string
/**
 * 
 * @export
 * @interface Apiv1questionsAnswer
 */
export interface Apiv1questionsAnswer {
    /**
     * Текст ответа
     * @type {string}
     * @memberof Apiv1questionsAnswer
     */
    text: string;
}
/**
 * 
 * @export
 * @interface Apiv3ordersordermetasgtinSgtin
 */
export interface Apiv3ordersordermetasgtinSgtin {
    /**
     * Код маркировки на упаковке. От 16 до 135 символов.
     * @type {string}
     * @memberof Apiv3ordersordermetasgtinSgtin
     */
    code: string;
}
/**
 * 
 * @export
 * @interface Apiv3stockswarehouseStocks
 */
export interface Apiv3stockswarehouseStocks {
    /**
     * Баркод
     * @type {string}
     * @memberof Apiv3stockswarehouseStocks
     */
    sku?: string;
    /**
     * Остаток
     * @type {number}
     * @memberof Apiv3stockswarehouseStocks
     */
    amount?: number;
}
/**
 * 
 * @export
 */
export type CampaignIntervalsNotChanged = string
/**
 * 
 * @export
 * @interface CardsFilterBody
 */
export interface CardsFilterBody {
    /**
     * Массив  артикулов продавца. <br>Максимальное количество в запросе `100`. 
     * @type {Array<string>}
     * @memberof CardsFilterBody
     */
    vendorCodes?: Array<string>;
    /**
     * <code>true</code> - показать КТ только из разрешенных к реализации категорий<br> <code>false</code> - показать КТ из всех категорий 
     * @type {boolean}
     * @memberof CardsFilterBody
     */
    allowedCategoriesOnly?: boolean;
}
/**
 * 
 * @export
 * @interface CardsUpdateBody
 */
export interface CardsUpdateBody {
    /**
     * Идентификатор карточки товара
     * @type {number}
     * @memberof CardsUpdateBody
     */
    imtID?: number;
    /**
     * Артикул WB
     * @type {number}
     * @memberof CardsUpdateBody
     */
    nmID: number;
    /**
     * Артикул продавца
     * @type {string}
     * @memberof CardsUpdateBody
     */
    vendorCode: string;
    /**
     * Массив размеров для номенклатуры (для безразмерного товара все равно нужно передавать данный массив без параметров (`wbSize` и `techSize`), но с `chrtID` и баркодом)
     * @type {Array<Contentv1cardsupdateSizes>}
     * @memberof CardsUpdateBody
     */
    sizes: Array<Contentv1cardsupdateSizes>;
    /**
     * Массив характеристик, индивидуальный для каждой категории
     * @type {Array<any>}
     * @memberof CardsUpdateBody
     */
    characteristics: Array<any>;
}
/**
 * 
 * @export
 * @interface CardsUploadBody
 */
export interface CardsUploadBody {
}
/**
 * 
 * @export
 */
export type CompanyNameChangeErr = string
/**
 * 
 * @export
 * @interface Contentv1cardscursorlistSort
 */
export interface Contentv1cardscursorlistSort {
    /**
     * 
     * @type {Contentv1cardscursorlistSortCursor}
     * @memberof Contentv1cardscursorlistSort
     */
    cursor?: Contentv1cardscursorlistSortCursor;
    /**
     * 
     * @type {Contentv1cardscursorlistSortFilter}
     * @memberof Contentv1cardscursorlistSort
     */
    filter?: Contentv1cardscursorlistSortFilter;
    /**
     * 
     * @type {Contentv1cardscursorlistSortSort}
     * @memberof Contentv1cardscursorlistSort
     */
    sort?: Contentv1cardscursorlistSortSort;
}
/**
 * 
 * @export
 * @interface Contentv1cardscursorlistSortCursor
 */
export interface Contentv1cardscursorlistSortCursor {
    /**
     * Время обновления последней КТ из предыдущего ответа на запрос списка КТ.
     * @type {string}
     * @memberof Contentv1cardscursorlistSortCursor
     */
    updatedAt?: string;
    /**
     * Артикул WB последней КТ из предыдущего ответа на запрос списка КТ.
     * @type {number}
     * @memberof Contentv1cardscursorlistSortCursor
     */
    nmID?: number;
    /**
     * Кол-во запрашиваемых КТ.
     * @type {number}
     * @memberof Contentv1cardscursorlistSortCursor
     */
    limit?: number;
}
/**
 * 
 * @export
 * @interface Contentv1cardscursorlistSortFilter
 */
export interface Contentv1cardscursorlistSortFilter {
    /**
     * Поиск по артикулу WB, артикулу продавца, баркоду или тегу
     * @type {number}
     * @memberof Contentv1cardscursorlistSortFilter
     */
    textSearch?: number;
    /**
     * `-1` - Показать все КТ. <br>`0` - Показать КТ без фото. <br>`1` - Показать КТ с фото. 
     * @type {number}
     * @memberof Contentv1cardscursorlistSortFilter
     */
    withPhoto?: number;
    /**
     * <code>true</code> - показать КТ только из разрешенных к реализации категорий<br> <code>false</code> - показать КТ из всех категорий 
     * @type {boolean}
     * @memberof Contentv1cardscursorlistSortFilter
     */
    allowedCategoriesOnly?: boolean;
}
/**
 * 
 * @export
 * @interface Contentv1cardscursorlistSortSort
 */
export interface Contentv1cardscursorlistSortSort {
    /**
     * Поле, по которому будет сортироваться список КТ (пока поддерживается только updateAt).
     * @type {string}
     * @memberof Contentv1cardscursorlistSortSort
     */
    sortColumn?: string;
    /**
     * Тип сортировки.
     * @type {boolean}
     * @memberof Contentv1cardscursorlistSortSort
     */
    ascending?: boolean;
}
/**
 * 
 * @export
 * @interface Contentv1cardstrashlistSort
 */
export interface Contentv1cardstrashlistSort {
    /**
     * Поле, по которому будет сортироваться список КТ (пока что поддерживается только `updateAt`) 
     * @type {string}
     * @memberof Contentv1cardstrashlistSort
     */
    sortColumn?: string;
    /**
     * Тип сортировки
     * @type {boolean}
     * @memberof Contentv1cardstrashlistSort
     */
    ascending?: boolean;
    /**
     * Поле, по которому будет осуществляться поиск: по баркоду(`skus`), артикулу продавца (`vendorCode`), артикулу WB (`nmID`) 
     * @type {string}
     * @memberof Contentv1cardstrashlistSort
     */
    searchValue?: string;
    /**
     * С какого элемента выдавать данные
     * @type {number}
     * @memberof Contentv1cardstrashlistSort
     */
    offset?: number;
    /**
     * Кол-во запрашиваемых КТ (max. 1000)
     * @type {number}
     * @memberof Contentv1cardstrashlistSort
     */
    limit?: number;
}
/**
 * 
 * @export
 * @interface Contentv1cardsupdateSizes
 */
export interface Contentv1cardsupdateSizes {
    /**
     * Размер товара (пример S, M, L, XL, 42, 42-43)
     * @type {string}
     * @memberof Contentv1cardsupdateSizes
     */
    techSize?: string;
    /**
     * Числовой идентификатор размера для данной номенклатуры Wildberries
     * @type {number}
     * @memberof Contentv1cardsupdateSizes
     */
    chrtID: number;
    /**
     * Российский размер товара
     * @type {string}
     * @memberof Contentv1cardsupdateSizes
     */
    wbSize?: string;
    /**
     * Массив баркодов, строковых идентификаторов размеров товара (их можно сгенерировать с помощью API, см. раздел \"Контент / Просмотр\")
     * @type {Array<string>}
     * @memberof Contentv1cardsupdateSizes
     */
    skus: Array<string>;
}
/**
 * 
 * @export
 * @interface Contentv1cardsuploadaddCards
 */
export interface Contentv1cardsuploadaddCards {
    /**
     * Артикул продавца
     * @type {string}
     * @memberof Contentv1cardsuploadaddCards
     */
    vendorCode?: string;
    /**
     * Массив характеристик, индивидуальный для каждой категории
     * @type {Array<any>}
     * @memberof Contentv1cardsuploadaddCards
     */
    characteristics?: Array<any>;
    /**
     * 
     * @type {Array<Contentv1cardsuploadaddSizes>}
     * @memberof Contentv1cardsuploadaddCards
     */
    sizes?: Array<Contentv1cardsuploadaddSizes>;
}
/**
 * 
 * @export
 * @interface Contentv1cardsuploadaddSizes
 */
export interface Contentv1cardsuploadaddSizes {
    /**
     * Размер товара (пример S, M, L, XL, 42, 42-43)
     * @type {string}
     * @memberof Contentv1cardsuploadaddSizes
     */
    techSize?: string;
    /**
     * Российский размер товара
     * @type {string}
     * @memberof Contentv1cardsuploadaddSizes
     */
    wbSize?: string;
    /**
     * Цена (указывается в рублях)
     * @type {number}
     * @memberof Contentv1cardsuploadaddSizes
     */
    price?: number;
    /**
     * Массив баркодов, строковых идентификаторов размеров товара (их можно сгенерировать с помощью API, см. Viewer)
     * @type {Array<string>}
     * @memberof Contentv1cardsuploadaddSizes
     */
    skus?: Array<string>;
}
/**
 * 
 * @export
 */
export type CreatingGroupOfIndividualCards = Array<Array>
/**
 * 
 * @export
 */
export type CreatingMergedCards = Array<Array>
/**
 * 
 * @export
 */
export type CreatingOneCard = Array<Array>
/**
 * 
 * @export
 * @interface CursorListBody
 */
export interface CursorListBody {
    /**
     * 
     * @type {Contentv1cardscursorlistSort}
     * @memberof CursorListBody
     */
    sort?: Contentv1cardscursorlistSort;
}
/**
 * 
 * @export
 * @interface DetailReportItem
 */
export interface DetailReportItem {
    /**
     * Номер отчёта
     * @type {number}
     * @memberof DetailReportItem
     */
    realizationreportId?: number;
    /**
     * Дата начала отчётного периода
     * @type {Date}
     * @memberof DetailReportItem
     */
    dateFrom?: Date;
    /**
     * Дата конца отчётного периода
     * @type {Date}
     * @memberof DetailReportItem
     */
    dateTo?: Date;
    /**
     * Дата формирования отчёта
     * @type {Date}
     * @memberof DetailReportItem
     */
    createDt?: Date;
    /**
     * Договор
     * @type {any}
     * @memberof DetailReportItem
     */
    suppliercontractCode?: any;
    /**
     * Номер строки
     * @type {number}
     * @memberof DetailReportItem
     */
    rrdId?: number;
    /**
     * Номер поставки
     * @type {number}
     * @memberof DetailReportItem
     */
    giId?: number;
    /**
     * Предмет
     * @type {string}
     * @memberof DetailReportItem
     */
    subjectName?: string;
    /**
     * Артикул WB
     * @type {number}
     * @memberof DetailReportItem
     */
    nmId?: number;
    /**
     * Бренд
     * @type {string}
     * @memberof DetailReportItem
     */
    brandName?: string;
    /**
     * Артикул продавца
     * @type {string}
     * @memberof DetailReportItem
     */
    saName?: string;
    /**
     * Размер
     * @type {string}
     * @memberof DetailReportItem
     */
    tsName?: string;
    /**
     * Баркод
     * @type {string}
     * @memberof DetailReportItem
     */
    barcode?: string;
    /**
     * Тип документа
     * @type {string}
     * @memberof DetailReportItem
     */
    docTypeName?: string;
    /**
     * Количество
     * @type {number}
     * @memberof DetailReportItem
     */
    quantity?: number;
    /**
     * Цена розничная
     * @type {number}
     * @memberof DetailReportItem
     */
    retailPrice?: number;
    /**
     * Сумма продаж (возвратов)
     * @type {number}
     * @memberof DetailReportItem
     */
    retailAmount?: number;
    /**
     * Согласованная скидка
     * @type {number}
     * @memberof DetailReportItem
     */
    salePercent?: number;
    /**
     * Процент комиссии
     * @type {number}
     * @memberof DetailReportItem
     */
    commissionPercent?: number;
    /**
     * Склад
     * @type {string}
     * @memberof DetailReportItem
     */
    officeName?: string;
    /**
     * Обоснование для оплаты
     * @type {string}
     * @memberof DetailReportItem
     */
    supplierOperName?: string;
    /**
     * Дата заказа. <br> Присылается с явным указанием часового пояса
     * @type {Date}
     * @memberof DetailReportItem
     */
    orderDt?: Date;
    /**
     * Дата продажи. <br> Присылается с явным указанием часового пояса
     * @type {Date}
     * @memberof DetailReportItem
     */
    saleDt?: Date;
    /**
     * Дата операции. <br> Присылается с явным указанием часового пояса
     * @type {Date}
     * @memberof DetailReportItem
     */
    rrDt?: Date;
    /**
     * Штрих-код
     * @type {number}
     * @memberof DetailReportItem
     */
    shkId?: number;
    /**
     * Цена розничная с учетом согласованной скидки
     * @type {number}
     * @memberof DetailReportItem
     */
    retailPriceWithdiscRub?: number;
    /**
     * Количество доставок
     * @type {number}
     * @memberof DetailReportItem
     */
    deliveryAmount?: number;
    /**
     * Количество возвратов
     * @type {number}
     * @memberof DetailReportItem
     */
    returnAmount?: number;
    /**
     * Стоимость логистики
     * @type {number}
     * @memberof DetailReportItem
     */
    deliveryRub?: number;
    /**
     * Тип коробов
     * @type {string}
     * @memberof DetailReportItem
     */
    giBoxTypeName?: string;
    /**
     * Согласованный продуктовый дисконт
     * @type {number}
     * @memberof DetailReportItem
     */
    productDiscountForReport?: number;
    /**
     * Промокод
     * @type {number}
     * @memberof DetailReportItem
     */
    supplierPromo?: number;
    /**
     * Уникальный идентификатор заказа
     * @type {number}
     * @memberof DetailReportItem
     */
    rid?: number;
    /**
     * Скидка постоянного покупателя
     * @type {number}
     * @memberof DetailReportItem
     */
    ppvzSppPrc?: number;
    /**
     * Размер кВВ без НДС, % базовый
     * @type {number}
     * @memberof DetailReportItem
     */
    ppvzKvwPrcBase?: number;
    /**
     * Итоговый кВВ без НДС, %
     * @type {number}
     * @memberof DetailReportItem
     */
    ppvzKvwPrc?: number;
    /**
     * Размер снижения кВВ из-за рейтинга, % <span class=\"new\">new</span>
     * @type {number}
     * @memberof DetailReportItem
     */
    supRatingPrcUp?: number;
    /**
     * Размер снижения кВВ из-за акции, % <span class=\"new\">new</span>
     * @type {number}
     * @memberof DetailReportItem
     */
    isKgvpV2?: number;
    /**
     * Вознаграждение с продаж до вычета услуг поверенного, без НДС
     * @type {number}
     * @memberof DetailReportItem
     */
    ppvzSalesCommission?: number;
    /**
     * К перечислению продавцу за реализованный товар
     * @type {number}
     * @memberof DetailReportItem
     */
    ppvzForPay?: number;
    /**
     * Возмещение за выдачу и возврат товаров на ПВЗ
     * @type {number}
     * @memberof DetailReportItem
     */
    ppvzReward?: number;
    /**
     * Возмещение издержек по эквайрингу. <br> Издержки WB за услуги эквайринга: вычитаются из вознаграждения WB и не влияют на доход продавца. 
     * @type {number}
     * @memberof DetailReportItem
     */
    acquiringFee?: number;
    /**
     * Наименование банка-эквайера
     * @type {string}
     * @memberof DetailReportItem
     */
    acquiringBank?: string;
    /**
     * Вознаграждение WB без НДС
     * @type {number}
     * @memberof DetailReportItem
     */
    ppvzVw?: number;
    /**
     * НДС с вознаграждения WB
     * @type {number}
     * @memberof DetailReportItem
     */
    ppvzVwNds?: number;
    /**
     * Номер офиса
     * @type {number}
     * @memberof DetailReportItem
     */
    ppvzOfficeId?: number;
    /**
     * Наименование офиса доставки
     * @type {string}
     * @memberof DetailReportItem
     */
    ppvzOfficeName?: string;
    /**
     * Номер партнера
     * @type {number}
     * @memberof DetailReportItem
     */
    ppvzSupplierId?: number;
    /**
     * Партнер
     * @type {string}
     * @memberof DetailReportItem
     */
    ppvzSupplierName?: string;
    /**
     * ИНН партнера
     * @type {string}
     * @memberof DetailReportItem
     */
    ppvzInn?: string;
    /**
     * Номер таможенной декларации
     * @type {string}
     * @memberof DetailReportItem
     */
    declarationNumber?: string;
    /**
     * Обоснование штрафов и доплат. <br> Поле будет в ответе при наличии значения 
     * @type {string}
     * @memberof DetailReportItem
     */
    bonusTypeName?: string;
    /**
     * Цифровое значение стикера, который клеится на товар в процессе сборки заказа по схеме \"Маркетплейс\"
     * @type {string}
     * @memberof DetailReportItem
     */
    stickerId?: string;
    /**
     * Страна продажи
     * @type {string}
     * @memberof DetailReportItem
     */
    siteCountry?: string;
    /**
     * Штрафы
     * @type {number}
     * @memberof DetailReportItem
     */
    penalty?: number;
    /**
     * Доплаты
     * @type {number}
     * @memberof DetailReportItem
     */
    additionalPayment?: number;
    /**
     * Возмещение издержек по перевозке. <span class=\"new\">new</span><br> Поле будет в ответе при наличии значения 
     * @type {number}
     * @memberof DetailReportItem
     */
    rebillLogisticCost?: number;
    /**
     * Организатор перевозки. <span class=\"new\">new</span><br> Поле будет в ответе при наличии значения.           
     * @type {string}
     * @memberof DetailReportItem
     */
    rebillLogisticOrg?: string;
    /**
     * Код маркировки. <br> Поле будет в ответе при наличии значения 
     * @type {string}
     * @memberof DetailReportItem
     */
    kiz?: string;
    /**
     * Уникальный идентификатор заказа. Примечание для использующих API Marketplace: `srid` равен `rid` в ответах методов сборочных заданий. 
     * @type {string}
     * @memberof DetailReportItem
     */
    srid?: string;
}
/**
 * 
 * @export
 */
export type DisplayIntervalError = string
/**
 * 
 * @export
 */
export type ErrorProcesRequestParam = string
/**
 * 
 * @export
 * @interface FeedbackErr400
 */
export interface FeedbackErr400 {
    /**
     * 
     * @type {any}
     * @memberof FeedbackErr400
     */
    data?: any;
    /**
     * Есть ли ошибка
     * @type {boolean}
     * @memberof FeedbackErr400
     */
    error?: boolean;
    /**
     * Описание ошибки
     * @type {string}
     * @memberof FeedbackErr400
     */
    errorText?: string;
    /**
     * 
     * @type {any}
     * @memberof FeedbackErr400
     */
    additionalErrors?: any;
}
/**
 * 
 * @export
 * @interface FeedbackErr403
 */
export interface FeedbackErr403 {
    /**
     * 
     * @type {any}
     * @memberof FeedbackErr403
     */
    data?: any;
    /**
     * Есть ли ошибка
     * @type {boolean}
     * @memberof FeedbackErr403
     */
    error?: boolean;
    /**
     * Описание авторизации
     * @type {string}
     * @memberof FeedbackErr403
     */
    errorText?: string;
    /**
     * 
     * @type {any}
     * @memberof FeedbackErr403
     */
    additionalErrors?: any;
}
/**
 * 
 * @export
 * @interface FeedbackErr404
 */
export interface FeedbackErr404 {
    /**
     * 
     * @type {any}
     * @memberof FeedbackErr404
     */
    data?: any;
    /**
     * Есть ли ошибка
     * @type {boolean}
     * @memberof FeedbackErr404
     */
    error?: boolean;
    /**
     * Описание авторизации
     * @type {string}
     * @memberof FeedbackErr404
     */
    errorText?: string;
    /**
     * 
     * @type {any}
     * @memberof FeedbackErr404
     */
    additionalErrors?: any;
}
/**
 * 
 * @export
 * @interface IncomesItem
 */
export interface IncomesItem {
    /**
     * Номер поставки
     * @type {number}
     * @memberof IncomesItem
     */
    incomeId?: number;
    /**
     * Номер УПД
     * @type {string}
     * @memberof IncomesItem
     */
    number?: string;
    /**
     * Дата поступления. Если часовой пояс не указан, то берется Московское время UTC+3.
     * @type {string}
     * @memberof IncomesItem
     */
    date?: string;
    /**
     * Дата и время обновления информации в сервисе. Это поле соответствует параметру `dateFrom` в запросе. Если часовой пояс не указан, то берется Московское время UTC+3.
     * @type {Date}
     * @memberof IncomesItem
     */
    lastChangeDate?: Date;
    /**
     * Артикул продавца
     * @type {string}
     * @memberof IncomesItem
     */
    supplierArticle?: string;
    /**
     * Размер товара (пример S, M, L, XL, 42, 42-43)
     * @type {string}
     * @memberof IncomesItem
     */
    techSize?: string;
    /**
     * Бар-код
     * @type {string}
     * @memberof IncomesItem
     */
    barcode?: string;
    /**
     * Количество
     * @type {number}
     * @memberof IncomesItem
     */
    quantity?: number;
    /**
     * Цена из УПД
     * @type {number}
     * @memberof IncomesItem
     */
    totalPrice?: number;
    /**
     * Дата принятия (закрытия) в WB. Если часовой пояс не указан, то берется Московское время UTC+3.
     * @type {string}
     * @memberof IncomesItem
     */
    dateClose?: string;
    /**
     * Название склада
     * @type {string}
     * @memberof IncomesItem
     */
    warehouseName?: string;
    /**
     * Артикул WB
     * @type {number}
     * @memberof IncomesItem
     */
    nmId?: number;
    /**
     * Текущий статус поставки
     * @type {string}
     * @memberof IncomesItem
     */
    status?: IncomesItem.StatusEnum;
}

/**
 * @export
 * @namespace IncomesItem
 */
export namespace IncomesItem {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
         = <any> 'Принято'
    }
}
/**
 * 
 * @export
 */
export type IncorrectActive = string
/**
 * 
 * @export
 */
export type IncorrectCpm = string
/**
 * 
 * @export
 */
export type IncorrectDisplayInterval = string
/**
 * 
 * @export
 */
export type IncorrectName = string
/**
 * 
 * @export
 */
export type IncorrectNm = string
/**
 * 
 * @export
 */
export type IncorrectNumDisplayIntervals = string
/**
 * 
 * @export
 */
export type IncorrectNumItems = string
/**
 * 
 * @export
 */
export type IncorrectParam = string
/**
 * 
 * @export
 * @interface IncorrectRequest
 */
export interface IncorrectRequest {
    /**
     * 
     * @type {any}
     * @memberof IncorrectRequest
     */
    data?: any;
    /**
     * Флаг ошибки
     * @type {boolean}
     * @memberof IncorrectRequest
     */
    error?: boolean;
    /**
     * Описание ошибки
     * @type {string}
     * @memberof IncorrectRequest
     */
    errorText?: string;
    /**
     * 
     * @type {IncorrectRequestAdditionalErrors}
     * @memberof IncorrectRequest
     */
    additionalErrors?: IncorrectRequestAdditionalErrors;
}
/**
 * Дополнительные ошибки
 * @export
 * @interface IncorrectRequestAdditionalErrors
 */
export interface IncorrectRequestAdditionalErrors {
    /**
     * 
     * @type {string}
     * @memberof IncorrectRequestAdditionalErrors
     */
    description?: string;
}
/**
 * 
 * @export
 */
export type IncorrectStatus = string
/**
 * 
 * @export
 */
export type IncorrectSubjectID = string
/**
 * 
 * @export
 */
export type IncorrectSupplierId = string
/**
 * 
 * @export
 */
export type IncorrectType = string
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * Артикул WB
     * @type {number}
     * @memberof InlineResponse200
     */
    nmId?: number;
    /**
     * Цена
     * @type {number}
     * @memberof InlineResponse200
     */
    price?: number;
    /**
     * Скидка
     * @type {number}
     * @memberof InlineResponse200
     */
    discount?: number;
    /**
     * Промокод
     * @type {number}
     * @memberof InlineResponse200
     */
    promoCode?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * Номер запроса на сброс скидки
     * @type {number}
     * @memberof InlineResponse2001
     */
    uploadId?: number;
    /**
     * Данное поле обозначает что скидка уже была сброшена
     * @type {boolean}
     * @memberof InlineResponse2001
     */
    alreadyExists?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
    /**
     * 
     * @type {Array<InlineResponse20010Data>}
     * @memberof InlineResponse20010
     */
    data?: Array<InlineResponse20010Data>;
    /**
     * Флаг ошибки.
     * @type {boolean}
     * @memberof InlineResponse20010
     */
    error?: boolean;
    /**
     * Описание ошибки.
     * @type {string}
     * @memberof InlineResponse20010
     */
    errorText?: string;
    /**
     * Дополнительные ошибки.
     * @type {string}
     * @memberof InlineResponse20010
     */
    additionalErrors?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20010Data
 */
export interface InlineResponse20010Data {
    /**
     * Наименование подкатегории
     * @type {string}
     * @memberof InlineResponse20010Data
     */
    objectName?: string;
    /**
     * Наименование характеристики
     * @type {string}
     * @memberof InlineResponse20010Data
     */
    name?: string;
    /**
     * Характеристика обязательна к заполенению
     * @type {boolean}
     * @memberof InlineResponse20010Data
     */
    required?: boolean;
    /**
     * Единица имерения (см, гр и т.д.)
     * @type {string}
     * @memberof InlineResponse20010Data
     */
    unitName?: string;
    /**
     * Максимальное кол-во значений которое можно присвоить данной характеристике
     * @type {number}
     * @memberof InlineResponse20010Data
     */
    maxCount?: number;
    /**
     * Характеристика популярна у пользователей
     * @type {boolean}
     * @memberof InlineResponse20010Data
     */
    popular?: boolean;
    /**
     * Тип характеристики (1 и 0 - строка или массив строк; 4 - число или массив чисел)
     * @type {number}
     * @memberof InlineResponse20010Data
     */
    charcType?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20011
 */
export interface InlineResponse20011 {
    /**
     * 
     * @type {Array<InlineResponse20011Data>}
     * @memberof InlineResponse20011
     */
    data?: Array<InlineResponse20011Data>;
    /**
     * Флаг ошибки.
     * @type {boolean}
     * @memberof InlineResponse20011
     */
    error?: boolean;
    /**
     * Описание ошибки.
     * @type {string}
     * @memberof InlineResponse20011
     */
    errorText?: string;
    /**
     * Дополнительные ошибки.
     * @type {string}
     * @memberof InlineResponse20011
     */
    additionalErrors?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20011Data
 */
export interface InlineResponse20011Data {
    /**
     * Наименование подкатегории
     * @type {string}
     * @memberof InlineResponse20011Data
     */
    objectName?: string;
    /**
     * Наименование характеристики
     * @type {string}
     * @memberof InlineResponse20011Data
     */
    name?: string;
    /**
     * Характеристика обязательна к заполенению
     * @type {boolean}
     * @memberof InlineResponse20011Data
     */
    required?: boolean;
    /**
     * Единица имерения (см, гр и т.д.)
     * @type {string}
     * @memberof InlineResponse20011Data
     */
    unitName?: string;
    /**
     * Максимальное кол-во значений, которое можно присвоить данной характеристике. <br>Если 0, то нет ограничения. 
     * @type {number}
     * @memberof InlineResponse20011Data
     */
    maxCount?: number;
    /**
     * Характеристика популярна у пользователей
     * @type {boolean}
     * @memberof InlineResponse20011Data
     */
    popular?: boolean;
    /**
     * Тип характеристики (1 и 0 - строка или массив строк; 4 - число или массив чисел)
     * @type {number}
     * @memberof InlineResponse20011Data
     */
    charcType?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20012
 */
export interface InlineResponse20012 {
    /**
     * 
     * @type {Array<InlineResponse20012Data>}
     * @memberof InlineResponse20012
     */
    data?: Array<InlineResponse20012Data>;
    /**
     * Флаг ошибки.
     * @type {boolean}
     * @memberof InlineResponse20012
     */
    error?: boolean;
    /**
     * Описание ошибки.
     * @type {string}
     * @memberof InlineResponse20012
     */
    errorText?: string;
    /**
     * Дополнительные ошибки.
     * @type {string}
     * @memberof InlineResponse20012
     */
    additionalErrors?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20012Data
 */
export interface InlineResponse20012Data {
    /**
     * Наименование цвета
     * @type {string}
     * @memberof InlineResponse20012Data
     */
    name?: string;
    /**
     * Наименование родительского цвета
     * @type {string}
     * @memberof InlineResponse20012Data
     */
    parentName?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20013
 */
export interface InlineResponse20013 {
    /**
     * Массив значений для хар-ки Пол
     * @type {Array<string>}
     * @memberof InlineResponse20013
     */
    data?: Array<string>;
    /**
     * Флаг ошибки.
     * @type {boolean}
     * @memberof InlineResponse20013
     */
    error?: boolean;
    /**
     * Описание ошибки.
     * @type {string}
     * @memberof InlineResponse20013
     */
    errorText?: string;
    /**
     * Дополнительные ошибки.
     * @type {string}
     * @memberof InlineResponse20013
     */
    additionalErrors?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20014
 */
export interface InlineResponse20014 {
    /**
     * 
     * @type {Array<InlineResponse20014Data>}
     * @memberof InlineResponse20014
     */
    data?: Array<InlineResponse20014Data>;
    /**
     * Флаг ошибки.
     * @type {boolean}
     * @memberof InlineResponse20014
     */
    error?: boolean;
    /**
     * Описание ошибки.
     * @type {string}
     * @memberof InlineResponse20014
     */
    errorText?: string;
    /**
     * Дополнительные ошибки.
     * @type {string}
     * @memberof InlineResponse20014
     */
    additionalErrors?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20014Data
 */
export interface InlineResponse20014Data {
    /**
     * Значение характеристики Страны
     * @type {string}
     * @memberof InlineResponse20014Data
     */
    name?: string;
    /**
     * Полное название страны
     * @type {string}
     * @memberof InlineResponse20014Data
     */
    fullName?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20015
 */
export interface InlineResponse20015 {
    /**
     * Массив значений для хар-ки Сезон
     * @type {Array<string>}
     * @memberof InlineResponse20015
     */
    data?: Array<string>;
    /**
     * Флаг ошибки.
     * @type {boolean}
     * @memberof InlineResponse20015
     */
    error?: boolean;
    /**
     * Описание ошибки.
     * @type {string}
     * @memberof InlineResponse20015
     */
    errorText?: string;
    /**
     * Дополнительные ошибки.
     * @type {string}
     * @memberof InlineResponse20015
     */
    additionalErrors?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20016
 */
export interface InlineResponse20016 {
    /**
     * Массив найденных брендов
     * @type {Array<string>}
     * @memberof InlineResponse20016
     */
    data?: Array<string>;
    /**
     * Флаг ошибки.
     * @type {boolean}
     * @memberof InlineResponse20016
     */
    error?: boolean;
    /**
     * Описание ошибки.
     * @type {string}
     * @memberof InlineResponse20016
     */
    errorText?: string;
    /**
     * Дополнительные ошибки.
     * @type {string}
     * @memberof InlineResponse20016
     */
    additionalErrors?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20017
 */
export interface InlineResponse20017 {
    /**
     * 
     * @type {Array<InlineResponse20017Data>}
     * @memberof InlineResponse20017
     */
    data?: Array<InlineResponse20017Data>;
    /**
     * Флаг ошибки.
     * @type {boolean}
     * @memberof InlineResponse20017
     */
    error?: boolean;
    /**
     * Описание ошибки.
     * @type {string}
     * @memberof InlineResponse20017
     */
    errorText?: string;
    /**
     * Дополнительные ошибки.
     * @type {string}
     * @memberof InlineResponse20017
     */
    additionalErrors?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20017Data
 */
export interface InlineResponse20017Data {
    /**
     * Наименование категории
     * @type {string}
     * @memberof InlineResponse20017Data
     */
    subjectName?: string;
    /**
     * Код ТНВЭД
     * @type {string}
     * @memberof InlineResponse20017Data
     */
    tnvedName?: string;
    /**
     * Описание кода ТНВЭД
     * @type {string}
     * @memberof InlineResponse20017Data
     */
    description?: string;
    /**
     * КИЗовый ТНВЭД
     * @type {boolean}
     * @memberof InlineResponse20017Data
     */
    isKiz?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse20018
 */
export interface InlineResponse20018 {
    /**
     * 
     * @type {any}
     * @memberof InlineResponse20018
     */
    data?: any;
    /**
     * Флаг ошибки.
     * @type {boolean}
     * @memberof InlineResponse20018
     */
    error?: boolean;
    /**
     * Описание ошибки.
     * @type {string}
     * @memberof InlineResponse20018
     */
    errorText?: string;
    /**
     * Дополнительные ошибки.
     * @type {string}
     * @memberof InlineResponse20018
     */
    additionalErrors?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20019
 */
export interface InlineResponse20019 {
    /**
     * 
     * @type {InlineResponse20019Data}
     * @memberof InlineResponse20019
     */
    data?: InlineResponse20019Data;
    /**
     * Флаг ошибки
     * @type {boolean}
     * @memberof InlineResponse20019
     */
    error?: boolean;
    /**
     * Описание ошибки
     * @type {string}
     * @memberof InlineResponse20019
     */
    errorText?: string;
    /**
     * Дополнительные ошибки
     * @type {string}
     * @memberof InlineResponse20019
     */
    additionalErrors?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20019Data
 */
export interface InlineResponse20019Data {
    /**
     * Числовой идентификатор тега
     * @type {number}
     * @memberof InlineResponse20019Data
     */
    id?: number;
    /**
     * Цвет тега
     * @type {string}
     * @memberof InlineResponse20019Data
     */
    color?: string;
    /**
     * Имя тега
     * @type {string}
     * @memberof InlineResponse20019Data
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {any}
     * @memberof InlineResponse2002
     */
    data?: any;
    /**
     * Флаг ошибки
     * @type {boolean}
     * @memberof InlineResponse2002
     */
    error?: boolean;
    /**
     * Описание ошибки
     * @type {string}
     * @memberof InlineResponse2002
     */
    errorText?: string;
    /**
     * Дополнительные ошибки
     * @type {string}
     * @memberof InlineResponse2002
     */
    additionalErrors?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20020
 */
export interface InlineResponse20020 {
}
/**
 * 
 * @export
 * @interface InlineResponse20021
 */
export interface InlineResponse20021 {
}
/**
 * 
 * @export
 * @interface InlineResponse20022
 */
export interface InlineResponse20022 {
    /**
     * 
     * @type {InlineResponse20022Data}
     * @memberof InlineResponse20022
     */
    data?: InlineResponse20022Data;
    /**
     * Флаг ошибки
     * @type {boolean}
     * @memberof InlineResponse20022
     */
    error?: boolean;
    /**
     * Описание ошибки
     * @type {string}
     * @memberof InlineResponse20022
     */
    errorText?: string;
    /**
     * Дополнительные ошибки
     * @type {string}
     * @memberof InlineResponse20022
     */
    additionalErrors?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20022Data
 */
export interface InlineResponse20022Data {
    /**
     * Список запрашиваемых КТ
     * @type {Array<InlineResponse20022DataCards>}
     * @memberof InlineResponse20022Data
     */
    cards?: Array<InlineResponse20022DataCards>;
    /**
     * 
     * @type {InlineResponse20022DataCursor}
     * @memberof InlineResponse20022Data
     */
    cursor?: InlineResponse20022DataCursor;
}
/**
 * 
 * @export
 * @interface InlineResponse20022DataCards
 */
export interface InlineResponse20022DataCards {
    /**
     * Артикул WB
     * @type {number}
     * @memberof InlineResponse20022DataCards
     */
    nmID?: number;
    /**
     * Артикул продавца
     * @type {string}
     * @memberof InlineResponse20022DataCards
     */
    vendorCode?: string;
    /**
     * Категория для который создавалось КТ с данной НМ
     * @type {string}
     * @memberof InlineResponse20022DataCards
     */
    object?: string;
    /**
     * Брэнд
     * @type {string}
     * @memberof InlineResponse20022DataCards
     */
    brand?: string;
    /**
     * Дата обновления
     * @type {string}
     * @memberof InlineResponse20022DataCards
     */
    updateAt?: string;
    /**
     * Цвета номенклатуры
     * @type {Array<string>}
     * @memberof InlineResponse20022DataCards
     */
    colors?: Array<string>;
    /**
     * Медиафайлы номенклатуры. <br>Фото, URL которого заканчивается на <b>1.jpg</b> является главным в карточке. 
     * @type {Array<string>}
     * @memberof InlineResponse20022DataCards
     */
    mediaFiles?: Array<string>;
    /**
     * Массив размеров для номенклатуры (для безразмерного товара все равно нужно передавать данный массив с одним элементом и нулевым размером, но с ценой и баркодом) 
     * @type {Array<InlineResponse20022DataSizes>}
     * @memberof InlineResponse20022DataCards
     */
    sizes?: Array<InlineResponse20022DataSizes>;
}
/**
 * 
 * @export
 * @interface InlineResponse20022DataCursor
 */
export interface InlineResponse20022DataCursor {
    /**
     * Смещение относительно первой РК
     * @type {number}
     * @memberof InlineResponse20022DataCursor
     */
    offset?: number;
    /**
     * Кол-во запрашиваемых КТ
     * @type {number}
     * @memberof InlineResponse20022DataCursor
     */
    limit?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20022DataSizes
 */
export interface InlineResponse20022DataSizes {
    /**
     * Массив баркодов, строковых идентификаторов размеров товара (их можно сгенерировать с помощью API, см. Viewer)
     * @type {Array<string>}
     * @memberof InlineResponse20022DataSizes
     */
    skus?: Array<string>;
    /**
     * Размер товара (пример S, M, L, XL, 42, 42-43)
     * @type {string}
     * @memberof InlineResponse20022DataSizes
     */
    techSize?: string;
    /**
     * Российский размер товара
     * @type {string}
     * @memberof InlineResponse20022DataSizes
     */
    wbSize?: string;
    /**
     * Цена
     * @type {number}
     * @memberof InlineResponse20022DataSizes
     */
    price?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20023
 */
export interface InlineResponse20023 {
    /**
     * ID склада.
     * @type {number}
     * @memberof InlineResponse20023
     */
    id?: number;
    /**
     * Наименование склада.
     * @type {string}
     * @memberof InlineResponse20023
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20024
 */
export interface InlineResponse20024 {
    /**
     * 
     * @type {Array<InlineResponse20024Stocks>}
     * @memberof InlineResponse20024
     */
    stocks?: Array<InlineResponse20024Stocks>;
}
/**
 * 
 * @export
 * @interface InlineResponse20024Stocks
 */
export interface InlineResponse20024Stocks {
    /**
     * Баркод
     * @type {string}
     * @memberof InlineResponse20024Stocks
     */
    sku?: string;
    /**
     * Остаток
     * @type {number}
     * @memberof InlineResponse20024Stocks
     */
    amount?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20025
 */
export interface InlineResponse20025 {
    /**
     * 
     * @type {Next}
     * @memberof InlineResponse20025
     */
    next?: Next;
    /**
     * Список поставок
     * @type {Array<Supply>}
     * @memberof InlineResponse20025
     */
    supplies?: Array<Supply>;
}
/**
 * 
 * @export
 * @interface InlineResponse20026
 */
export interface InlineResponse20026 {
    /**
     * 
     * @type {Array<SupplyOrder>}
     * @memberof InlineResponse20026
     */
    orders?: Array<SupplyOrder>;
}
/**
 * 
 * @export
 * @interface InlineResponse20027
 */
export interface InlineResponse20027 {
    /**
     * Закодированное значение этикетки (идентификатор поставки)
     * @type {string}
     * @memberof InlineResponse20027
     */
    barcode?: string;
    /**
     * Полное представление этикетки в заданном формате. (кодировка base64)
     * @type {string}
     * @memberof InlineResponse20027
     */
    file?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20028
 */
export interface InlineResponse20028 {
    /**
     * 
     * @type {Array<InlineResponse20028Orders>}
     * @memberof InlineResponse20028
     */
    orders?: Array<InlineResponse20028Orders>;
}
/**
 * 
 * @export
 * @interface InlineResponse20028Orders
 */
export interface InlineResponse20028Orders {
    /**
     * Идентификатор сборочного задания
     * @type {number}
     * @memberof InlineResponse20028Orders
     */
    id?: number;
    /**
     * Статус сборочного задания продавца (устанавливается продавцом)
     * @type {string}
     * @memberof InlineResponse20028Orders
     */
    supplierStatus?: InlineResponse20028Orders.SupplierStatusEnum;
    /**
     * Статус сборочного задания в системе Wildberries
     * @type {string}
     * @memberof InlineResponse20028Orders
     */
    wbStatus?: InlineResponse20028Orders.WbStatusEnum;
}

/**
 * @export
 * @namespace InlineResponse20028Orders
 */
export namespace InlineResponse20028Orders {
    /**
     * @export
     * @enum {string}
     */
    export enum SupplierStatusEnum {
        New = <any> 'new',
        Confirm = <any> 'confirm',
        Complete = <any> 'complete',
        Cancel = <any> 'cancel'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum WbStatusEnum {
        Waiting = <any> 'waiting',
        Sorted = <any> 'sorted',
        Sold = <any> 'sold',
        Canceled = <any> 'canceled',
        CanceledByClient = <any> 'canceled_by_client'
    }
}
/**
 * 
 * @export
 * @interface InlineResponse20029
 */
export interface InlineResponse20029 {
    /**
     * 
     * @type {Next}
     * @memberof InlineResponse20029
     */
    next?: Next;
    /**
     * 
     * @type {Array<Order>}
     * @memberof InlineResponse20029
     */
    orders?: Array<Order>;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * Массив сгенерированых баркодов
     * @type {Array<string>}
     * @memberof InlineResponse2003
     */
    data?: Array<string>;
    /**
     * Флаг ошибки.
     * @type {boolean}
     * @memberof InlineResponse2003
     */
    error?: boolean;
    /**
     * Описание ошибки.
     * @type {string}
     * @memberof InlineResponse2003
     */
    errorText?: string;
    /**
     * Дополнительные ошибки.
     * @type {string}
     * @memberof InlineResponse2003
     */
    additionalErrors?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20030
 */
export interface InlineResponse20030 {
    /**
     * Список новых сборочных заданий
     * @type {Array<Order>}
     * @memberof InlineResponse20030
     */
    orders?: Array<Order>;
}
/**
 * 
 * @export
 * @interface InlineResponse20031
 */
export interface InlineResponse20031 {
    /**
     * 
     * @type {Array<InlineResponse20031Stickers>}
     * @memberof InlineResponse20031
     */
    stickers?: Array<InlineResponse20031Stickers>;
}
/**
 * 
 * @export
 * @interface InlineResponse20031Stickers
 */
export interface InlineResponse20031Stickers {
    /**
     * Идентификатор сборочного задания
     * @type {number}
     * @memberof InlineResponse20031Stickers
     */
    orderId?: number;
    /**
     * Первая часть идентификатора этикетки (для печати подписи)
     * @type {number}
     * @memberof InlineResponse20031Stickers
     */
    partA?: number;
    /**
     * Вторая часть идентификатора этикетки
     * @type {number}
     * @memberof InlineResponse20031Stickers
     */
    partB?: number;
    /**
     * Закодированное значение этикетки
     * @type {string}
     * @memberof InlineResponse20031Stickers
     */
    barcode?: string;
    /**
     * Полное представление этикетки в заданном формате. (кодировка base64)
     * @type {string}
     * @memberof InlineResponse20031Stickers
     */
    file?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20032
 */
export interface InlineResponse20032 {
    /**
     * Общее количество РК всех статусов и типов
     * @type {number}
     * @memberof InlineResponse20032
     */
    all?: number;
    /**
     * Массив РК
     * @type {Array<InlineResponse20032Adverts>}
     * @memberof InlineResponse20032
     */
    adverts?: Array<InlineResponse20032Adverts>;
}
/**
 * 
 * @export
 * @interface InlineResponse20032Adverts
 */
export interface InlineResponse20032Adverts {
    /**
     * <dl> <dt>Тип РК:</dt> <dd><code>4</code> - реклама в каталоге</dd> <dd><code>5</code> - реклама в карточке товара</dd> <dd><code>6</code> - реклама в поиске</dd> <dd><code>7</code> - реклама в рекомендациях на главной странице</dd> </dl> 
     * @type {number}
     * @memberof InlineResponse20032Adverts
     */
    type?: number;
    /**
     * <dl> <dt>Статус РК:</dt> <dd><code>7</code> - РК завершена</dd> <dd><code>9</code> - идут показы</dd> <dd><code>11</code> - РК на паузе</dd> </dl> 
     * @type {number}
     * @memberof InlineResponse20032Adverts
     */
    status?: number;
    /**
     * Количество РК
     * @type {number}
     * @memberof InlineResponse20032Adverts
     */
    count?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20033
 */
export interface InlineResponse20033 {
    /**
     * Идентификатор РК
     * @type {number}
     * @memberof InlineResponse20033
     */
    advertId?: number;
    /**
     * <dl> <dt>Тип РК:</dt> <dd><code>4</code> - реклама в каталоге</dd> <dd><code>5</code> - реклама в карточке товара</dd> <dd><code>6</code> - реклама в поиске</dd> <dd><code>7</code> - реклама в рекомендациях на главной странице</dd> </dl> 
     * @type {number}
     * @memberof InlineResponse20033
     */
    type?: number;
    /**
     * <dl> <dt>Статус РК:</dt> <dd><code>7</code> - РК завершена</dd> <dd><code>9</code> - идут показы</dd> <dd><code>11</code> - РК на паузе</dd> </dl> 
     * @type {number}
     * @memberof InlineResponse20033
     */
    status?: number;
    /**
     * <p>Сумма дневного бюджета <span class=\"new\">new</span></p>
     * @type {string}
     * @memberof InlineResponse20033
     */
    dailyBudget?: string;
    /**
     * Время создания РК
     * @type {string}
     * @memberof InlineResponse20033
     */
    createTime?: string;
    /**
     * Время последнего изменения РК
     * @type {string}
     * @memberof InlineResponse20033
     */
    changeTime?: string;
    /**
     * <p>Время последнего запуска РК <span class=\"new\">new</span></p>
     * @type {string}
     * @memberof InlineResponse20033
     */
    startTime?: string;
    /**
     * <p>Время завершения РК (state 7) <span class=\"new\">new</span></p>
     * @type {string}
     * @memberof InlineResponse20033
     */
    endTime?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20034
 */
export interface InlineResponse20034 {
    /**
     * Идентификатор РК
     * @type {number}
     * @memberof InlineResponse20034
     */
    advertId?: number;
    /**
     * <dl> <dt>Тип РК:</dt> <dd><code>4</code> - реклама в каталоге</dd> <dd><code>5</code> - реклама в карточке товара</dd> <dd><code>6</code> - реклама в поиске</dd> <dd><code>7</code> - реклама в рекомендациях на главной странице</dd> </dl> 
     * @type {number}
     * @memberof InlineResponse20034
     */
    type?: number;
    /**
     * <dl> <dt>Статус РК:</dt> <dd><code>7</code> - РК завершена</dd> <dd><code>9</code> - идут показы</dd> <dd><code>11</code> - РК на паузе</dd> </dl> 
     * @type {number}
     * @memberof InlineResponse20034
     */
    status?: number;
    /**
     * Дневной бюджет, если не установлен, то 0
     * @type {number}
     * @memberof InlineResponse20034
     */
    dailyBudget?: number;
    /**
     * Время создания РК
     * @type {string}
     * @memberof InlineResponse20034
     */
    createTime?: string;
    /**
     * Время последнего изменения РК
     * @type {string}
     * @memberof InlineResponse20034
     */
    changeTime?: string;
    /**
     * Дата запуска РК
     * @type {string}
     * @memberof InlineResponse20034
     */
    startTime?: string;
    /**
     * Дата завершения РК
     * @type {string}
     * @memberof InlineResponse20034
     */
    endTime?: string;
    /**
     * Название РК
     * @type {string}
     * @memberof InlineResponse20034
     */
    name?: string;
    /**
     * Параметры РК
     * @type {Array<InlineResponse20034Params>}
     * @memberof InlineResponse20034
     */
    params?: Array<InlineResponse20034Params>;
}
/**
 * 
 * @export
 * @interface InlineResponse20034Intervals
 */
export interface InlineResponse20034Intervals {
    /**
     * Время начала показов
     * @type {number}
     * @memberof InlineResponse20034Intervals
     */
    begin?: number;
    /**
     * Время окончания показов
     * @type {number}
     * @memberof InlineResponse20034Intervals
     */
    end?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20034Nms
 */
export interface InlineResponse20034Nms {
    /**
     * Числовой идентификатор номенклатуры Wildberries (<code>nmId</code>)
     * @type {number}
     * @memberof InlineResponse20034Nms
     */
    nm?: number;
    /**
     * Состояние номенклатуры (<code>true</code> - активна или <code>false</code> - неактивна) 
     * @type {boolean}
     * @memberof InlineResponse20034Nms
     */
    active?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse20034Params
 */
export interface InlineResponse20034Params {
    /**
     * Название предметной группы (для РК в поиске и рекомендациях)
     * @type {string}
     * @memberof InlineResponse20034Params
     */
    subjectName?: string;
    /**
     * <p>Флаг активности РК, <code>true</code> - активна, <code>false</code> - неактивна <span class=\"new\">new</span></p>
     * @type {boolean}
     * @memberof InlineResponse20034Params
     */
    active?: boolean;
    /**
     * Интервалы часов показа РК
     * @type {Array<InlineResponse20034Intervals>}
     * @memberof InlineResponse20034Params
     */
    intervals?: Array<InlineResponse20034Intervals>;
    /**
     * Текущая ставка
     * @type {number}
     * @memberof InlineResponse20034Params
     */
    price?: number;
    /**
     * Идентификатор меню, где размещается РК (для РК в каталоге)
     * @type {number}
     * @memberof InlineResponse20034Params
     */
    menuId?: number;
    /**
     * Идентификатор предметной группы, для которой создана РК (для РК в поиске и рекомендациях)
     * @type {number}
     * @memberof InlineResponse20034Params
     */
    subjectId?: number;
    /**
     * Идентификатор сочетания предмета и пола (для РК в карточке товара)
     * @type {number}
     * @memberof InlineResponse20034Params
     */
    setId?: number;
    /**
     * Сочетание предмета и пола (для РК в карточке товара)
     * @type {string}
     * @memberof InlineResponse20034Params
     */
    setName?: string;
    /**
     * Название меню, где размещается РК (для РК в каталоге)
     * @type {any}
     * @memberof InlineResponse20034Params
     */
    menuName?: any;
    /**
     * Массив номенклатур РК
     * @type {Array<InlineResponse20034Nms>}
     * @memberof InlineResponse20034Params
     */
    nms?: Array<InlineResponse20034Nms>;
}
/**
 * 
 * @export
 * @interface InlineResponse20035
 */
export interface InlineResponse20035 {
    /**
     * Размер ставки
     * @type {number}
     * @memberof InlineResponse20035
     */
    cmp?: number;
    /**
     * Количество ставок
     * @type {number}
     * @memberof InlineResponse20035
     */
    count?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20036
 */
export interface InlineResponse20036 {
    /**
     * Значение параметра (param) запроса
     * @type {number}
     * @memberof InlineResponse20036
     */
    param?: number;
    /**
     * Информация о ставке(-ах)
     * @type {Array<Advv0allcpmCpm>}
     * @memberof InlineResponse20036
     */
    cpm?: Array<Advv0allcpmCpm>;
}
/**
 * 
 * @export
 * @interface InlineResponse20037
 */
export interface InlineResponse20037 {
    /**
     * Значение для параметра `subjectId`
     * @type {number}
     * @memberof InlineResponse20037
     */
    id?: number;
    /**
     * Название предметной группы, для которой создана РК
     * @type {string}
     * @memberof InlineResponse20037
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20038
 */
export interface InlineResponse20038 {
    /**
     * Значение для параметра `menuId`
     * @type {number}
     * @memberof InlineResponse20038
     */
    id?: number;
    /**
     * Название меню, где размещается РК
     * @type {string}
     * @memberof InlineResponse20038
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20039
 */
export interface InlineResponse20039 {
    /**
     * Значение для параметра `setId`
     * @type {number}
     * @memberof InlineResponse20039
     */
    id?: number;
    /**
     * Сочетание предмета и пола
     * @type {string}
     * @memberof InlineResponse20039
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {InlineResponse2004Data}
     * @memberof InlineResponse2004
     */
    data?: InlineResponse2004Data;
    /**
     * Флаг ошибки
     * @type {boolean}
     * @memberof InlineResponse2004
     */
    error?: boolean;
    /**
     * Описание ошибки
     * @type {string}
     * @memberof InlineResponse2004
     */
    errorText?: string;
    /**
     * Дополнительные ошибки
     * @type {any}
     * @memberof InlineResponse2004
     */
    additionalErrors?: any;
}
/**
 * 
 * @export
 * @interface InlineResponse20040
 */
export interface InlineResponse20040 {
    /**
     * 
     * @type {InlineResponse20040Data}
     * @memberof InlineResponse20040
     */
    data?: InlineResponse20040Data;
    /**
     * Есть ли ошибка
     * @type {boolean}
     * @memberof InlineResponse20040
     */
    error?: boolean;
    /**
     * Описание ошибки
     * @type {string}
     * @memberof InlineResponse20040
     */
    errorText?: string;
    /**
     * 
     * @type {any}
     * @memberof InlineResponse20040
     */
    additionalErrors?: any;
}
/**
 * 
 * @export
 * @interface InlineResponse20040Data
 */
export interface InlineResponse20040Data {
    /**
     * Количество неотвеченных вопросов
     * @type {number}
     * @memberof InlineResponse20040Data
     */
    countUnanswered?: number;
    /**
     * Количество неотвеченных вопросов за сегодня
     * @type {number}
     * @memberof InlineResponse20040Data
     */
    countUnansweredToday?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20041
 */
export interface InlineResponse20041 {
    /**
     * 
     * @type {InlineResponse20041Data}
     * @memberof InlineResponse20041
     */
    data?: InlineResponse20041Data;
    /**
     * Есть ли ошибка
     * @type {boolean}
     * @memberof InlineResponse20041
     */
    error?: boolean;
    /**
     * Описание ошибки
     * @type {string}
     * @memberof InlineResponse20041
     */
    errorText?: string;
    /**
     * 
     * @type {any}
     * @memberof InlineResponse20041
     */
    additionalErrors?: any;
}
/**
 * 
 * @export
 * @interface InlineResponse20041Data
 */
export interface InlineResponse20041Data {
    /**
     * Есть ли непросмотренные вопросы (`true` есть, `false` нет)
     * @type {boolean}
     * @memberof InlineResponse20041Data
     */
    hasNewQuestions?: boolean;
    /**
     * Есть ли непросмотренные отзывы (`true` есть, `false` нет)
     * @type {boolean}
     * @memberof InlineResponse20041Data
     */
    hasNewFeedbacks?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse20042
 */
export interface InlineResponse20042 {
    /**
     * 
     * @type {InlineResponse20042Data}
     * @memberof InlineResponse20042
     */
    data?: InlineResponse20042Data;
    /**
     * Есть ли ошибка
     * @type {boolean}
     * @memberof InlineResponse20042
     */
    error?: boolean;
    /**
     * Описание ошибки
     * @type {string}
     * @memberof InlineResponse20042
     */
    errorText?: string;
    /**
     * 
     * @type {any}
     * @memberof InlineResponse20042
     */
    additionalErrors?: any;
}
/**
 * 
 * @export
 * @interface InlineResponse20042Data
 */
export interface InlineResponse20042Data {
    /**
     * Массив структур товаров
     * @type {Array<InlineResponse20042DataProducts>}
     * @memberof InlineResponse20042Data
     */
    products?: Array<InlineResponse20042DataProducts>;
}
/**
 * 
 * @export
 * @interface InlineResponse20042DataProducts
 */
export interface InlineResponse20042DataProducts {
    /**
     * Артикул WB
     * @type {number}
     * @memberof InlineResponse20042DataProducts
     */
    nmId?: number;
    /**
     * Идентификатор карточки товара
     * @type {number}
     * @memberof InlineResponse20042DataProducts
     */
    imtId?: number;
    /**
     * Название товара
     * @type {string}
     * @memberof InlineResponse20042DataProducts
     */
    productName?: string;
    /**
     * Бренд товара
     * @type {string}
     * @memberof InlineResponse20042DataProducts
     */
    brandName?: string;
    /**
     * Количество вопросов
     * @type {string}
     * @memberof InlineResponse20042DataProducts
     */
    questionsCount?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20043
 */
export interface InlineResponse20043 {
    /**
     * 
     * @type {InlineResponse20043Data}
     * @memberof InlineResponse20043
     */
    data?: InlineResponse20043Data;
    /**
     * Есть ли ошибка
     * @type {boolean}
     * @memberof InlineResponse20043
     */
    error?: boolean;
    /**
     * Описание ошибки
     * @type {string}
     * @memberof InlineResponse20043
     */
    errorText?: string;
    /**
     * 
     * @type {any}
     * @memberof InlineResponse20043
     */
    additionalErrors?: any;
}
/**
 * 
 * @export
 * @interface InlineResponse20043Data
 */
export interface InlineResponse20043Data {
    /**
     * Количество необработанных вопросов
     * @type {number}
     * @memberof InlineResponse20043Data
     */
    countUnanswered?: number;
    /**
     * Количество обработанных вопросов
     * @type {number}
     * @memberof InlineResponse20043Data
     */
    countArchive?: number;
    /**
     * Массив структур вопросов
     * @type {Array<InlineResponse20043DataQuestions>}
     * @memberof InlineResponse20043Data
     */
    questions?: Array<InlineResponse20043DataQuestions>;
}
/**
 * Структура ответа
 * @export
 * @interface InlineResponse20043DataAnswer
 */
export interface InlineResponse20043DataAnswer {
    /**
     * Текст ответа
     * @type {string}
     * @memberof InlineResponse20043DataAnswer
     */
    text?: string;
    /**
     * Можно ли отредактировать ответ (`false` - нельзя, `true` - можно)
     * @type {boolean}
     * @memberof InlineResponse20043DataAnswer
     */
    editable?: boolean;
    /**
     * Дата и время создания ответа
     * @type {Date}
     * @memberof InlineResponse20043DataAnswer
     */
    createDate?: Date;
}
/**
 * Структура товара
 * @export
 * @interface InlineResponse20043DataProductDetails
 */
export interface InlineResponse20043DataProductDetails {
    /**
     * Артикул WB
     * @type {number}
     * @memberof InlineResponse20043DataProductDetails
     */
    nmId?: number;
    /**
     * Идентификатор карточки товара
     * @type {number}
     * @memberof InlineResponse20043DataProductDetails
     */
    imtId?: number;
    /**
     * Название товара
     * @type {string}
     * @memberof InlineResponse20043DataProductDetails
     */
    productName?: string;
    /**
     * Артикул продавца
     * @type {string}
     * @memberof InlineResponse20043DataProductDetails
     */
    supplierArticle?: string;
    /**
     * Имя продавца
     * @type {string}
     * @memberof InlineResponse20043DataProductDetails
     */
    supplierName?: string;
    /**
     * Название бренда
     * @type {string}
     * @memberof InlineResponse20043DataProductDetails
     */
    brandName?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20043DataQuestions
 */
export interface InlineResponse20043DataQuestions {
    /**
     * id вопроса
     * @type {string}
     * @memberof InlineResponse20043DataQuestions
     */
    id?: string;
    /**
     * Текст вопроса
     * @type {string}
     * @memberof InlineResponse20043DataQuestions
     */
    text?: string;
    /**
     * Дата и время создания вопроса
     * @type {Date}
     * @memberof InlineResponse20043DataQuestions
     */
    createdDate?: Date;
    /**
     * <dt>Статус вопроса:</dt> <dd>`none` - вопрос отклонён продавцом (такой вопрос не отображается на портале покупателей)</dd> <dd>`wbRu` - ответ предоставлен, вопрос отображается на сайте покупателей</dd> <dd>`suppliersPortalSynch` - новый вопрос</dd> 
     * @type {string}
     * @memberof InlineResponse20043DataQuestions
     */
    state?: string;
    /**
     * 
     * @type {InlineResponse20043DataAnswer}
     * @memberof InlineResponse20043DataQuestions
     */
    answer?: InlineResponse20043DataAnswer;
    /**
     * 
     * @type {InlineResponse20043DataProductDetails}
     * @memberof InlineResponse20043DataQuestions
     */
    productDetails?: InlineResponse20043DataProductDetails;
    /**
     * Просмотрен ли вопрос
     * @type {boolean}
     * @memberof InlineResponse20043DataQuestions
     */
    wasViewed?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse20044
 */
export interface InlineResponse20044 {
    /**
     * Есть ли ошибка
     * @type {boolean}
     * @memberof InlineResponse20044
     */
    error?: boolean;
    /**
     * Описание ошибки
     * @type {string}
     * @memberof InlineResponse20044
     */
    errorText?: string;
    /**
     * Дополнительные ошибки
     * @type {any}
     * @memberof InlineResponse20044
     */
    additionalErrors?: any;
}
/**
 * 
 * @export
 * @interface InlineResponse20045
 */
export interface InlineResponse20045 {
    /**
     * 
     * @type {InlineResponse20045Data}
     * @memberof InlineResponse20045
     */
    data?: InlineResponse20045Data;
    /**
     * Есть ли ошибка
     * @type {boolean}
     * @memberof InlineResponse20045
     */
    error?: boolean;
    /**
     * Описание ошибки
     * @type {string}
     * @memberof InlineResponse20045
     */
    errorText?: string;
    /**
     * 
     * @type {any}
     * @memberof InlineResponse20045
     */
    additionalErrors?: any;
}
/**
 * 
 * @export
 * @interface InlineResponse20045Data
 */
export interface InlineResponse20045Data {
    /**
     * Имя файла
     * @type {string}
     * @memberof InlineResponse20045Data
     */
    fileName?: string;
    /**
     * Файл
     * @type {Blob}
     * @memberof InlineResponse20045Data
     */
    file?: Blob;
    /**
     * Тип контента
     * @type {string}
     * @memberof InlineResponse20045Data
     */
    contentType?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20046
 */
export interface InlineResponse20046 {
    /**
     * 
     * @type {InlineResponse20046Data}
     * @memberof InlineResponse20046
     */
    data?: InlineResponse20046Data;
    /**
     * Есть ли ошибка
     * @type {boolean}
     * @memberof InlineResponse20046
     */
    error?: boolean;
    /**
     * Описание ошибки
     * @type {string}
     * @memberof InlineResponse20046
     */
    errorText?: string;
    /**
     * 
     * @type {any}
     * @memberof InlineResponse20046
     */
    additionalErrors?: any;
}
/**
 * 
 * @export
 * @interface InlineResponse20046Data
 */
export interface InlineResponse20046Data {
    /**
     * Количество необработанных отзывов
     * @type {number}
     * @memberof InlineResponse20046Data
     */
    countUnanswered?: number;
    /**
     * Количество необработанных отзывов за сегодня
     * @type {number}
     * @memberof InlineResponse20046Data
     */
    countUnansweredToday?: number;
    /**
     * Средняя оценка всех отзывов
     * @type {string}
     * @memberof InlineResponse20046Data
     */
    valuation?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20047
 */
export interface InlineResponse20047 {
    /**
     * 
     * @type {Array<InlineResponse20047Data>}
     * @memberof InlineResponse20047
     */
    data?: Array<InlineResponse20047Data>;
    /**
     * Есть ли ошибка
     * @type {boolean}
     * @memberof InlineResponse20047
     */
    error?: boolean;
    /**
     * Описание ошибки
     * @type {string}
     * @memberof InlineResponse20047
     */
    errorText?: string;
    /**
     * 
     * @type {any}
     * @memberof InlineResponse20047
     */
    additionalErrors?: any;
}
/**
 * 
 * @export
 * @interface InlineResponse20047Data
 */
export interface InlineResponse20047Data {
    /**
     * Id категории товара
     * @type {number}
     * @memberof InlineResponse20047Data
     */
    subjectId?: number;
    /**
     * Название категории товара
     * @type {string}
     * @memberof InlineResponse20047Data
     */
    subjectName?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20048
 */
export interface InlineResponse20048 {
    /**
     * 
     * @type {Array<InlineResponse20048Data>}
     * @memberof InlineResponse20048
     */
    data?: Array<InlineResponse20048Data>;
    /**
     * Есть ли ошибка
     * @type {boolean}
     * @memberof InlineResponse20048
     */
    error?: boolean;
    /**
     * Описание ошибки
     * @type {string}
     * @memberof InlineResponse20048
     */
    errorText?: string;
    /**
     * 
     * @type {any}
     * @memberof InlineResponse20048
     */
    additionalErrors?: any;
}
/**
 * 
 * @export
 * @interface InlineResponse20048Data
 */
export interface InlineResponse20048Data {
    /**
     * Средняя оценка товаров
     * @type {string}
     * @memberof InlineResponse20048Data
     */
    valuation?: string;
    /**
     * Количество отзывов по запрашиваемой категории
     * @type {number}
     * @memberof InlineResponse20048Data
     */
    feedbacksCount?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20049
 */
export interface InlineResponse20049 {
    /**
     * 
     * @type {Array<InlineResponse20049Data>}
     * @memberof InlineResponse20049
     */
    data?: Array<InlineResponse20049Data>;
    /**
     * Есть ли ошибка
     * @type {boolean}
     * @memberof InlineResponse20049
     */
    error?: boolean;
    /**
     * Описание ошибки
     * @type {string}
     * @memberof InlineResponse20049
     */
    errorText?: string;
    /**
     * 
     * @type {any}
     * @memberof InlineResponse20049
     */
    additionalErrors?: any;
}
/**
 * 
 * @export
 * @interface InlineResponse20049Data
 */
export interface InlineResponse20049Data {
    /**
     * 
     * @type {ProductRating}
     * @memberof InlineResponse20049Data
     */
    productMaxRating?: ProductRating;
    /**
     * 
     * @type {ProductRating}
     * @memberof InlineResponse20049Data
     */
    productMinRating?: ProductRating;
}
/**
 * 
 * @export
 * @interface InlineResponse2004Data
 */
export interface InlineResponse2004Data {
    /**
     * Список запрашиваемых КТ
     * @type {Array<InlineResponse2004DataCards>}
     * @memberof InlineResponse2004Data
     */
    cards?: Array<InlineResponse2004DataCards>;
    /**
     * 
     * @type {InlineResponse2004DataCursor}
     * @memberof InlineResponse2004Data
     */
    cursor?: InlineResponse2004DataCursor;
}
/**
 * 
 * @export
 * @interface InlineResponse2004DataCards
 */
export interface InlineResponse2004DataCards {
    /**
     * Массив размеров для номенклатуры (для безразмерного товара все равно нужно передавать данный массив с одним элементом и нулевым размером, но с ценой и баркодом) 
     * @type {Array<InlineResponse2004DataSizes>}
     * @memberof InlineResponse2004DataCards
     */
    sizes?: Array<InlineResponse2004DataSizes>;
    /**
     * Медиафайлы номенклатуры. <br>Фото, URL которого заканчивается на <b>1.jpg</b> является главным в карточке. 
     * @type {Array<string>}
     * @memberof InlineResponse2004DataCards
     */
    mediaFiles?: Array<string>;
    /**
     * Цвета номенклатуры
     * @type {Array<string>}
     * @memberof InlineResponse2004DataCards
     */
    colors?: Array<string>;
    /**
     * Дата обновления
     * @type {string}
     * @memberof InlineResponse2004DataCards
     */
    updateAt?: string;
    /**
     * Артикул продавца
     * @type {string}
     * @memberof InlineResponse2004DataCards
     */
    vendorCode?: string;
    /**
     * Брэнд
     * @type {string}
     * @memberof InlineResponse2004DataCards
     */
    brand?: string;
    /**
     * Категория для который создавалось КТ с данной НМ
     * @type {string}
     * @memberof InlineResponse2004DataCards
     */
    object?: string;
    /**
     * Артикул WB
     * @type {number}
     * @memberof InlineResponse2004DataCards
     */
    nmID?: number;
    /**
     * Идентификатор карточки товара (нужен для группирования НМ в одну КТ)
     * @type {number}
     * @memberof InlineResponse2004DataCards
     */
    imtID?: number;
    /**
     * Числовой идентификатор размера для данной номенклатуры Wildberries
     * @type {number}
     * @memberof InlineResponse2004DataCards
     */
    chrtID?: number;
    /**
     * `true` - категория карточки запрещена к реализации<br> `false` - категория карточки разрешена к реализации 
     * @type {boolean}
     * @memberof InlineResponse2004DataCards
     */
    isProhibited?: boolean;
    /**
     * Массив тегов
     * @type {Array<string>}
     * @memberof InlineResponse2004DataCards
     */
    tags?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineResponse2004DataCursor
 */
export interface InlineResponse2004DataCursor {
    /**
     * Дата с которой надо запрашивать следующий список КТ
     * @type {string}
     * @memberof InlineResponse2004DataCursor
     */
    updatedAt?: string;
    /**
     * Номер Артикула WB с которой надо запрашивтаь следующий список КТ
     * @type {number}
     * @memberof InlineResponse2004DataCursor
     */
    nmID?: number;
    /**
     * Кол-во возвращенных КТ
     * @type {number}
     * @memberof InlineResponse2004DataCursor
     */
    total?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2004DataSizes
 */
export interface InlineResponse2004DataSizes {
    /**
     * Размер товара (пример S, M, L, XL, 42, 42-43)
     * @type {string}
     * @memberof InlineResponse2004DataSizes
     */
    techSize?: string;
    /**
     * Массив баркодов, строковых идентификаторов размеров товара (их можно сгенерировать с помощью API, см. Viewer)
     * @type {Array<string>}
     * @memberof InlineResponse2004DataSizes
     */
    skus?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * 
     * @type {Array<InlineResponse2005Data>}
     * @memberof InlineResponse2005
     */
    data?: Array<InlineResponse2005Data>;
    /**
     * Флаг ошибки.
     * @type {boolean}
     * @memberof InlineResponse2005
     */
    error?: boolean;
    /**
     * Описание ошибки.
     * @type {string}
     * @memberof InlineResponse2005
     */
    errorText?: string;
    /**
     * Дополнительные ошибки.
     * @type {string}
     * @memberof InlineResponse2005
     */
    additionalErrors?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20050
 */
export interface InlineResponse20050 {
    /**
     * 
     * @type {InlineResponse20050Data}
     * @memberof InlineResponse20050
     */
    data?: InlineResponse20050Data;
    /**
     * Есть ли ошибка
     * @type {boolean}
     * @memberof InlineResponse20050
     */
    error?: boolean;
    /**
     * Описание ошибки
     * @type {string}
     * @memberof InlineResponse20050
     */
    errorText?: string;
    /**
     * 
     * @type {any}
     * @memberof InlineResponse20050
     */
    additionalErrors?: any;
}
/**
 * 
 * @export
 * @interface InlineResponse20050Data
 */
export interface InlineResponse20050Data {
    /**
     * Количество необработанных отзывов
     * @type {number}
     * @memberof InlineResponse20050Data
     */
    countUnanswered?: number;
    /**
     * Количество обработанных отзывов
     * @type {number}
     * @memberof InlineResponse20050Data
     */
    countArchive?: number;
    /**
     * 
     * @type {ResponseFeadback}
     * @memberof InlineResponse20050Data
     */
    feedbacks?: ResponseFeadback;
}
/**
 * 
 * @export
 * @interface InlineResponse20051
 */
export interface InlineResponse20051 {
    /**
     * 
     * @type {InlineResponse20051Data}
     * @memberof InlineResponse20051
     */
    data?: InlineResponse20051Data;
    /**
     * Есть ли ошибка
     * @type {boolean}
     * @memberof InlineResponse20051
     */
    error?: boolean;
    /**
     * Описание ошибки
     * @type {string}
     * @memberof InlineResponse20051
     */
    errorText?: string;
    /**
     * 
     * @type {any}
     * @memberof InlineResponse20051
     */
    additionalErrors?: any;
}
/**
 * 
 * @export
 * @interface InlineResponse20051Data
 */
export interface InlineResponse20051Data {
    /**
     * Имя файла
     * @type {string}
     * @memberof InlineResponse20051Data
     */
    fileName?: string;
    /**
     * Файл
     * @type {Blob}
     * @memberof InlineResponse20051Data
     */
    file?: Blob;
    /**
     * Тип контента
     * @type {string}
     * @memberof InlineResponse20051Data
     */
    contentType?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20052
 */
export interface InlineResponse20052 {
    /**
     * 
     * @type {InlineResponse20052Data}
     * @memberof InlineResponse20052
     */
    data?: InlineResponse20052Data;
    /**
     * Есть ли ошибка
     * @type {boolean}
     * @memberof InlineResponse20052
     */
    error?: boolean;
    /**
     * Описание ошибки
     * @type {string}
     * @memberof InlineResponse20052
     */
    errorText?: string;
    /**
     * 
     * @type {any}
     * @memberof InlineResponse20052
     */
    additionalErrors?: any;
}
/**
 * 
 * @export
 * @interface InlineResponse20052Data
 */
export interface InlineResponse20052Data {
    /**
     * 
     * @type {ResponseFeadback}
     * @memberof InlineResponse20052Data
     */
    feedbacks?: ResponseFeadback;
}
/**
 * 
 * @export
 * @interface InlineResponse20053
 */
export interface InlineResponse20053 {
    /**
     * 
     * @type {InlineResponse20053Data}
     * @memberof InlineResponse20053
     */
    data?: InlineResponse20053Data;
    /**
     * Есть ли ошибка
     * @type {boolean}
     * @memberof InlineResponse20053
     */
    error?: boolean;
    /**
     * Описание ошибки
     * @type {string}
     * @memberof InlineResponse20053
     */
    errorText?: string;
    /**
     * 
     * @type {any}
     * @memberof InlineResponse20053
     */
    additionalErrors?: any;
}
/**
 * 
 * @export
 * @interface InlineResponse20053Data
 */
export interface InlineResponse20053Data {
    /**
     * Средняя оценка товара
     * @type {string}
     * @memberof InlineResponse20053Data
     */
    valuation?: string;
    /**
     * Количество отзывов на данный товар
     * @type {number}
     * @memberof InlineResponse20053Data
     */
    feedbacksCount?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20054
 */
export interface InlineResponse20054 {
    /**
     * 
     * @type {InlineResponse20054Data}
     * @memberof InlineResponse20054
     */
    data?: InlineResponse20054Data;
}
/**
 * Массив данных
 * @export
 * @interface InlineResponse20054Data
 */
export interface InlineResponse20054Data {
    /**
     * Запрашиваемый `nmId`
     * @type {number}
     * @memberof InlineResponse20054Data
     */
    nm?: number;
    /**
     * Массив рекомендаций
     * @type {Array<number>}
     * @memberof InlineResponse20054Data
     */
    list?: Array<number>;
}
/**
 * 
 * @export
 * @interface InlineResponse2005Data
 */
export interface InlineResponse2005Data {
    /**
     * Категория для который создавалось КТ с данной НМ
     * @type {string}
     * @memberof InlineResponse2005Data
     */
    object?: string;
    /**
     * Артикул продавца
     * @type {string}
     * @memberof InlineResponse2005Data
     */
    vendorCode?: string;
    /**
     * Дата и время запроса на создание КТ с данным НМ
     * @type {string}
     * @memberof InlineResponse2005Data
     */
    updateAt?: string;
    /**
     * Список ошибок из-за которых не обработался запрос на создание КТ с данным НМ
     * @type {Array<string>}
     * @memberof InlineResponse2005Data
     */
    errors?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * 
     * @type {Array<InlineResponse2006Data>}
     * @memberof InlineResponse2006
     */
    data?: Array<InlineResponse2006Data>;
    /**
     * Флаг ошибки.
     * @type {boolean}
     * @memberof InlineResponse2006
     */
    error?: boolean;
    /**
     * Описание ошибки.
     * @type {string}
     * @memberof InlineResponse2006
     */
    errorText?: string;
    /**
     * Дополнительные ошибки.
     * @type {any}
     * @memberof InlineResponse2006
     */
    additionalErrors?: any;
}
/**
 * 
 * @export
 * @interface InlineResponse2006Data
 */
export interface InlineResponse2006Data {
    /**
     * Идентификатор карточки товара (нужен для группирования НМ в одно КТ)
     * @type {number}
     * @memberof InlineResponse2006Data
     */
    imtID?: number;
    /**
     * Артикул WB
     * @type {number}
     * @memberof InlineResponse2006Data
     */
    nmID?: number;
    /**
     * Артикул продавца
     * @type {string}
     * @memberof InlineResponse2006Data
     */
    vendorCode?: string;
    /**
     * `true` - категория карточки запрещена к реализации<br> `false` категория карточки разрешена к реализации 
     * @type {boolean}
     * @memberof InlineResponse2006Data
     */
    isProhibited?: boolean;
    /**
     * Медиафайлы номенклатуры. <br>Фото, URL которого заканчивается на <b>1.jpg</b> является главным в карточке. 
     * @type {Array<string>}
     * @memberof InlineResponse2006Data
     */
    mediaFiles?: Array<string>;
    /**
     * 
     * @type {Array<InlineResponse2006Sizes>}
     * @memberof InlineResponse2006Data
     */
    sizes?: Array<InlineResponse2006Sizes>;
    /**
     * Массив характеристик, индивидуальный для каждой категории
     * @type {Array<any>}
     * @memberof InlineResponse2006Data
     */
    characteristics?: Array<any>;
}
/**
 * 
 * @export
 * @interface InlineResponse2006Sizes
 */
export interface InlineResponse2006Sizes {
    /**
     * Размер товара (пример S, M, L, XL, 42, 42-43)
     * @type {string}
     * @memberof InlineResponse2006Sizes
     */
    techSize?: string;
    /**
     * Российский размер товара
     * @type {string}
     * @memberof InlineResponse2006Sizes
     */
    wbSize?: string;
    /**
     * Цена, `неактивно`, для уточнения цены используйте метод \"Получение информации о ценах\" раздел документации Цены. 
     * @type {number}
     * @memberof InlineResponse2006Sizes
     */
    price?: number;
    /**
     * Числовой идентификатор размера для данной номенклатуры Wildberries
     * @type {number}
     * @memberof InlineResponse2006Sizes
     */
    chrtID?: number;
    /**
     * Массив баркодов, строковых идентификаторов размеров товара (их можно сгенерировать с помощью API, см. Viewer)
     * @type {Array<string>}
     * @memberof InlineResponse2006Sizes
     */
    skus?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * 
     * @type {InlineResponse2007Data}
     * @memberof InlineResponse2007
     */
    data?: InlineResponse2007Data;
    /**
     * Флаг ошибки
     * @type {boolean}
     * @memberof InlineResponse2007
     */
    error?: boolean;
    /**
     * Описание ошибки
     * @type {string}
     * @memberof InlineResponse2007
     */
    errorText?: string;
    /**
     * Дополнительные ошибки
     * @type {any}
     * @memberof InlineResponse2007
     */
    additionalErrors?: any;
}
/**
 * 
 * @export
 * @interface InlineResponse2007Data
 */
export interface InlineResponse2007Data {
    /**
     * Количество бесплатных лимитов
     * @type {number}
     * @memberof InlineResponse2007Data
     */
    freeLimits?: number;
    /**
     * Количество оплаченных лимитов
     * @type {number}
     * @memberof InlineResponse2007Data
     */
    paidLimits?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     * 
     * @type {Array<InlineResponse2008Data>}
     * @memberof InlineResponse2008
     */
    data?: Array<InlineResponse2008Data>;
    /**
     * Флаг ошибки.
     * @type {boolean}
     * @memberof InlineResponse2008
     */
    error?: boolean;
    /**
     * Описание ошибки.
     * @type {string}
     * @memberof InlineResponse2008
     */
    errorText?: string;
    /**
     * Дополнительные ошибки.
     * @type {string}
     * @memberof InlineResponse2008
     */
    additionalErrors?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2008Data
 */
export interface InlineResponse2008Data {
    /**
     * Название категории
     * @type {string}
     * @memberof InlineResponse2008Data
     */
    objectName?: string;
    /**
     * Название родительской категории
     * @type {string}
     * @memberof InlineResponse2008Data
     */
    parentName?: string;
    /**
     * Виден на сайте
     * @type {boolean}
     * @memberof InlineResponse2008Data
     */
    isVisible?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
    /**
     * 
     * @type {Array<InlineResponse2009Data>}
     * @memberof InlineResponse2009
     */
    data?: Array<InlineResponse2009Data>;
    /**
     * Флаг ошибки.
     * @type {boolean}
     * @memberof InlineResponse2009
     */
    error?: boolean;
    /**
     * Описание ошибки.
     * @type {string}
     * @memberof InlineResponse2009
     */
    errorText?: string;
    /**
     * Дополнительные ошибки.
     * @type {string}
     * @memberof InlineResponse2009
     */
    additionalErrors?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2009Data
 */
export interface InlineResponse2009Data {
    /**
     * Название категории
     * @type {string}
     * @memberof InlineResponse2009Data
     */
    name?: string;
    /**
     * Виден на сайте
     * @type {boolean}
     * @memberof InlineResponse2009Data
     */
    isVisible?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse201
 */
export interface InlineResponse201 {
    /**
     * Идентификатор поставки
     * @type {string}
     * @memberof InlineResponse201
     */
    id?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse400
 */
export interface InlineResponse400 {
}
/**
 * 
 * @export
 * @interface InlineResponse4001
 */
export interface InlineResponse4001 {
}
/**
 * 
 * @export
 * @interface InlineResponse40010
 */
export interface InlineResponse40010 {
}
/**
 * 
 * @export
 * @interface InlineResponse40011
 */
export interface InlineResponse40011 {
}
/**
 * 
 * @export
 * @interface InlineResponse4002
 */
export interface InlineResponse4002 {
}
/**
 * 
 * @export
 * @interface InlineResponse4003
 */
export interface InlineResponse4003 {
}
/**
 * 
 * @export
 * @interface InlineResponse4004
 */
export interface InlineResponse4004 {
}
/**
 * 
 * @export
 * @interface InlineResponse4005
 */
export interface InlineResponse4005 {
}
/**
 * 
 * @export
 * @interface InlineResponse4006
 */
export interface InlineResponse4006 {
}
/**
 * 
 * @export
 * @interface InlineResponse4007
 */
export interface InlineResponse4007 {
}
/**
 * 
 * @export
 * @interface InlineResponse4008
 */
export interface InlineResponse4008 {
}
/**
 * 
 * @export
 * @interface InlineResponse4009
 */
export interface InlineResponse4009 {
}
/**
 * 
 * @export
 * @interface InlineResponse401
 */
export interface InlineResponse401 {
}
/**
 * 
 * @export
 * @interface InlineResponse4011
 */
export interface InlineResponse4011 {
}
/**
 * 
 * @export
 * @interface InlineResponse4012
 */
export interface InlineResponse4012 {
}
/**
 * 
 * @export
 * @interface InlineResponse422
 */
export interface InlineResponse422 {
}
/**
 * 
 * @export
 * @interface InlineResponse4221
 */
export interface InlineResponse4221 {
}
/**
 * 
 * @export
 * @interface InlineResponse4222
 */
export interface InlineResponse4222 {
}
/**
 * 
 * @export
 * @interface InlineResponse4223
 */
export interface InlineResponse4223 {
}
/**
 * 
 * @export
 * @interface InlineResponse4224
 */
export interface InlineResponse4224 {
}
/**
 * 
 * @export
 */
export type InvalidRcId = string
/**
 * 
 * @export
 * @interface MediaFileBody
 */
export interface MediaFileBody {
    /**
     * 
     * @type {Blob}
     * @memberof MediaFileBody
     */
    uploadfile?: Blob;
}
/**
 * 
 * @export
 * @interface MediaSaveBody
 */
export interface MediaSaveBody {
    /**
     * Артикул продавца
     * @type {string}
     * @memberof MediaSaveBody
     */
    vendorCode?: string;
    /**
     * Ссылки на изображения в том порядке, в котором мы хотим их увидеть в карточке товара.
     * @type {Array<string>}
     * @memberof MediaSaveBody
     */
    data?: Array<string>;
}
/**
 * 
 * @export
 * @interface MetaSgtinBody
 */
export interface MetaSgtinBody {
    /**
     * Массив КиЗов.
     * @type {Array<Apiv3ordersordermetasgtinSgtin>}
     * @memberof MetaSgtinBody
     */
    sgtin?: Array<Apiv3ordersordermetasgtinSgtin>;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * Код ошибки
     * @type {string}
     * @memberof ModelError
     */
    code?: string;
    /**
     * Описание ошибки
     * @type {string}
     * @memberof ModelError
     */
    message?: string;
    /**
     * Дополнительные данные, обогащающие ошибку
     * @type {any}
     * @memberof ModelError
     */
    data?: any;
}
/**
 * Параметр пагинации. Содержит значение, которое необходимо указать в запросе для получения следующего пакета данных
 * @export
 */
export type Next = number
/**
 * 
 * @export
 * @interface NomenclatureLinkBody
 */
export interface NomenclatureLinkBody {
    /**
     * Артикул WB
     * @type {number}
     * @memberof NomenclatureLinkBody
     */
    nmID?: number;
    /**
     * Массив числовых идентификаторов тегов.<br>   Что бы снять теги с КТ, необходимо передать пустой массив.<br> Чтобы добавить теги к уже имеющимся в КТ, необходимо в запросе передать новые теги и теги, которые уже есть в КТ. 
     * @type {Array<number>}
     * @memberof NomenclatureLinkBody
     */
    tagsIDs?: Array<number>;
}
/**
 * 
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * Идентификатор сборочного задания в Маркетплейсе
     * @type {number}
     * @memberof Order
     */
    id?: number;
    /**
     * Идентификатор сборочного задания в системе Wildberries
     * @type {string}
     * @memberof Order
     */
    rid?: string;
    /**
     * Дата создания сборочного задания (RFC3339)
     * @type {Date}
     * @memberof Order
     */
    createdAt?: Date;
    /**
     * Идентификатор склада продавца, на который поступило сборочное задание
     * @type {number}
     * @memberof Order
     */
    warehouseId?: number;
    /**
     * Идентификатор поставки. Возвращается, если заказ закреплён за поставкой
     * @type {string}
     * @memberof Order
     */
    supplyId?: string;
    /**
     * Массив приоритетных СЦ для доставки сборочного задания. Если поле не заполнено или массив пустой, приоритетного СЦ для данного сборочного задания нет
     * @type {Array<string>}
     * @memberof Order
     */
    prioritySc?: Array<string>;
    /**
     * Список офисов, куда следует привезти товар
     * @type {Array<string>}
     * @memberof Order
     */
    offices?: Array<string>;
    /**
     * 
     * @type {OrderAddress}
     * @memberof Order
     */
    address?: OrderAddress;
    /**
     * 
     * @type {OrderUser}
     * @memberof Order
     */
    user?: OrderUser;
    /**
     * Массив баркодов товара
     * @type {Array<string>}
     * @memberof Order
     */
    skus?: Array<string>;
    /**
     * Цена в валюте продажи с учетом всех скидок, умноженная на 100. Код валюты продажи в поле currencyCode.
     * @type {number}
     * @memberof Order
     */
    price?: number;
    /**
     * Цена в валюте продажи с учетом всех скидок, сконвертированная по курсу на момент продажи в российские копейки. Предоставляется в информационных целях.
     * @type {number}
     * @memberof Order
     */
    convertedPrice?: number;
    /**
     * Код валюты продажи (ISO 4217)
     * @type {number}
     * @memberof Order
     */
    currencyCode?: number;
    /**
     * Код валюты страны поставщика (ISO 4217)
     * @type {number}
     * @memberof Order
     */
    convertedCurrencyCode?: number;
    /**
     * Идентификатор транзакции для группировки сборочных заданий. Сборочные задания в одной корзине покупателя будут иметь одинаковый orderUID
     * @type {string}
     * @memberof Order
     */
    orderUid?: string;
    /**
     * Тип доставки: fbs - доставка на склад Wildberries, dbs - доставка силами продавца 
     * @type {string}
     * @memberof Order
     */
    deliveryType?: Order.DeliveryTypeEnum;
    /**
     * Артикул WB
     * @type {number}
     * @memberof Order
     */
    nmId?: number;
    /**
     * Идентификатор размера товара в системе Wildberries
     * @type {number}
     * @memberof Order
     */
    chrtId?: number;
    /**
     * Артикул продавца
     * @type {string}
     * @memberof Order
     */
    article?: string;
    /**
     * сКГТ-признак товара, на который был сделан заказ
     * @type {boolean}
     * @memberof Order
     */
    isLargeCargo?: boolean;
}

/**
 * @export
 * @namespace Order
 */
export namespace Order {
    /**
     * @export
     * @enum {string}
     */
    export enum DeliveryTypeEnum {
        Dbs = <any> 'dbs',
        Fbs = <any> 'fbs'
    }
}
/**
 * Детализованный адрес покупателя для доставки (если применимо). Некоторые из полей могут прийти пустыми из-за специфики адреса
 * @export
 * @interface OrderAddress
 */
export interface OrderAddress {
    /**
     * Область
     * @type {string}
     * @memberof OrderAddress
     */
    province?: string;
    /**
     * Район
     * @type {string}
     * @memberof OrderAddress
     */
    area?: string;
    /**
     * Город
     * @type {string}
     * @memberof OrderAddress
     */
    city?: string;
    /**
     * Улица
     * @type {string}
     * @memberof OrderAddress
     */
    street?: string;
    /**
     * Номер дома
     * @type {string}
     * @memberof OrderAddress
     */
    home?: string;
    /**
     * Номер квартиры
     * @type {string}
     * @memberof OrderAddress
     */
    flat?: string;
    /**
     * Подъезд
     * @type {string}
     * @memberof OrderAddress
     */
    entrance?: string;
    /**
     * Координата долготы
     * @type {number}
     * @memberof OrderAddress
     */
    longitude?: number;
    /**
     * Координаты широты
     * @type {number}
     * @memberof OrderAddress
     */
    latitude?: number;
}
/**
 * Информация о покупателе (только для доставки силами продавца)
 * @export
 * @interface OrderUser
 */
export interface OrderUser {
    /**
     * ФИО
     * @type {string}
     * @memberof OrderUser
     */
    fio?: string;
    /**
     * Номер телефона
     * @type {string}
     * @memberof OrderUser
     */
    phone?: string;
}
/**
 * 
 * @export
 * @interface OrdersItem
 */
export interface OrdersItem {
    /**
     * Номер заказа. Объединяет все позиции одного заказа.
     * @type {string}
     * @memberof OrdersItem
     */
    gNumber?: string;
    /**
     * Дата и время заказа. Это поле соответствует параметру `dateFrom` в запросе, если параметр `flag=1`. Если часовой пояс не указан, то берется Московское время UTC+3.
     * @type {Date}
     * @memberof OrdersItem
     */
    date?: Date;
    /**
     * Дата и время обновления информации в сервисе. Это поле соответствует параметру `dateFrom` в запросе, если параметр `flag=0` или не указан. Если часовой пояс не указан, то берется Московское время UTC+3.
     * @type {Date}
     * @memberof OrdersItem
     */
    lastChangeDate?: Date;
    /**
     * Артикул продавца
     * @type {string}
     * @memberof OrdersItem
     */
    supplierArticle?: string;
    /**
     * Размер товара (пример S, M, L, XL, 42, 42-43)
     * @type {string}
     * @memberof OrdersItem
     */
    techSize?: string;
    /**
     * Бар-код
     * @type {string}
     * @memberof OrdersItem
     */
    barcode?: string;
    /**
     * Цена до согласованной итоговой скидки/промо/спп. Для получения цены со скидкой можно воспользоваться формулой `priceWithDiscount = totalPrice * (1 - discountPercent/100)`
     * @type {number}
     * @memberof OrdersItem
     */
    totalPrice?: number;
    /**
     * Согласованный итоговый дисконт. Будучи примененным к `totalPrice`, даёт сумму к оплате.
     * @type {number}
     * @memberof OrdersItem
     */
    discountPercent?: number;
    /**
     * Название склада отгрузки
     * @type {string}
     * @memberof OrdersItem
     */
    warehouseName?: string;
    /**
     * Область
     * @type {string}
     * @memberof OrdersItem
     */
    oblast?: string;
    /**
     * Номер поставки (от продавца на склад)
     * @type {number}
     * @memberof OrdersItem
     */
    incomeID?: number;
    /**
     * Уникальный идентификатор позиции заказа. Может использоваться для поиска соответствия между заказами и продажами.
     * @type {number}
     * @memberof OrdersItem
     */
    odid?: number;
    /**
     * Артикул WB
     * @type {number}
     * @memberof OrdersItem
     */
    nmId?: number;
    /**
     * Предмет
     * @type {string}
     * @memberof OrdersItem
     */
    subject?: string;
    /**
     * Категория
     * @type {string}
     * @memberof OrdersItem
     */
    category?: string;
    /**
     * Бренд
     * @type {string}
     * @memberof OrdersItem
     */
    brand?: string;
    /**
     * Отмена заказа. true - заказ отменен до оплаты.
     * @type {boolean}
     * @memberof OrdersItem
     */
    isCancel?: boolean;
    /**
     * Дата и время отмены заказа. Если заказ не был отменен, то `\"0001-01-01T00:00:00\"`. Если часовой пояс не указан, то берется Московское время UTC+3.
     * @type {Date}
     * @memberof OrdersItem
     */
    cancelDt?: Date;
    /**
     * Цифровое значение стикера, который клеится на товар в процессе сборки заказа по системе Маркетплейс.
     * @type {string}
     * @memberof OrdersItem
     */
    sticker?: string;
    /**
     * Уникальный идентификатор заказа, функционально аналогичный `odid`/`rid`.  Данный параметр введен в июле'22 и в течение переходного периода может быть заполнен не во всех ответах. Примечание для работающих по системе Маркетплейс: `srid` равен `rid` в ответе на метод `GET /api/v2/orders`. 
     * @type {string}
     * @memberof OrdersItem
     */
    srid?: string;
}
/**
 * 
 * @export
 * @interface OrdersStatusBody
 */
export interface OrdersStatusBody {
    /**
     * Список идентификаторов сборочных заданий
     * @type {Array<number>}
     * @memberof OrdersStatusBody
     */
    orders?: Array<number>;
}
/**
 * 
 * @export
 * @interface OrdersStickersBody
 */
export interface OrdersStickersBody {
    /**
     * Массив идентификаторов сборочных заданий
     * @type {Array<number>}
     * @memberof OrdersStickersBody
     */
    orders?: Array<number>;
}
/**
 * 
 * @export
 * @interface ProductRating
 */
export interface ProductRating {
    /**
     * Артикул WB
     * @type {number}
     * @memberof ProductRating
     */
    nmId?: number;
    /**
     * Идентификатор карточки товара
     * @type {number}
     * @memberof ProductRating
     */
    imtId?: number;
    /**
     * Сумма оценок
     * @type {number}
     * @memberof ProductRating
     */
    valuationsSum?: number;
    /**
     * Количество отзывов
     * @type {number}
     * @memberof ProductRating
     */
    feedbacksCount?: number;
    /**
     * Средняя оценка
     * @type {number}
     * @memberof ProductRating
     */
    valuation?: number;
    /**
     * Название товара
     * @type {string}
     * @memberof ProductRating
     */
    productName?: string;
    /**
     * Артикул продавца
     * @type {string}
     * @memberof ProductRating
     */
    supplierArticle?: string;
    /**
     * Бренд товара
     * @type {string}
     * @memberof ProductRating
     */
    brandName?: string;
}
/**
 * 
 * @export
 */
export type RequestBodyProcessError = string
/**
 * 
 * @export
 * @interface ResponseBody400LenName
 */
export interface ResponseBody400LenName {
    /**
     * 
     * @type {any}
     * @memberof ResponseBody400LenName
     */
    data?: any;
    /**
     * Флаг ошибки
     * @type {boolean}
     * @memberof ResponseBody400LenName
     */
    error?: boolean;
    /**
     * Описание ошибки
     * @type {string}
     * @memberof ResponseBody400LenName
     */
    errorText?: string;
    /**
     * 
     * @type {ResponseNotFound200AdditionalErrors}
     * @memberof ResponseBody400LenName
     */
    additionalErrors?: ResponseNotFound200AdditionalErrors;
}
/**
 * 
 * @export
 * @interface ResponseBodyError400
 */
export interface ResponseBodyError400 {
    /**
     * 
     * @type {any}
     * @memberof ResponseBodyError400
     */
    data?: any;
    /**
     * Флаг ошибки
     * @type {boolean}
     * @memberof ResponseBodyError400
     */
    error?: boolean;
    /**
     * Описание ошибки
     * @type {string}
     * @memberof ResponseBodyError400
     */
    errorText?: string;
    /**
     * Дополнительные ошибки
     * @type {any}
     * @memberof ResponseBodyError400
     */
    additionalErrors?: any;
}
/**
 * 
 * @export
 * @interface ResponseBodyError403
 */
export interface ResponseBodyError403 {
    /**
     * 
     * @type {any}
     * @memberof ResponseBodyError403
     */
    data?: any;
    /**
     * Флаг ошибки
     * @type {boolean}
     * @memberof ResponseBodyError403
     */
    error?: boolean;
    /**
     * Описание ошибки
     * @type {string}
     * @memberof ResponseBodyError403
     */
    errorText?: string;
    /**
     * Дополнительные ошибки
     * @type {string}
     * @memberof ResponseBodyError403
     */
    additionalErrors?: string;
}
/**
 * 
 * @export
 * @interface ResponseBodyError500
 */
export interface ResponseBodyError500 {
    /**
     * 
     * @type {any}
     * @memberof ResponseBodyError500
     */
    data?: any;
    /**
     * Флаг ошибки
     * @type {boolean}
     * @memberof ResponseBodyError500
     */
    error?: boolean;
    /**
     * Описание ошибки
     * @type {string}
     * @memberof ResponseBodyError500
     */
    errorText?: string;
    /**
     * Дополнительные ошибки
     * @type {any}
     * @memberof ResponseBodyError500
     */
    additionalErrors?: any;
}
/**
 * 
 * @export
 * @interface ResponseBodyLimitTag
 */
export interface ResponseBodyLimitTag {
    /**
     * 
     * @type {any}
     * @memberof ResponseBodyLimitTag
     */
    data?: any;
    /**
     * Флаг ошибки
     * @type {boolean}
     * @memberof ResponseBodyLimitTag
     */
    error?: boolean;
    /**
     * Описание ошибки
     * @type {string}
     * @memberof ResponseBodyLimitTag
     */
    errorText?: string;
    /**
     * Дополнительные ошибки
     * @type {any}
     * @memberof ResponseBodyLimitTag
     */
    additionalErrors?: any;
}
/**
 * 
 * @export
 * @interface ResponseBodyNameNotExist
 */
export interface ResponseBodyNameNotExist {
    /**
     * 
     * @type {any}
     * @memberof ResponseBodyNameNotExist
     */
    data?: any;
    /**
     * Флаг ошибки
     * @type {boolean}
     * @memberof ResponseBodyNameNotExist
     */
    error?: boolean;
    /**
     * Описание ошибки
     * @type {string}
     * @memberof ResponseBodyNameNotExist
     */
    errorText?: string;
    /**
     * Дополнительные ошибки
     * @type {any}
     * @memberof ResponseBodyNameNotExist
     */
    additionalErrors?: any;
}
/**
 * 
 * @export
 * @interface ResponseBodyTagNotExist
 */
export interface ResponseBodyTagNotExist {
    /**
     * 
     * @type {any}
     * @memberof ResponseBodyTagNotExist
     */
    data?: any;
    /**
     * Флаг ошибки
     * @type {boolean}
     * @memberof ResponseBodyTagNotExist
     */
    error?: boolean;
    /**
     * Описание ошибки
     * @type {string}
     * @memberof ResponseBodyTagNotExist
     */
    errorText?: string;
    /**
     * 
     * @type {ResponseBodyTagNotExistAdditionalErrors}
     * @memberof ResponseBodyTagNotExist
     */
    additionalErrors?: ResponseBodyTagNotExistAdditionalErrors;
}
/**
 * Дополнительные ошибки
 * @export
 * @interface ResponseBodyTagNotExistAdditionalErrors
 */
export interface ResponseBodyTagNotExistAdditionalErrors {
    /**
     * 
     * @type {string}
     * @memberof ResponseBodyTagNotExistAdditionalErrors
     */
    tagID?: string;
}
/**
 * Массив структур отзывов
 * @export
 */
export type ResponseFeadback = Array<ResponseFeadbackInner>
/**
 * 
 * @export
 * @interface ResponseFeadbackInner
 */
export interface ResponseFeadbackInner {
    /**
     * Id отзыва
     * @type {string}
     * @memberof ResponseFeadbackInner
     */
    id?: string;
    /**
     * Имя автора отзыва
     * @type {string}
     * @memberof ResponseFeadbackInner
     */
    userName?: string;
    /**
     * <dl> <dt>   Соответствие заявленного размера реальному. <span class=\"new\">new</span>   <br>Возможные значения: </dt> <dd>\"\" - для безразмерных товаров,</dd> <dd>\"ок\" - соответствует размеру,</dd> <dd>\"smaller\" - маломерит,</dd> <dd>\"bigger\" - большемерит</dd>               </dl>                       
     * @type {string}
     * @memberof ResponseFeadbackInner
     */
    matchingSize?: string;
    /**
     * Текст отзыва
     * @type {string}
     * @memberof ResponseFeadbackInner
     */
    text?: string;
    /**
     * Оценка товара
     * @type {number}
     * @memberof ResponseFeadbackInner
     */
    productValuation?: number;
    /**
     * Дата и время создания отзыва
     * @type {Date}
     * @memberof ResponseFeadbackInner
     */
    createdDate?: Date;
    /**
     * Дата и время обновления отзыва
     * @type {Date}
     * @memberof ResponseFeadbackInner
     */
    updatedDate?: Date;
    /**
     * <dt>Статус вопроса:</dt> <dd>`none` - не обработан (новый)</dd> <dd>`wbRu` - обработан</dd> <dd>`deleted` - удален</dd> 
     * @type {string}
     * @memberof ResponseFeadbackInner
     */
    state?: string;
    /**
     * Структура ответа
     * @type {any}
     * @memberof ResponseFeadbackInner
     */
    answer?: any;
    /**
     * Структура товара
     * @type {any}
     * @memberof ResponseFeadbackInner
     */
    productDetails?: any;
    /**
     * Массив структур фотографий
     * @type {Array<any>}
     * @memberof ResponseFeadbackInner
     */
    photoLinks?: Array<any>;
    /**
     * Структура видео
     * @type {any}
     * @memberof ResponseFeadbackInner
     */
    video?: any;
    /**
     * Просмотрен ли отзыв
     * @type {boolean}
     * @memberof ResponseFeadbackInner
     */
    wasViewed?: boolean;
    /**
     * Можно ли оставить жалобу (`true` - да, `false` - нет) <br> Жалобу можно оставить, если с момента создания отзыва прошло менее 30 дней. 
     * @type {boolean}
     * @memberof ResponseFeadbackInner
     */
    isCreationSupplierComplaint?: boolean;
    /**
     * Жалоба на отзыв
     * @type {any}
     * @memberof ResponseFeadbackInner
     */
    supplierComplaint?: any;
}
/**
 * 
 * @export
 * @interface ResponseNotFound200
 */
export interface ResponseNotFound200 {
    /**
     * 
     * @type {any}
     * @memberof ResponseNotFound200
     */
    data?: any;
    /**
     * Флаг ошибки
     * @type {boolean}
     * @memberof ResponseNotFound200
     */
    error?: boolean;
    /**
     * Описание ошибки
     * @type {string}
     * @memberof ResponseNotFound200
     */
    errorText?: string;
    /**
     * 
     * @type {ResponseNotFound200AdditionalErrors}
     * @memberof ResponseNotFound200
     */
    additionalErrors?: ResponseNotFound200AdditionalErrors;
}
/**
 * Дополнительные ошибки
 * @export
 * @interface ResponseNotFound200AdditionalErrors
 */
export interface ResponseNotFound200AdditionalErrors {
    /**
     * 
     * @type {string}
     * @memberof ResponseNotFound200AdditionalErrors
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface ResponseNotFound200Del
 */
export interface ResponseNotFound200Del {
    /**
     * 
     * @type {any}
     * @memberof ResponseNotFound200Del
     */
    data?: any;
    /**
     * Флаг ошибки
     * @type {boolean}
     * @memberof ResponseNotFound200Del
     */
    error?: boolean;
    /**
     * Описание ошибки
     * @type {string}
     * @memberof ResponseNotFound200Del
     */
    errorText?: string;
    /**
     * 
     * @type {ResponseNotFound200AdditionalErrors}
     * @memberof ResponseNotFound200Del
     */
    additionalErrors?: ResponseNotFound200AdditionalErrors;
}
/**
 * 
 * @export
 * @interface ResponseOK200
 */
export interface ResponseOK200 {
    /**
     * 
     * @type {any}
     * @memberof ResponseOK200
     */
    data?: any;
    /**
     * Флаг ошибки
     * @type {boolean}
     * @memberof ResponseOK200
     */
    error?: boolean;
    /**
     * Описание ошибки
     * @type {string}
     * @memberof ResponseOK200
     */
    errorText?: string;
    /**
     * Дополнительные ошибки
     * @type {any}
     * @memberof ResponseOK200
     */
    additionalErrors?: any;
}
/**
 * 
 * @export
 * @interface SalesItem
 */
export interface SalesItem {
    /**
     * Номер заказа. Объединяет все позиции одного заказа.
     * @type {string}
     * @memberof SalesItem
     */
    gNumber?: string;
    /**
     * Дата и время продажи. Это поле соответствует параметру `dateFrom` в запросе, если параметр `flag=1`. Если часовой пояс не указан, то берется Московское время UTC+3.
     * @type {Date}
     * @memberof SalesItem
     */
    date?: Date;
    /**
     * Дата и время обновления информации в сервисе. Это поле соответствует параметру `dateFrom` в запросе, если параметр `flag=0` или не указан. Если часовой пояс не указан, то берется Московское время UTC+3.
     * @type {Date}
     * @memberof SalesItem
     */
    lastChangeDate?: Date;
    /**
     * Артикул продавца
     * @type {string}
     * @memberof SalesItem
     */
    supplierArticle?: string;
    /**
     * Размер товара (пример S, M, L, XL, 42, 42-43)
     * @type {string}
     * @memberof SalesItem
     */
    techSize?: string;
    /**
     * Бар-код
     * @type {string}
     * @memberof SalesItem
     */
    barcode?: string;
    /**
     * Цена до согласованной скидки/промо/спп. Для получения цены со скидкой можно воспользоваться формулой `priceWithDiscount = totalPrice * (1 - discountPercent/100)`
     * @type {number}
     * @memberof SalesItem
     */
    totalPrice?: number;
    /**
     * Согласованный итоговый дисконт
     * @type {number}
     * @memberof SalesItem
     */
    discountPercent?: number;
    /**
     * Договор поставки
     * @type {boolean}
     * @memberof SalesItem
     */
    isSupply?: boolean;
    /**
     * Договор реализации
     * @type {boolean}
     * @memberof SalesItem
     */
    isRealization?: boolean;
    /**
     * Скидка по промокоду
     * @type {number}
     * @memberof SalesItem
     */
    promoCodeDiscount?: number;
    /**
     * Название склада отгрузки
     * @type {string}
     * @memberof SalesItem
     */
    warehouseName?: string;
    /**
     * Страна
     * @type {string}
     * @memberof SalesItem
     */
    countryName?: string;
    /**
     * Округ
     * @type {string}
     * @memberof SalesItem
     */
    oblastOkrugName?: string;
    /**
     * Регион
     * @type {string}
     * @memberof SalesItem
     */
    regionName?: string;
    /**
     * Номер поставки (от продавца на склад)
     * @type {number}
     * @memberof SalesItem
     */
    incomeID?: number;
    /**
     * Уникальный идентификатор продажи/возврата. <ul>  <li> `SXXXXXXXXXX` — продажа  <li> `RXXXXXXXXXX` — возврат  <li> `DXXXXXXXXXXX` — доплата <li> `AXXXXXXXXX` – сторно продаж (все значения полей как у продажи, но поля с суммами и кол-вом с минусом как в возврате) <li> `BXXXXXXXXX` - сторно возврата (все значения полей как у возврата, но поля с суммами и кол-вом с плюсом, в противоположность возврату) </ul> 
     * @type {string}
     * @memberof SalesItem
     */
    saleID?: string;
    /**
     * Уникальный идентификатор позиции заказа. Может использоваться для поиска соответствия между заказами и продажами.
     * @type {number}
     * @memberof SalesItem
     */
    odid?: number;
    /**
     * Согласованная скидка постоянного покупателя
     * @type {number}
     * @memberof SalesItem
     */
    spp?: number;
    /**
     * К перечислению продавцку
     * @type {number}
     * @memberof SalesItem
     */
    forPay?: number;
    /**
     * Фактическая цена заказа с учетом всех скидок
     * @type {number}
     * @memberof SalesItem
     */
    finishedPrice?: number;
    /**
     * Цена, от которой считается вознаграждение продавца `forpay` (с учетом всех согласованных скидок)
     * @type {number}
     * @memberof SalesItem
     */
    priceWithDisc?: number;
    /**
     * Артикул WB
     * @type {number}
     * @memberof SalesItem
     */
    nmId?: number;
    /**
     * Предмет
     * @type {string}
     * @memberof SalesItem
     */
    subject?: string;
    /**
     * Категория
     * @type {string}
     * @memberof SalesItem
     */
    category?: string;
    /**
     * Бренд
     * @type {string}
     * @memberof SalesItem
     */
    brand?: string;
    /**
     * Для сторно-операций `1`, для остальных `0`
     * @type {number}
     * @memberof SalesItem
     */
    isStorno?: number;
    /**
     * Цифровое значение стикера, который клеится на товар в процессе сборки заказа по системе Маркетплейс.
     * @type {string}
     * @memberof SalesItem
     */
    sticker?: string;
    /**
     * Уникальный идентификатор заказа, функционально аналогичный `odid`/`rid`.  Данный параметр введен в июле'22 и в течение переходного периода может быть заполнен не во всех ответах. Примечание для работающих по системе Маркетплейс: `srid` равен `rid` в ответе на метод `GET /api/v2/orders`. 
     * @type {string}
     * @memberof SalesItem
     */
    srid?: string;
}
/**
 * 
 * @export
 */
export type StatusNoChange = string
/**
 * 
 * @export
 * @interface StocksItem
 */
export interface StocksItem {
    /**
     * Дата и время обновления информации в сервисе. Это поле соответствует параметру `dateFrom` в запросе. Если часовой пояс не указан, то берется Московское время UTC+3.
     * @type {Date}
     * @memberof StocksItem
     */
    lastChangeDate?: Date;
    /**
     * Артикул продавца
     * @type {string}
     * @memberof StocksItem
     */
    supplierArticle?: string;
    /**
     * Размер товара (пример S, M, L, XL, 42, 42-43)
     * @type {string}
     * @memberof StocksItem
     */
    techSize?: string;
    /**
     * Бар-код
     * @type {string}
     * @memberof StocksItem
     */
    barcode?: string;
    /**
     * Количество, доступное для продажи (сколько можно добавить в корзину)
     * @type {number}
     * @memberof StocksItem
     */
    quantity?: number;
    /**
     * Договор поставки
     * @type {boolean}
     * @memberof StocksItem
     */
    isSupply?: boolean;
    /**
     * Договор реализации
     * @type {boolean}
     * @memberof StocksItem
     */
    isRealization?: boolean;
    /**
     * Полное (непроданное) количество, которое числится за складом (= `quantity` + в пути)
     * @type {number}
     * @memberof StocksItem
     */
    quantityFull?: number;
    /**
     * Название склада
     * @type {string}
     * @memberof StocksItem
     */
    warehouseName?: string;
    /**
     * Артикул WB
     * @type {number}
     * @memberof StocksItem
     */
    nmId?: number;
    /**
     * Предмет
     * @type {string}
     * @memberof StocksItem
     */
    subject?: string;
    /**
     * Категория
     * @type {string}
     * @memberof StocksItem
     */
    category?: string;
    /**
     * Количество дней на сайте
     * @type {number}
     * @memberof StocksItem
     */
    daysOnSite?: number;
    /**
     * Бренд
     * @type {string}
     * @memberof StocksItem
     */
    brand?: string;
    /**
     * Код контракта
     * @type {string}
     * @memberof StocksItem
     */
    sCCode?: string;
    /**
     * Цена
     * @type {number}
     * @memberof StocksItem
     */
    price?: number;
    /**
     * Скидка
     * @type {number}
     * @memberof StocksItem
     */
    discount?: number;
}
/**
 * 
 * @export
 * @interface StocksWarehouseBody
 */
export interface StocksWarehouseBody {
    /**
     * Массив баркодов товаров и их остатков
     * @type {Array<Apiv3stockswarehouseStocks>}
     * @memberof StocksWarehouseBody
     */
    stocks: Array<Apiv3stockswarehouseStocks>;
}
/**
 * 
 * @export
 * @interface StocksWarehouseBody1
 */
export interface StocksWarehouseBody1 {
    /**
     * Массив баркодов
     * @type {Array<string>}
     * @memberof StocksWarehouseBody1
     */
    skus?: Array<string>;
}
/**
 * 
 * @export
 * @interface StocksWarehouseBody2
 */
export interface StocksWarehouseBody2 {
    /**
     * Массив баркодов
     * @type {Array<string>}
     * @memberof StocksWarehouseBody2
     */
    skus?: Array<string>;
}
/**
 * 
 * @export
 * @interface Supply
 */
export interface Supply {
    /**
     * Идентификатор поставки
     * @type {string}
     * @memberof Supply
     */
    id?: string;
    /**
     * Флаг закрытия поставки
     * @type {boolean}
     * @memberof Supply
     */
    done?: boolean;
    /**
     * Дата создания поставки (RFC3339)
     * @type {Date}
     * @memberof Supply
     */
    createdAt?: Date;
    /**
     * Дата закрытия поставки (RFC3339)
     * @type {Date}
     * @memberof Supply
     */
    closedAt?: Date;
    /**
     * Дата скана поставки (RFC3339)
     * @type {Date}
     * @memberof Supply
     */
    scanDt?: Date;
    /**
     * Наименование поставки
     * @type {string}
     * @memberof Supply
     */
    name?: string;
    /**
     * сКГТ-признак поставки
     * @type {boolean}
     * @memberof Supply
     */
    isLargeCargo?: boolean;
}
/**
 * 
 * @export
 * @interface SupplyOrder
 */
export interface SupplyOrder {
    /**
     * Идентификатор сборочного задания в Маркетплейсе
     * @type {number}
     * @memberof SupplyOrder
     */
    id?: number;
    /**
     * Идентификатор сборочного задания в системе Wildberries
     * @type {string}
     * @memberof SupplyOrder
     */
    rid?: string;
    /**
     * Дата создания сборочного задания (RFC3339)
     * @type {Date}
     * @memberof SupplyOrder
     */
    createdAt?: Date;
    /**
     * Идентификатор склада продавца, на который поступило сборочное задание
     * @type {number}
     * @memberof SupplyOrder
     */
    warehouseId?: number;
    /**
     * Массив приоритетных СЦ для доставки сборочного задания. Если поле не заполнено или массив пустой, приоритетного СЦ для данного сборочного задания нет
     * @type {Array<string>}
     * @memberof SupplyOrder
     */
    prioritySc?: Array<string>;
    /**
     * Список офисов, куда следует привезти товар
     * @type {Array<string>}
     * @memberof SupplyOrder
     */
    offices?: Array<string>;
    /**
     * 
     * @type {OrderUser}
     * @memberof SupplyOrder
     */
    user?: OrderUser;
    /**
     * Массив баркодов товара
     * @type {Array<string>}
     * @memberof SupplyOrder
     */
    skus?: Array<string>;
    /**
     * Цена в валюте продажи с учетом всех скидок, умноженная на 100. Код валюты продажи в поле currencyCode.
     * @type {number}
     * @memberof SupplyOrder
     */
    price?: number;
    /**
     * Цена продажи с учетом скидок в копейках, сконвертированная в рубли по курсу на момент создания сборочного задания. Предоставляется в информационных целях
     * @type {number}
     * @memberof SupplyOrder
     */
    convertedPrice?: number;
    /**
     * Код валюты продажи (ISO 4217)
     * @type {number}
     * @memberof SupplyOrder
     */
    currencyCode?: number;
    /**
     * Код валюты страны продавца (ISO 4217)
     * @type {number}
     * @memberof SupplyOrder
     */
    convertedCurrencyCode?: number;
    /**
     * Идентификатор транзакции для группировки сборочных заданий. Сборочные задания в одной корзине покупателя будут иметь одинаковый orderUID
     * @type {string}
     * @memberof SupplyOrder
     */
    orderUid?: string;
    /**
     * ААртикул WB
     * @type {number}
     * @memberof SupplyOrder
     */
    nmId?: number;
    /**
     * Идентификатор размера товара в системе Wildberries
     * @type {number}
     * @memberof SupplyOrder
     */
    chrtId?: number;
    /**
     * Артикул продавца
     * @type {string}
     * @memberof SupplyOrder
     */
    article?: string;
    /**
     * сКГТ-признак товара, на который был сделан заказ
     * @type {boolean}
     * @memberof SupplyOrder
     */
    isLargeCargo?: boolean;
}
/**
 * 
 * @export
 * @interface TagIdBody
 */
export interface TagIdBody {
    /**
     * Цвет тега
     * @type {string}
     * @memberof TagIdBody
     */
    color?: string;
    /**
     * Имя тега
     * @type {string}
     * @memberof TagIdBody
     */
    name?: string;
}
/**
 * Токен недействителен
 * @export
 */
export type TokenInvalid = string
/**
 * Используемый токен не применим к данным методам.
 * @export
 */
export type TokenIsNotApplicable = string
/**
 * Токен отсутствует
 * @export
 */
export type TokenMissing = string
/**
 * Токен удален
 * @export
 */
export type TokenNotFound = string
/**
 * 
 * @export
 * @interface TrashListBody
 */
export interface TrashListBody {
    /**
     * 
     * @type {Contentv1cardstrashlistSort}
     * @memberof TrashListBody
     */
    sort?: Contentv1cardstrashlistSort;
}
/**
 * 
 * @export
 * @interface UploadAddBody
 */
export interface UploadAddBody {
    /**
     * Артикул продавца
     * @type {string}
     * @memberof UploadAddBody
     */
    vendorCode?: string;
    /**
     * Массив НМ которые хотим добавить к КТ
     * @type {Array<Contentv1cardsuploadaddCards>}
     * @memberof UploadAddBody
     */
    cards?: Array<Contentv1cardsuploadaddCards>;
}
/**
 * 
 * @export
 * @interface V0AllcpmBody
 */
export interface V0AllcpmBody {
    /**
     * Массив параметров запроса, по которым будет получен список ставок активных РК: должен быть значением `menuId` (для РК в каталоге), `subjectId` (для РК в поиске и рекомендациях) или `setId` (для РК в карточке товара). 
     * @type {Array<number>}
     * @memberof V0AllcpmBody
     */
    param?: Array<number>;
}
/**
 * 
 * @export
 * @interface V0CpmBody
 */
export interface V0CpmBody {
    /**
     * Идентификатор РК, где меняется ставка
     * @type {number}
     * @memberof V0CpmBody
     */
    advertId: number;
    /**
     * <dl> <dt>Тип РК, где меняется ставка:</dt> <dd><code>5</code> - реклама в карточке товара</dd> <dd><code>6</code> - реклама в поиске</dd> <dd><code>7</code> - реклама в рекомендациях на главной странице</dd> </dl> 
     * @type {number}
     * @memberof V0CpmBody
     */
    type: V0CpmBody.TypeEnum;
    /**
     * Новое значение ставки
     * @type {number}
     * @memberof V0CpmBody
     */
    cpm: number;
    /**
     * Параметр, для которого будет внесено изменение (является значением `subjectId` или `setId` в зависимости от типа РК) 
     * @type {number}
     * @memberof V0CpmBody
     */
    param: number;
}

/**
 * @export
 * @namespace V0CpmBody
 */
export namespace V0CpmBody {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        NUMBER_5 = <any> 5,
        NUMBER_6 = <any> 6,
        NUMBER_7 = <any> 7
    }
}
/**
 * 
 * @export
 * @interface V0IntervalsBody
 */
export interface V0IntervalsBody {
    /**
     * Идентификатор РК, у которой меняется бюджет
     * @type {number}
     * @memberof V0IntervalsBody
     */
    advertId: number;
    /**
     * Массив новых значений для интервалов. <br> Максимальное количество интервалов `24`. 
     * @type {Array<Advv0intervalsIntervals>}
     * @memberof V0IntervalsBody
     */
    intervals: Array<Advv0intervalsIntervals>;
    /**
     * Параметр, для которого будет внесено изменение, должен быть значением `menuId` (для РК в каталоге), `subjectId` (для РК в поиске и рекомендациях) или `setId` (для РК в карточке товара) 
     * @type {number}
     * @memberof V0IntervalsBody
     */
    param: number;
}
/**
 * 
 * @export
 * @interface V0NmactiveBody
 */
export interface V0NmactiveBody {
    /**
     * Идентификатор РК
     * @type {number}
     * @memberof V0NmactiveBody
     */
    advertId: number;
    /**
     * Массив значений активности для номенклатур. <br> Максимальноe количество номенклатур в запросе `50`. 
     * @type {Array<Advv0nmactiveActive>}
     * @memberof V0NmactiveBody
     */
    active: Array<Advv0nmactiveActive>;
    /**
     * Параметр, для которого будет внесено изменение, должен быть значением `menuId` (для РК в каталоге), `subjectId` (для РК в поиске и рекомендациях) или `setId` (для РК в карточке товара). 
     * @type {number}
     * @memberof V0NmactiveBody
     */
    param: number;
}
/**
 * 
 * @export
 * @interface V0RenameBody
 */
export interface V0RenameBody {
    /**
     * Идентификатор РК, у которой меняется название
     * @type {number}
     * @memberof V0RenameBody
     */
    advertId: number;
    /**
     * Новое название (максимум 100 символов)
     * @type {string}
     * @memberof V0RenameBody
     */
    name: string;
}
/**
 * 
 * @export
 * @interface V1BarcodesBody
 */
export interface V1BarcodesBody {
    /**
     * Кол-во баркодов которые надо сгенерировать, максимальное доступное количество баркодов для генерации - `5000`
     * @type {number}
     * @memberof V1BarcodesBody
     */
    count?: number;
}
/**
 * 
 * @export
 * @interface V1DelBody
 */
export interface V1DelBody {
    /**
     * Идентификатор товара (`nmId`), у которого необходимо удалить рекомендацию
     * @type {number}
     * @memberof V1DelBody
     */
    nm: number;
    /**
     * Список идентификаторов товаров (`nmId`), которые необходимо удалить из рекомендуемых
     * @type {Array<number>}
     * @memberof V1DelBody
     */
    recom: Array<number>;
}
/**
 * 
 * @export
 * @interface V1FeedbacksBody
 */
export interface V1FeedbacksBody {
}
/**
 * 
 * @export
 * @interface V1InsBody
 */
export interface V1InsBody {
    /**
     * Идентификатор товара (`nmId`), к которому добавляется рекомендация
     * @type {number}
     * @memberof V1InsBody
     */
    nm: number;
    /**
     * Список идентификаторов товаров (`nmId`), которые необходимо добавить в рекомендуемые
     * @type {Array<number>}
     * @memberof V1InsBody
     */
    recom: Array<number>;
}
/**
 * 
 * @export
 * @interface V1PricesBody
 */
export interface V1PricesBody {
    /**
     * Номенклатура
     * @type {number}
     * @memberof V1PricesBody
     */
    nmId?: number;
    /**
     * Цена (указывать без копеек)
     * @type {number}
     * @memberof V1PricesBody
     */
    price?: number;
}
/**
 * 
 * @export
 * @interface V1QuestionsBody
 */
export interface V1QuestionsBody {
}
/**
 * 
 * @export
 * @interface V1SetBody
 */
export interface V1SetBody {
    /**
     * Артикул WB (`nmId`), которому передается рекомендация
     * @type {number}
     * @memberof V1SetBody
     */
    nm: number;
    /**
     * Список артикулов WB (`nmId`), которые необходимо передать в рекомендуемые.
     * @type {Array<number>}
     * @memberof V1SetBody
     */
    recom: Array<number>;
}
/**
 * 
 * @export
 * @interface V1TagBody
 */
export interface V1TagBody {
    /**
     * Цвет тега. <dl> <dt>Доступные цвета:</dt> <dd><code>D1CFD7</code> - серый</dd> <dd><code>FEE0E0</code> - красный</dd> <dd><code>ECDAFF</code> - фиолетовый</dd> <dd><code>E4EAFF</code> - синий</dd> <dd><code>DEF1DD</code> - зеленный</dd> <dd><code>FFECC7</code> - желтый</dd> </dl> 
     * @type {string}
     * @memberof V1TagBody
     */
    color?: string;
    /**
     * Имя тега
     * @type {string}
     * @memberof V1TagBody
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface V3SuppliesBody
 */
export interface V3SuppliesBody {
    /**
     * Наименование поставки
     * @type {string}
     * @memberof V3SuppliesBody
     */
    name?: string;
}
/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Метод позволяет изменить активность предметной группы для рекламы в поиске.<br> Изменение активности доступно только для РК в статусе 9 или 11. 
         * @summary Изменение активности предметной группы для РК в поиске
         * @param {number} id Идентификатор РК
         * @param {number} subjectId Идентификатор предметной группы, для которой меняется активность
         * @param {string} status Новое состояние (&#x60;true&#x60; - сделать группу активной или &#x60;false&#x60; - сделать группу неактивной)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0ActiveGet(id: number, subjectId: number, status: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling advV0ActiveGet.');
            }
            // verify required parameter 'subjectId' is not null or undefined
            if (subjectId === null || subjectId === undefined) {
                throw new RequiredError('subjectId','Required parameter subjectId was null or undefined when calling advV0ActiveGet.');
            }
            // verify required parameter 'status' is not null or undefined
            if (status === null || status === undefined) {
                throw new RequiredError('status','Required parameter status was null or undefined when calling advV0ActiveGet.');
            }
            const localVarPath = `/adv/v0/active`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (subjectId !== undefined) {
                localVarQueryParameter['subjectId'] = subjectId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение информации об одной РК
         * @summary Информация о РК
         * @param {number} id Идентификатор РК
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0AdvertGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling advV0AdvertGet.');
            }
            const localVarPath = `/adv/v0/advert`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет получить список РК продавца.
         * @summary Список РК
         * @param {number} [status] &lt;dl&gt; &lt;dt&gt;Статус РК:&lt;/dt&gt; &lt;dd&gt;&lt;code&gt;7&lt;/code&gt; - РК завершена&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;9&lt;/code&gt; - идут показы&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;11&lt;/code&gt; - РК на паузе&lt;/dd&gt; &lt;/dl&gt; 
         * @param {number} [type] &lt;dl&gt; &lt;dt&gt;Тип РК:&lt;/dt&gt; &lt;dd&gt;&lt;code&gt;4&lt;/code&gt; - реклама в каталоге&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;5&lt;/code&gt; - реклама в карточке товара&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;6&lt;/code&gt; - реклама в поиске&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;7&lt;/code&gt; - реклама в рекомендациях на главной странице&lt;/dd&gt; &lt;/dl&gt; 
         * @param {number} [limit] Количество кампаний в ответе
         * @param {number} [offset] Смещение относительно первой РК
         * @param {string} [order] &lt;dl&gt; &lt;dt&gt;Порядок:&lt;/dt&gt; &lt;dd&gt;&lt;code&gt;create&lt;/code&gt; (по времени создания РК)&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;change&lt;/code&gt; (по времени последнего изменения РК)&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;id&lt;/code&gt; (по идентификатору РК)&lt;/dd&gt; &lt;/dl&gt; &lt;br&gt;Например: &lt;code&gt;**_/api/v0/adverts?type&#x3D;6&amp;limit&#x3D;5&amp;offset&#x3D;10&amp;&lt;b&gt;order&#x3D;change&lt;/b&gt;&amp;direction&#x3D;asc**&lt;/code&gt; 
         * @param {string} [direction] &lt;dl&gt; &lt;dt&gt;Направление:&lt;/dt&gt; &lt;dd&gt;&lt;code&gt;desc&lt;/code&gt; (от большего к меньшему)&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;asc&lt;/code&gt; (от меньшего к большему)&lt;/dd&gt; &lt;/dl&gt; &lt;br&gt;Например: &lt;code&gt;**_/api/v0/adverts?type&#x3D;6&amp;limit&#x3D;5&amp;offset&#x3D;10&amp;order&#x3D;change&amp;&lt;b&gt;direction&#x3D;asc&lt;/b&gt;**&lt;/code&gt; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0AdvertsGet(status?: number, type?: number, limit?: number, offset?: number, order?: string, direction?: string, options: any = {}): FetchArgs {
            const localVarPath = `/adv/v0/adverts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет получить список ставок по типу размещения РК.<br> С помощью этого метода изменить ставку невозможно. 
         * @summary Список ставок по типу размещения РК
         * @param {V0AllcpmBody} body 
         * @param {number} type &lt;dl&gt; &lt;dt&gt;Тип РК:&lt;/dt&gt; &lt;dd&gt;&lt;code&gt;4&lt;/code&gt; - реклама в каталоге&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;5&lt;/code&gt; - реклама в карточке товара&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;6&lt;/code&gt; - реклама в поиске&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;7&lt;/code&gt; - реклама в рекомендациях на главной странице&lt;/dd&gt; &lt;/dl&gt; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0AllcpmPost(body: V0AllcpmBody, type: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling advV0AllcpmPost.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling advV0AllcpmPost.');
            }
            const localVarPath = `/adv/v0/allcpm`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V0AllcpmBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение количества рекламных кампаний (РК) поставщика
         * @summary Получение РК
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0CountGet(options: any = {}): FetchArgs {
            const localVarPath = `/adv/v0/count`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение списка ставок для типа размещения. <br>Данные в ответе отсортированы по величине ставки от большей к меньшей. 
         * @summary Список ставок
         * @param {number} type &lt;dl&gt; &lt;dt&gt;Тип РК:&lt;/dt&gt; &lt;dd&gt;&lt;code&gt;4&lt;/code&gt; - реклама в каталоге&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;5&lt;/code&gt; - реклама в карточке товара&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;6&lt;/code&gt; - реклама в поиске&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;7&lt;/code&gt; - реклама в рекомендациях на главной странице&lt;/dd&gt; &lt;/dl&gt; 
         * @param {number} param Параметр запроса, по которому будет получен список ставок активных РК. &lt;br&gt;Должен быть значением &#x60;menuId&#x60;, &#x60;subjectId&#x60; или &#x60;setId&#x60; в зависимости от типа РК. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0CpmGet(type: number, param: number, options: any = {}): FetchArgs {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling advV0CpmGet.');
            }
            // verify required parameter 'param' is not null or undefined
            if (param === null || param === undefined) {
                throw new RequiredError('param','Required parameter param was null or undefined when calling advV0CpmGet.');
            }
            const localVarPath = `/adv/v0/cpm`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (param !== undefined) {
                localVarQueryParameter['param'] = param;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Изменение ставки у рекламной кампании <br>Доступно для РК в карточке товара, поиске или рекомендациях 
         * @summary Изменение ставки у РК
         * @param {V0CpmBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0CpmPost(body: V0CpmBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling advV0CpmPost.');
            }
            const localVarPath = `/adv/v0/cpm`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V0CpmBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет изменить временной интервал показа рекламной кампании.
         * @summary Изменение интервалов показа РК
         * @param {V0IntervalsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0IntervalsPost(body?: V0IntervalsBody, options: any = {}): FetchArgs {
            const localVarPath = `/adv/v0/intervals`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V0IntervalsBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет изменить активность номенклатур в РК.
         * @summary Изменение активности номенклатур РК
         * @param {V0NmactiveBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0NmactivePost(body?: V0NmactiveBody, options: any = {}): FetchArgs {
            const localVarPath = `/adv/v0/nmactive`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V0NmactiveBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет получить список значений параметра <code>menuId</code>.
         * @summary Словарь значений параметра menuId
         * @param {number} [id] Идентификатор меню, где размещается РК (для РК в каталоге). &lt;br&gt; Принимает значение параметра &#x60;menuId&#x60; из РК. &lt;br&gt; При пустом параметре вернётся весь список существующих значений. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0ParamsMenuGet(id?: number, options: any = {}): FetchArgs {
            const localVarPath = `/adv/v0/params/menu`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет получить список значений параметра <code>setId</code>.
         * @summary Словарь значений параметра setId
         * @param {number} [id] Идентификатор сочетания предмета и пола (для РК в карточке товара). &lt;br&gt; Принимает значение параметра &#x60;setId&#x60; из РК. &lt;br&gt; При пустом параметре вернётся весь список существующих значений. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0ParamsSetGet(id?: number, options: any = {}): FetchArgs {
            const localVarPath = `/adv/v0/params/set`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет получить список значений параметра <code>subjectId</code>.
         * @summary Словарь значений параметра subjectId
         * @param {number} [id] Идентификатор предметной группы, для которой создана РК (для РК в поиске и рекомендациях). &lt;br&gt; Принимает значение параметра &#x60;subjectId&#x60; из РК. &lt;br&gt; При пустом параметре вернётся весь список существующих значений. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0ParamsSubjectGet(id?: number, options: any = {}): FetchArgs {
            const localVarPath = `/adv/v0/params/subject`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * РК в статусе <b>\"9 - идут показы\"</b> - можно запаузить, сделав <b>GET</b> на  `/api/v0/pause?id=***`. 
         * @summary Пауза РК
         * @param {number} id Идентификатор РК
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0PauseGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling advV0PauseGet.');
            }
            const localVarPath = `/adv/v0/pause`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет переименовать рекламную кампанию.
         * @summary Переименование РК
         * @param {V0RenameBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0RenamePost(body?: V0RenameBody, options: any = {}): FetchArgs {
            const localVarPath = `/adv/v0/rename`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V0RenameBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * РК в статусе <b>\"11 - на паузе\"</b> - можно снова запустить. <br>Для запуска необходимо, чтобы у РК были активные ставки. <br><b>GET</b> на `/api/v0/start?id=***` - в ответ `200`, если статус изменен, или `400`, если это сделать не удалось. 
         * @summary Запуск РК
         * @param {number} id Идентификатор РК
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0StartGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling advV0StartGet.');
            }
            const localVarPath = `/adv/v0/start`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет завершить РК, находящиеся в статусе 9 или 11.
         * @summary Завершение РК
         * @param {number} id Идентификатор РК
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0StopGet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling advV0StopGet.');
            }
            const localVarPath = `/adv/v0/stop`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет удалить рекомендации. <br> `ВАЖНО!` Если запрос прошел успешно (код ответа 200), а рекомендации не удалились, то Вам необходимо проверить корректность отправленных значений. На данный момент в методе не предусмотрена валидация значений параметров. Тщательно проверяйте данные перед отправкой 
         * @summary Удаление рекомендаций
         * @param {Array<V1DelBody>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DelPost(body: Array<V1DelBody>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1DelPost.');
            }
            const localVarPath = `/api/v1/del`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;V1DelBody&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет получить список архивных отзывов. <br> Отзыв становится архивным если на него предоставлен ответ или ответ не предоставлен в течение 30 дней со дня его публикации. 
         * @summary Список архивных отзывов
         * @param {number} take Количество отзывов
         * @param {number} skip Количество отзывов для пропуска
         * @param {number} [nmId] Артикул WB
         * @param {string} [order] Сортировка отзывов по дате (dateAsc/dateDesc)
         * @param {boolean} [hasSupplierComplaint] Отзывы с жалобой продавца(&#x60;true&#x60;) или без жалобы(&#x60;false&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FeedbacksArchiveGet(take: number, skip: number, nmId?: number, order?: string, hasSupplierComplaint?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'take' is not null or undefined
            if (take === null || take === undefined) {
                throw new RequiredError('take','Required parameter take was null or undefined when calling apiV1FeedbacksArchiveGet.');
            }
            // verify required parameter 'skip' is not null or undefined
            if (skip === null || skip === undefined) {
                throw new RequiredError('skip','Required parameter skip was null or undefined when calling apiV1FeedbacksArchiveGet.');
            }
            const localVarPath = `/api/v1/feedbacks/archive`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (nmId !== undefined) {
                localVarQueryParameter['nmId'] = nmId;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (hasSupplierComplaint !== undefined) {
                localVarQueryParameter['hasSupplierComplaint'] = hasSupplierComplaint;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет получить количество необработанных отзывов за сегодня, за всё время, и среднюю оценку всех отзывов.
         * @summary Необработанные отзывы
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FeedbacksCountUnansweredGet(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/feedbacks/count-unanswered`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет получить список отзывов по заданным параметрам с пагинацией и сортировкой.
         * @summary Список отзывов
         * @param {boolean} isAnswered Обработанные отзывы (&#x60;true&#x60;) или необработанные отзывы(&#x60;false&#x60;)
         * @param {number} take Количество отзывов (max. 10 000)
         * @param {number} skip Количество отзывов для пропуска
         * @param {number} [nmId] Артикул WB
         * @param {string} [order] Сортировка отзывов по дате (dateAsc/dateDesc)
         * @param {boolean} [hasSupplierComplaint] Отзывы с жалобой продавца(&#x60;true&#x60;) или без жалобы(&#x60;false&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FeedbacksGet(isAnswered: boolean, take: number, skip: number, nmId?: number, order?: string, hasSupplierComplaint?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'isAnswered' is not null or undefined
            if (isAnswered === null || isAnswered === undefined) {
                throw new RequiredError('isAnswered','Required parameter isAnswered was null or undefined when calling apiV1FeedbacksGet.');
            }
            // verify required parameter 'take' is not null or undefined
            if (take === null || take === undefined) {
                throw new RequiredError('take','Required parameter take was null or undefined when calling apiV1FeedbacksGet.');
            }
            // verify required parameter 'skip' is not null or undefined
            if (skip === null || skip === undefined) {
                throw new RequiredError('skip','Required parameter skip was null or undefined when calling apiV1FeedbacksGet.');
            }
            const localVarPath = `/api/v1/feedbacks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (isAnswered !== undefined) {
                localVarQueryParameter['isAnswered'] = isAnswered;
            }

            if (nmId !== undefined) {
                localVarQueryParameter['nmId'] = nmId;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (hasSupplierComplaint !== undefined) {
                localVarQueryParameter['hasSupplierComplaint'] = hasSupplierComplaint;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <dl> <dt>В зависимости от тела запроса можно:</dt> <dd>Просмотреть отзыв.</dd> <dd>Ответить на отзыв.</dd> <dd>Создать жалобу на отзыв.</dd> </dl> 
         * @summary Работа с отзывом
         * @param {V1FeedbacksBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FeedbacksPatch(body?: V1FeedbacksBody, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/feedbacks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1FeedbacksBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет получить среднюю оценку товаров по родительской категории.
         * @summary Средняя оценка товаров по родительской категории
         * @param {number} subjectId id категории товара
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FeedbacksProductsRatingGet(subjectId: number, options: any = {}): FetchArgs {
            // verify required parameter 'subjectId' is not null or undefined
            if (subjectId === null || subjectId === undefined) {
                throw new RequiredError('subjectId','Required parameter subjectId was null or undefined when calling apiV1FeedbacksProductsRatingGet.');
            }
            const localVarPath = `/api/v1/feedbacks/products/rating`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (subjectId !== undefined) {
                localVarQueryParameter['subjectId'] = subjectId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет получить среднюю оценку товара по его артикулу WB.
         * @summary Средняя оценка товара по артикулу WB
         * @param {number} nmId Артикул WB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FeedbacksProductsRatingNmidGet(nmId: number, options: any = {}): FetchArgs {
            // verify required parameter 'nmId' is not null or undefined
            if (nmId === null || nmId === undefined) {
                throw new RequiredError('nmId','Required parameter nmId was null or undefined when calling apiV1FeedbacksProductsRatingNmidGet.');
            }
            const localVarPath = `/api/v1/feedbacks/products/rating/nmid`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (nmId !== undefined) {
                localVarQueryParameter['nmId'] = nmId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет получить список из двух товаров, с наибольшей и наименьшей средней оценкой, по родительской категории.
         * @summary Товары с наибольшей и наименьшей средней оценкой по родительской категории
         * @param {number} subjectId id категории товара
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FeedbacksProductsRatingTopGet(subjectId: number, options: any = {}): FetchArgs {
            // verify required parameter 'subjectId' is not null or undefined
            if (subjectId === null || subjectId === undefined) {
                throw new RequiredError('subjectId','Required parameter subjectId was null or undefined when calling apiV1FeedbacksProductsRatingTopGet.');
            }
            const localVarPath = `/api/v1/feedbacks/products/rating/top`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (subjectId !== undefined) {
                localVarQueryParameter['subjectId'] = subjectId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет получить XLSX файл с отзывами в кодировке BASE64. <br> За один запрос можно получить 5000 отзывов. <br> На данный момент всего можно получить 200 000 последних отзывов. 
         * @summary Получение отзывов в формате XLSX
         * @param {boolean} isAnswered Необработанный(&#x60;false&#x60;) или в архиве(&#x60;true&#x60;)
         * @param {boolean} [hasSupplierComplaint] Отзывы с жалобой продавца(&#x60;true&#x60;) или без жалобы(&#x60;false&#x60;)
         * @param {number} [skip] Параметр пагинации, указывает сколько отзывов пропустить &lt;span class&#x3D;\&quot;new\&quot;&gt;new&lt;/span&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FeedbacksReportGet(isAnswered: boolean, hasSupplierComplaint?: boolean, skip?: number, options: any = {}): FetchArgs {
            // verify required parameter 'isAnswered' is not null or undefined
            if (isAnswered === null || isAnswered === undefined) {
                throw new RequiredError('isAnswered','Required parameter isAnswered was null or undefined when calling apiV1FeedbacksReportGet.');
            }
            const localVarPath = `/api/v1/feedbacks/report`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (isAnswered !== undefined) {
                localVarQueryParameter['isAnswered'] = isAnswered;
            }

            if (hasSupplierComplaint !== undefined) {
                localVarQueryParameter['hasSupplierComplaint'] = hasSupplierComplaint;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет добавить рекомендации к товару. <br> `ВАЖНО!` Если запрос прошел успешно (код ответа 200), а рекомендации не добавилась, то Вам необходимо проверить корректность отправленных значений.  <br>На данный момент в методе не предусмотрена валидация значений параметров.  <br>Тщательно проверяйте данные перед отправкой. <br>Ограничение по запросам: 120 запросов в минуту. 
         * @summary Добавление рекомендаций
         * @param {Array<V1InsBody>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1InsPost(body: Array<V1InsBody>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1InsPost.');
            }
            const localVarPath = `/api/v1/ins`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;V1InsBody&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет получить список рекомендаций по нескольким товарам
         * @summary Список рекомендаций
         * @param {number} nm Артикул WB (&#x60;nmId&#x60;), по которому необходимо получить список рекомендаций. &lt;br&gt; (max. 200) 
         * @param {number} [limit] Ограничение количества &#x60;nm&#x60; в ответе. (max. 999)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ListGet(nm: number, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'nm' is not null or undefined
            if (nm === null || nm === undefined) {
                throw new RequiredError('nm','Required parameter nm was null or undefined when calling apiV1ListGet.');
            }
            const localVarPath = `/api/v1/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (nm !== undefined) {
                localVarQueryParameter['nm'] = nm;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод отображает информацию о наличии у продавца непросмотренных отзывов и вопросов.
         * @summary Непросмотренные отзывы и вопросы
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1NewFeedbacksQuestionsGet(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/new-feedbacks-questions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет получить список родительских категорий товаров, которые есть у продавца.
         * @summary Родительские категории товаров
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ParentSubjectsGet(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/parent-subjects`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет получить количество неотвеченных вопросов за сегодня и за всё время.
         * @summary Неотвеченные вопросы
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QuestionsCountUnansweredGet(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/questions/count-unanswered`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет получить список вопросов по заданным параметрам с пагинацией и сортировкой.
         * @summary Список вопросов
         * @param {boolean} isAnswered Отвеченные вопросы (&#x60;true&#x60;) или неотвеченные вопросы(&#x60;false&#x60;) 
         * @param {number} take Количество вопросов (max. 10 000)
         * @param {number} skip Количество вопросов для пропуска
         * @param {number} [nmId] Артикул WB
         * @param {string} [order] Сортировка вопросов по дате (&#x60;dateAsc&#x60;/&#x60;dateDesc&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QuestionsGet(isAnswered: boolean, take: number, skip: number, nmId?: number, order?: string, options: any = {}): FetchArgs {
            // verify required parameter 'isAnswered' is not null or undefined
            if (isAnswered === null || isAnswered === undefined) {
                throw new RequiredError('isAnswered','Required parameter isAnswered was null or undefined when calling apiV1QuestionsGet.');
            }
            // verify required parameter 'take' is not null or undefined
            if (take === null || take === undefined) {
                throw new RequiredError('take','Required parameter take was null or undefined when calling apiV1QuestionsGet.');
            }
            // verify required parameter 'skip' is not null or undefined
            if (skip === null || skip === undefined) {
                throw new RequiredError('skip','Required parameter skip was null or undefined when calling apiV1QuestionsGet.');
            }
            const localVarPath = `/api/v1/questions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (isAnswered !== undefined) {
                localVarQueryParameter['isAnswered'] = isAnswered;
            }

            if (nmId !== undefined) {
                localVarQueryParameter['nmId'] = nmId;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <dl> <dt>В зависимости от тела запроса можно:</dt> <dd>Просмотреть вопрос.</dd> <dd>Отклонить вопрос.</dd> <dd>Ответить на вопрос.</dd> </dl> 
         * @summary Работа с вопросами
         * @param {V1QuestionsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QuestionsPatch(body?: V1QuestionsBody, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/questions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1QuestionsBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет получить товары, про которые чаще всего спрашивают.
         * @summary Часто спрашиваемые товары
         * @param {number} size Количество запрашиваемых товаров (max. 100)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QuestionsProductsRatingGet(size: number, options: any = {}): FetchArgs {
            // verify required parameter 'size' is not null or undefined
            if (size === null || size === undefined) {
                throw new RequiredError('size','Required parameter size was null or undefined when calling apiV1QuestionsProductsRatingGet.');
            }
            const localVarPath = `/api/v1/questions/products/rating`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет получить XLSX файл с вопросами в кодировке BASE64.
         * @summary Получение вопросов в формате XLSX
         * @param {boolean} isAnswered Обработанные вопросы (&#x60;true&#x60;) или необработанные вопросы(&#x60;false&#x60;) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QuestionsReportGet(isAnswered: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'isAnswered' is not null or undefined
            if (isAnswered === null || isAnswered === undefined) {
                throw new RequiredError('isAnswered','Required parameter isAnswered was null or undefined when calling apiV1QuestionsReportGet.');
            }
            const localVarPath = `/api/v1/questions/report`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (isAnswered !== undefined) {
                localVarQueryParameter['isAnswered'] = isAnswered;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет добавлять, удалять рекомендации.<br> Работает по принципу перезаписи, все что указано в recom, ставится взамен того, что было ранее.<br> Чтобы удалить рекомендации необходимо передать пустой массив recom.    
         * @summary Управление рекомендациями
         * @param {Array<V1SetBody>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SetPost(body: Array<V1SetBody>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV1SetPost.');
            }
            const localVarPath = `/api/v1/set`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;V1SetBody&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Поставки
         * @summary Поставки
         * @param {string} dateFrom Дата в формате RFC3339. Можно передать дату или дату со временем.  Время можно указывать с точностью до секунд или миллисекунд.  Литера &#x60;Z&#x60; в конце строки означает, что время передается в UTC-часовом поясе.  При ее отсутствии время считается в часовом поясе МСК (UTC+3). &lt;br&gt;Примеры: &lt;ul&gt; &lt;li&gt; &#x60;2019-06-20&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00Z&#x60; &lt;li&gt; &#x60;2019-06-20T23:59:59&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345Z&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345&#x60; &lt;li&gt; &#x60;2017-03-25T00:00:00&#x60; &lt;/ul&gt; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SupplierIncomesGet(dateFrom: string, options: any = {}): FetchArgs {
            // verify required parameter 'dateFrom' is not null or undefined
            if (dateFrom === null || dateFrom === undefined) {
                throw new RequiredError('dateFrom','Required parameter dateFrom was null or undefined when calling apiV1SupplierIncomesGet.');
            }
            const localVarPath = `/api/v1/supplier/incomes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = dateFrom;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Заказы. <br>  Важно: гарантируется хранение данных по заказам не более 90 дней от даты заказа. Данные обновляются раз в 30 минут.  Точное время обновления информации в сервисе можно увидеть в поле `lastChangeDate`. <br> Для идентификации товаров из одного заказа, а также продаж по ним, следует использовать  поле `gNumber` (строки с одинаковым значением этого поля относятся к одному заказу) и номер  уникальной позиции в заказе `odid` (`rid`).  
         * @summary Заказы
         * @param {string} dateFrom Дата в формате RFC3339. Можно передать дату или дату со временем.  Время можно указывать с точностью до секунд или миллисекунд.  Литера &#x60;Z&#x60; в конце строки означает, что время передается в UTC-часовом поясе.  При ее отсутствии время считается в часовом поясе МСК (UTC+3). &lt;br&gt;Примеры: &lt;ul&gt; &lt;li&gt; &#x60;2019-06-20&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00Z&#x60; &lt;li&gt; &#x60;2019-06-20T23:59:59&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345Z&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345&#x60; &lt;li&gt; &#x60;2017-03-25T00:00:00&#x60; &lt;/ul&gt; 
         * @param {number} [flag] Если параметр &#x60;flag&#x3D;0&#x60; (или не указан в строке запроса), при вызове API возвращаются данные,  у которых значение поля &#x60;lastChangeDate&#x60; (дата время обновления информации в сервисе) больше или равно переданному  значению параметра &#x60;dateFrom&#x60;.  При этом количество возвращенных строк данных варьируется в интервале от 0 до примерно 100 000. &lt;br&gt; Если параметр &#x60;flag&#x3D;1&#x60;, то будет выгружена информация обо всех заказах или продажах с датой,  равной переданному параметру &#x60;dateFrom&#x60; (в данном случае время в дате значения не имеет).  При этом количество возвращенных строк данных будет равно количеству всех заказов или продаж,  сделанных в указанную дату, переданную в параметре &#x60;dateFrom&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SupplierOrdersGet(dateFrom: string, flag?: number, options: any = {}): FetchArgs {
            // verify required parameter 'dateFrom' is not null or undefined
            if (dateFrom === null || dateFrom === undefined) {
                throw new RequiredError('dateFrom','Required parameter dateFrom was null or undefined when calling apiV1SupplierOrdersGet.');
            }
            const localVarPath = `/api/v1/supplier/orders`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = dateFrom;
            }

            if (flag !== undefined) {
                localVarQueryParameter['flag'] = flag;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Отчет о продажах по реализации.  <br> В отчете доступны данные за последние 3 месяца. <br> В случае отсутствия данных за указанный период метод вернет `null`. <br> Технический перерыв в работе метода: каждый понедельник с 3:00 до 16:00. <br> <a href=\"./excel/stat-excel.html\">Инструкция: Сохранение статистики в Excel</a> 
         * @summary Отчет о продажах по реализации
         * @param {string} dateFrom Дата в формате RFC3339. Можно передать дату или дату со временем.  Время можно указывать с точностью до секунд или миллисекунд.  Литера &#x60;Z&#x60; в конце строки означает, что время передается в UTC-часовом поясе.  При ее отсутствии время считается в часовом поясе МСК (UTC+3). &lt;br&gt;Примеры: &lt;ul&gt; &lt;li&gt; &#x60;2019-06-20&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00Z&#x60; &lt;li&gt; &#x60;2019-06-20T23:59:59&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345Z&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345&#x60; &lt;li&gt; &#x60;2017-03-25T00:00:00&#x60; &lt;/ul&gt; 
         * @param {string} dateTo Конечная дата отчета
         * @param {number} [limit] Максимальное количество строк отчета, возвращаемых методом. Не может быть более 100000.
         * @param {number} [rrdid] Уникальный идентификатор строки отчета. Необходим для получения отчета частями.  &lt;br&gt; Загрузку отчета нужно начинать с &#x60;rrdid &#x3D; 0&#x60; и при последующих вызовах API передавать в запросе значение &#x60;rrd_id&#x60; из последней строки, полученной в результате предыдущего вызова.  &lt;br&gt; Таким образом для загрузки одного отчета может понадобиться вызывать API до тех пор, пока количество возвращаемых строк не станет равным нулю. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SupplierReportDetailByPeriodGet(dateFrom: string, dateTo: string, limit?: number, rrdid?: number, options: any = {}): FetchArgs {
            // verify required parameter 'dateFrom' is not null or undefined
            if (dateFrom === null || dateFrom === undefined) {
                throw new RequiredError('dateFrom','Required parameter dateFrom was null or undefined when calling apiV1SupplierReportDetailByPeriodGet.');
            }
            // verify required parameter 'dateTo' is not null or undefined
            if (dateTo === null || dateTo === undefined) {
                throw new RequiredError('dateTo','Required parameter dateTo was null or undefined when calling apiV1SupplierReportDetailByPeriodGet.');
            }
            const localVarPath = `/api/v1/supplier/reportDetailByPeriod`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = dateFrom;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = (dateTo as any).toISOString();
            }

            if (rrdid !== undefined) {
                localVarQueryParameter['rrdid'] = rrdid;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Продажи. <br> Важно: гарантируется хранение данных по заказам не более 90 дней от даты заказа. Данные обновляются раз в 30 минут. Точное время обновления информации в сервисе можно увидеть в поле `lastChangeDate`. <br> Для идентификации товаров из одного заказа, а также продаж по ним, следует использовать  поле `gNumber` (строки с одинаковым значением этого поля относятся к одному заказу) и номер  уникальной позиции в заказе `odid` (`rid`).  <br> Для расчета окончательной стоимости (суммы к оплате) следует пользоваться следующей формулой: <br> `priceWithDiscount = totalPrice * (1 - discountPercent/100)` 
         * @summary Продажи
         * @param {string} dateFrom Дата в формате RFC3339. Можно передать дату или дату со временем.  Время можно указывать с точностью до секунд или миллисекунд.  Литера &#x60;Z&#x60; в конце строки означает, что время передается в UTC-часовом поясе.  При ее отсутствии время считается в часовом поясе МСК (UTC+3). &lt;br&gt;Примеры: &lt;ul&gt; &lt;li&gt; &#x60;2019-06-20&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00Z&#x60; &lt;li&gt; &#x60;2019-06-20T23:59:59&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345Z&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345&#x60; &lt;li&gt; &#x60;2017-03-25T00:00:00&#x60; &lt;/ul&gt; 
         * @param {number} [flag] Если параметр &#x60;flag&#x3D;0&#x60; (или не указан в строке запроса), при вызове API возвращаются данные,  у которых значение поля &#x60;lastChangeDate&#x60; (дата время обновления информации в сервисе) больше или равно переданному  значению параметра &#x60;dateFrom&#x60;.  При этом количество возвращенных строк данных варьируется в интервале от 0 до примерно 100 000. &lt;br&gt; Если параметр &#x60;flag&#x3D;1&#x60;, то будет выгружена информация обо всех заказах или продажах с датой,  равной переданному параметру &#x60;dateFrom&#x60; (в данном случае время в дате значения не имеет).  При этом количество возвращенных строк данных будет равно количеству всех заказов или продаж,  сделанных в указанную дату, переданную в параметре &#x60;dateFrom&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SupplierSalesGet(dateFrom: string, flag?: number, options: any = {}): FetchArgs {
            // verify required parameter 'dateFrom' is not null or undefined
            if (dateFrom === null || dateFrom === undefined) {
                throw new RequiredError('dateFrom','Required parameter dateFrom was null or undefined when calling apiV1SupplierSalesGet.');
            }
            const localVarPath = `/api/v1/supplier/sales`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = dateFrom;
            }

            if (flag !== undefined) {
                localVarQueryParameter['flag'] = flag;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Склад. Данные обновляются раз в сутки. Сервис статистики не хранит историю остатков товаров, поэтому получить данные об остатках товаров на прошедшую, не сегодняшнюю, дату - невозможно.
         * @summary Склад
         * @param {string} dateFrom Дата в формате RFC3339. Можно передать дату или дату со временем.  Время можно указывать с точностью до секунд или миллисекунд.  Литера &#x60;Z&#x60; в конце строки означает, что время передается в UTC-часовом поясе.  При ее отсутствии время считается в часовом поясе МСК (UTC+3). &lt;br&gt;Примеры: &lt;ul&gt; &lt;li&gt; &#x60;2019-06-20&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00Z&#x60; &lt;li&gt; &#x60;2019-06-20T23:59:59&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345Z&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345&#x60; &lt;li&gt; &#x60;2017-03-25T00:00:00&#x60; &lt;/ul&gt; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SupplierStocksGet(dateFrom: string, options: any = {}): FetchArgs {
            // verify required parameter 'dateFrom' is not null or undefined
            if (dateFrom === null || dateFrom === undefined) {
                throw new RequiredError('dateFrom','Required parameter dateFrom was null or undefined when calling apiV1SupplierStocksGet.');
            }
            const localVarPath = `/api/v1/supplier/stocks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = dateFrom;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение информации по номенклатурам, их ценам, скидкам и промокодам. Если не указывать фильтры, вернётся весь товар.
         * @summary Получение информации о ценах.
         * @param {number} [quantity] &#x60;1&#x60; - товар с ненулевым остатком, &#x60;0&#x60; - товар с любым остатком
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicApiV1InfoGet(quantity?: number, options: any = {}): FetchArgs {
            const localVarPath = `/public/api/v1/info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (quantity !== undefined) {
                localVarQueryParameter['quantity'] = quantity;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Загрузка цен. За раз можно загрузить не более 1000 номенклатур.
         * @summary Загрузка цен
         * @param {Array<V1PricesBody>} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicApiV1PricesPost(body?: Array<V1PricesBody>, options: any = {}): FetchArgs {
            const localVarPath = `/public/api/v1/prices`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;V1PricesBody&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Метод позволяет изменить активность предметной группы для рекламы в поиске.<br> Изменение активности доступно только для РК в статусе 9 или 11. 
         * @summary Изменение активности предметной группы для РК в поиске
         * @param {number} id Идентификатор РК
         * @param {number} subjectId Идентификатор предметной группы, для которой меняется активность
         * @param {string} status Новое состояние (&#x60;true&#x60; - сделать группу активной или &#x60;false&#x60; - сделать группу неактивной)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0ActiveGet(id: number, subjectId: number, status: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).advV0ActiveGet(id, subjectId, status, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Получение информации об одной РК
         * @summary Информация о РК
         * @param {number} id Идентификатор РК
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0AdvertGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20034> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).advV0AdvertGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет получить список РК продавца.
         * @summary Список РК
         * @param {number} [status] &lt;dl&gt; &lt;dt&gt;Статус РК:&lt;/dt&gt; &lt;dd&gt;&lt;code&gt;7&lt;/code&gt; - РК завершена&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;9&lt;/code&gt; - идут показы&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;11&lt;/code&gt; - РК на паузе&lt;/dd&gt; &lt;/dl&gt; 
         * @param {number} [type] &lt;dl&gt; &lt;dt&gt;Тип РК:&lt;/dt&gt; &lt;dd&gt;&lt;code&gt;4&lt;/code&gt; - реклама в каталоге&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;5&lt;/code&gt; - реклама в карточке товара&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;6&lt;/code&gt; - реклама в поиске&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;7&lt;/code&gt; - реклама в рекомендациях на главной странице&lt;/dd&gt; &lt;/dl&gt; 
         * @param {number} [limit] Количество кампаний в ответе
         * @param {number} [offset] Смещение относительно первой РК
         * @param {string} [order] &lt;dl&gt; &lt;dt&gt;Порядок:&lt;/dt&gt; &lt;dd&gt;&lt;code&gt;create&lt;/code&gt; (по времени создания РК)&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;change&lt;/code&gt; (по времени последнего изменения РК)&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;id&lt;/code&gt; (по идентификатору РК)&lt;/dd&gt; &lt;/dl&gt; &lt;br&gt;Например: &lt;code&gt;**_/api/v0/adverts?type&#x3D;6&amp;limit&#x3D;5&amp;offset&#x3D;10&amp;&lt;b&gt;order&#x3D;change&lt;/b&gt;&amp;direction&#x3D;asc**&lt;/code&gt; 
         * @param {string} [direction] &lt;dl&gt; &lt;dt&gt;Направление:&lt;/dt&gt; &lt;dd&gt;&lt;code&gt;desc&lt;/code&gt; (от большего к меньшему)&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;asc&lt;/code&gt; (от меньшего к большему)&lt;/dd&gt; &lt;/dl&gt; &lt;br&gt;Например: &lt;code&gt;**_/api/v0/adverts?type&#x3D;6&amp;limit&#x3D;5&amp;offset&#x3D;10&amp;order&#x3D;change&amp;&lt;b&gt;direction&#x3D;asc&lt;/b&gt;**&lt;/code&gt; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0AdvertsGet(status?: number, type?: number, limit?: number, offset?: number, order?: string, direction?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20033>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).advV0AdvertsGet(status, type, limit, offset, order, direction, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет получить список ставок по типу размещения РК.<br> С помощью этого метода изменить ставку невозможно. 
         * @summary Список ставок по типу размещения РК
         * @param {V0AllcpmBody} body 
         * @param {number} type &lt;dl&gt; &lt;dt&gt;Тип РК:&lt;/dt&gt; &lt;dd&gt;&lt;code&gt;4&lt;/code&gt; - реклама в каталоге&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;5&lt;/code&gt; - реклама в карточке товара&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;6&lt;/code&gt; - реклама в поиске&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;7&lt;/code&gt; - реклама в рекомендациях на главной странице&lt;/dd&gt; &lt;/dl&gt; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0AllcpmPost(body: V0AllcpmBody, type: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20036>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).advV0AllcpmPost(body, type, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Получение количества рекламных кампаний (РК) поставщика
         * @summary Получение РК
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0CountGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20032> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).advV0CountGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Получение списка ставок для типа размещения. <br>Данные в ответе отсортированы по величине ставки от большей к меньшей. 
         * @summary Список ставок
         * @param {number} type &lt;dl&gt; &lt;dt&gt;Тип РК:&lt;/dt&gt; &lt;dd&gt;&lt;code&gt;4&lt;/code&gt; - реклама в каталоге&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;5&lt;/code&gt; - реклама в карточке товара&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;6&lt;/code&gt; - реклама в поиске&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;7&lt;/code&gt; - реклама в рекомендациях на главной странице&lt;/dd&gt; &lt;/dl&gt; 
         * @param {number} param Параметр запроса, по которому будет получен список ставок активных РК. &lt;br&gt;Должен быть значением &#x60;menuId&#x60;, &#x60;subjectId&#x60; или &#x60;setId&#x60; в зависимости от типа РК. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0CpmGet(type: number, param: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20035>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).advV0CpmGet(type, param, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Изменение ставки у рекламной кампании <br>Доступно для РК в карточке товара, поиске или рекомендациях 
         * @summary Изменение ставки у РК
         * @param {V0CpmBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0CpmPost(body: V0CpmBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).advV0CpmPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет изменить временной интервал показа рекламной кампании.
         * @summary Изменение интервалов показа РК
         * @param {V0IntervalsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0IntervalsPost(body?: V0IntervalsBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).advV0IntervalsPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет изменить активность номенклатур в РК.
         * @summary Изменение активности номенклатур РК
         * @param {V0NmactiveBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0NmactivePost(body?: V0NmactiveBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).advV0NmactivePost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет получить список значений параметра <code>menuId</code>.
         * @summary Словарь значений параметра menuId
         * @param {number} [id] Идентификатор меню, где размещается РК (для РК в каталоге). &lt;br&gt; Принимает значение параметра &#x60;menuId&#x60; из РК. &lt;br&gt; При пустом параметре вернётся весь список существующих значений. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0ParamsMenuGet(id?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20038>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).advV0ParamsMenuGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет получить список значений параметра <code>setId</code>.
         * @summary Словарь значений параметра setId
         * @param {number} [id] Идентификатор сочетания предмета и пола (для РК в карточке товара). &lt;br&gt; Принимает значение параметра &#x60;setId&#x60; из РК. &lt;br&gt; При пустом параметре вернётся весь список существующих значений. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0ParamsSetGet(id?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20039>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).advV0ParamsSetGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет получить список значений параметра <code>subjectId</code>.
         * @summary Словарь значений параметра subjectId
         * @param {number} [id] Идентификатор предметной группы, для которой создана РК (для РК в поиске и рекомендациях). &lt;br&gt; Принимает значение параметра &#x60;subjectId&#x60; из РК. &lt;br&gt; При пустом параметре вернётся весь список существующих значений. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0ParamsSubjectGet(id?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20037>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).advV0ParamsSubjectGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * РК в статусе <b>\"9 - идут показы\"</b> - можно запаузить, сделав <b>GET</b> на  `/api/v0/pause?id=***`. 
         * @summary Пауза РК
         * @param {number} id Идентификатор РК
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0PauseGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).advV0PauseGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет переименовать рекламную кампанию.
         * @summary Переименование РК
         * @param {V0RenameBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0RenamePost(body?: V0RenameBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).advV0RenamePost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * РК в статусе <b>\"11 - на паузе\"</b> - можно снова запустить. <br>Для запуска необходимо, чтобы у РК были активные ставки. <br><b>GET</b> на `/api/v0/start?id=***` - в ответ `200`, если статус изменен, или `400`, если это сделать не удалось. 
         * @summary Запуск РК
         * @param {number} id Идентификатор РК
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0StartGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).advV0StartGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет завершить РК, находящиеся в статусе 9 или 11.
         * @summary Завершение РК
         * @param {number} id Идентификатор РК
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0StopGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).advV0StopGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет удалить рекомендации. <br> `ВАЖНО!` Если запрос прошел успешно (код ответа 200), а рекомендации не удалились, то Вам необходимо проверить корректность отправленных значений. На данный момент в методе не предусмотрена валидация значений параметров. Тщательно проверяйте данные перед отправкой 
         * @summary Удаление рекомендаций
         * @param {Array<V1DelBody>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DelPost(body: Array<V1DelBody>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiV1DelPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет получить список архивных отзывов. <br> Отзыв становится архивным если на него предоставлен ответ или ответ не предоставлен в течение 30 дней со дня его публикации. 
         * @summary Список архивных отзывов
         * @param {number} take Количество отзывов
         * @param {number} skip Количество отзывов для пропуска
         * @param {number} [nmId] Артикул WB
         * @param {string} [order] Сортировка отзывов по дате (dateAsc/dateDesc)
         * @param {boolean} [hasSupplierComplaint] Отзывы с жалобой продавца(&#x60;true&#x60;) или без жалобы(&#x60;false&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FeedbacksArchiveGet(take: number, skip: number, nmId?: number, order?: string, hasSupplierComplaint?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20052> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiV1FeedbacksArchiveGet(take, skip, nmId, order, hasSupplierComplaint, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет получить количество необработанных отзывов за сегодня, за всё время, и среднюю оценку всех отзывов.
         * @summary Необработанные отзывы
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FeedbacksCountUnansweredGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20046> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiV1FeedbacksCountUnansweredGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет получить список отзывов по заданным параметрам с пагинацией и сортировкой.
         * @summary Список отзывов
         * @param {boolean} isAnswered Обработанные отзывы (&#x60;true&#x60;) или необработанные отзывы(&#x60;false&#x60;)
         * @param {number} take Количество отзывов (max. 10 000)
         * @param {number} skip Количество отзывов для пропуска
         * @param {number} [nmId] Артикул WB
         * @param {string} [order] Сортировка отзывов по дате (dateAsc/dateDesc)
         * @param {boolean} [hasSupplierComplaint] Отзывы с жалобой продавца(&#x60;true&#x60;) или без жалобы(&#x60;false&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FeedbacksGet(isAnswered: boolean, take: number, skip: number, nmId?: number, order?: string, hasSupplierComplaint?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20050> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiV1FeedbacksGet(isAnswered, take, skip, nmId, order, hasSupplierComplaint, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * <dl> <dt>В зависимости от тела запроса можно:</dt> <dd>Просмотреть отзыв.</dd> <dd>Ответить на отзыв.</dd> <dd>Создать жалобу на отзыв.</dd> </dl> 
         * @summary Работа с отзывом
         * @param {V1FeedbacksBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FeedbacksPatch(body?: V1FeedbacksBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiV1FeedbacksPatch(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет получить среднюю оценку товаров по родительской категории.
         * @summary Средняя оценка товаров по родительской категории
         * @param {number} subjectId id категории товара
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FeedbacksProductsRatingGet(subjectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20048> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiV1FeedbacksProductsRatingGet(subjectId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет получить среднюю оценку товара по его артикулу WB.
         * @summary Средняя оценка товара по артикулу WB
         * @param {number} nmId Артикул WB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FeedbacksProductsRatingNmidGet(nmId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20053> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiV1FeedbacksProductsRatingNmidGet(nmId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет получить список из двух товаров, с наибольшей и наименьшей средней оценкой, по родительской категории.
         * @summary Товары с наибольшей и наименьшей средней оценкой по родительской категории
         * @param {number} subjectId id категории товара
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FeedbacksProductsRatingTopGet(subjectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20049> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiV1FeedbacksProductsRatingTopGet(subjectId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет получить XLSX файл с отзывами в кодировке BASE64. <br> За один запрос можно получить 5000 отзывов. <br> На данный момент всего можно получить 200 000 последних отзывов. 
         * @summary Получение отзывов в формате XLSX
         * @param {boolean} isAnswered Необработанный(&#x60;false&#x60;) или в архиве(&#x60;true&#x60;)
         * @param {boolean} [hasSupplierComplaint] Отзывы с жалобой продавца(&#x60;true&#x60;) или без жалобы(&#x60;false&#x60;)
         * @param {number} [skip] Параметр пагинации, указывает сколько отзывов пропустить &lt;span class&#x3D;\&quot;new\&quot;&gt;new&lt;/span&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FeedbacksReportGet(isAnswered: boolean, hasSupplierComplaint?: boolean, skip?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20051> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiV1FeedbacksReportGet(isAnswered, hasSupplierComplaint, skip, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет добавить рекомендации к товару. <br> `ВАЖНО!` Если запрос прошел успешно (код ответа 200), а рекомендации не добавилась, то Вам необходимо проверить корректность отправленных значений.  <br>На данный момент в методе не предусмотрена валидация значений параметров.  <br>Тщательно проверяйте данные перед отправкой. <br>Ограничение по запросам: 120 запросов в минуту. 
         * @summary Добавление рекомендаций
         * @param {Array<V1InsBody>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1InsPost(body: Array<V1InsBody>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiV1InsPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет получить список рекомендаций по нескольким товарам
         * @summary Список рекомендаций
         * @param {number} nm Артикул WB (&#x60;nmId&#x60;), по которому необходимо получить список рекомендаций. &lt;br&gt; (max. 200) 
         * @param {number} [limit] Ограничение количества &#x60;nm&#x60; в ответе. (max. 999)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ListGet(nm: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20054> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiV1ListGet(nm, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод отображает информацию о наличии у продавца непросмотренных отзывов и вопросов.
         * @summary Непросмотренные отзывы и вопросы
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1NewFeedbacksQuestionsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20041> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiV1NewFeedbacksQuestionsGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет получить список родительских категорий товаров, которые есть у продавца.
         * @summary Родительские категории товаров
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ParentSubjectsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20047> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiV1ParentSubjectsGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет получить количество неотвеченных вопросов за сегодня и за всё время.
         * @summary Неотвеченные вопросы
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QuestionsCountUnansweredGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20040> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiV1QuestionsCountUnansweredGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет получить список вопросов по заданным параметрам с пагинацией и сортировкой.
         * @summary Список вопросов
         * @param {boolean} isAnswered Отвеченные вопросы (&#x60;true&#x60;) или неотвеченные вопросы(&#x60;false&#x60;) 
         * @param {number} take Количество вопросов (max. 10 000)
         * @param {number} skip Количество вопросов для пропуска
         * @param {number} [nmId] Артикул WB
         * @param {string} [order] Сортировка вопросов по дате (&#x60;dateAsc&#x60;/&#x60;dateDesc&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QuestionsGet(isAnswered: boolean, take: number, skip: number, nmId?: number, order?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20043> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiV1QuestionsGet(isAnswered, take, skip, nmId, order, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * <dl> <dt>В зависимости от тела запроса можно:</dt> <dd>Просмотреть вопрос.</dd> <dd>Отклонить вопрос.</dd> <dd>Ответить на вопрос.</dd> </dl> 
         * @summary Работа с вопросами
         * @param {V1QuestionsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QuestionsPatch(body?: V1QuestionsBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20044> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiV1QuestionsPatch(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет получить товары, про которые чаще всего спрашивают.
         * @summary Часто спрашиваемые товары
         * @param {number} size Количество запрашиваемых товаров (max. 100)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QuestionsProductsRatingGet(size: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20042> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiV1QuestionsProductsRatingGet(size, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет получить XLSX файл с вопросами в кодировке BASE64.
         * @summary Получение вопросов в формате XLSX
         * @param {boolean} isAnswered Обработанные вопросы (&#x60;true&#x60;) или необработанные вопросы(&#x60;false&#x60;) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QuestionsReportGet(isAnswered: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20045> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiV1QuestionsReportGet(isAnswered, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет добавлять, удалять рекомендации.<br> Работает по принципу перезаписи, все что указано в recom, ставится взамен того, что было ранее.<br> Чтобы удалить рекомендации необходимо передать пустой массив recom.    
         * @summary Управление рекомендациями
         * @param {Array<V1SetBody>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SetPost(body: Array<V1SetBody>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiV1SetPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Поставки
         * @summary Поставки
         * @param {string} dateFrom Дата в формате RFC3339. Можно передать дату или дату со временем.  Время можно указывать с точностью до секунд или миллисекунд.  Литера &#x60;Z&#x60; в конце строки означает, что время передается в UTC-часовом поясе.  При ее отсутствии время считается в часовом поясе МСК (UTC+3). &lt;br&gt;Примеры: &lt;ul&gt; &lt;li&gt; &#x60;2019-06-20&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00Z&#x60; &lt;li&gt; &#x60;2019-06-20T23:59:59&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345Z&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345&#x60; &lt;li&gt; &#x60;2017-03-25T00:00:00&#x60; &lt;/ul&gt; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SupplierIncomesGet(dateFrom: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<IncomesItem>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiV1SupplierIncomesGet(dateFrom, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Заказы. <br>  Важно: гарантируется хранение данных по заказам не более 90 дней от даты заказа. Данные обновляются раз в 30 минут.  Точное время обновления информации в сервисе можно увидеть в поле `lastChangeDate`. <br> Для идентификации товаров из одного заказа, а также продаж по ним, следует использовать  поле `gNumber` (строки с одинаковым значением этого поля относятся к одному заказу) и номер  уникальной позиции в заказе `odid` (`rid`).  
         * @summary Заказы
         * @param {string} dateFrom Дата в формате RFC3339. Можно передать дату или дату со временем.  Время можно указывать с точностью до секунд или миллисекунд.  Литера &#x60;Z&#x60; в конце строки означает, что время передается в UTC-часовом поясе.  При ее отсутствии время считается в часовом поясе МСК (UTC+3). &lt;br&gt;Примеры: &lt;ul&gt; &lt;li&gt; &#x60;2019-06-20&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00Z&#x60; &lt;li&gt; &#x60;2019-06-20T23:59:59&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345Z&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345&#x60; &lt;li&gt; &#x60;2017-03-25T00:00:00&#x60; &lt;/ul&gt; 
         * @param {number} [flag] Если параметр &#x60;flag&#x3D;0&#x60; (или не указан в строке запроса), при вызове API возвращаются данные,  у которых значение поля &#x60;lastChangeDate&#x60; (дата время обновления информации в сервисе) больше или равно переданному  значению параметра &#x60;dateFrom&#x60;.  При этом количество возвращенных строк данных варьируется в интервале от 0 до примерно 100 000. &lt;br&gt; Если параметр &#x60;flag&#x3D;1&#x60;, то будет выгружена информация обо всех заказах или продажах с датой,  равной переданному параметру &#x60;dateFrom&#x60; (в данном случае время в дате значения не имеет).  При этом количество возвращенных строк данных будет равно количеству всех заказов или продаж,  сделанных в указанную дату, переданную в параметре &#x60;dateFrom&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SupplierOrdersGet(dateFrom: string, flag?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OrdersItem>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiV1SupplierOrdersGet(dateFrom, flag, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Отчет о продажах по реализации.  <br> В отчете доступны данные за последние 3 месяца. <br> В случае отсутствия данных за указанный период метод вернет `null`. <br> Технический перерыв в работе метода: каждый понедельник с 3:00 до 16:00. <br> <a href=\"./excel/stat-excel.html\">Инструкция: Сохранение статистики в Excel</a> 
         * @summary Отчет о продажах по реализации
         * @param {string} dateFrom Дата в формате RFC3339. Можно передать дату или дату со временем.  Время можно указывать с точностью до секунд или миллисекунд.  Литера &#x60;Z&#x60; в конце строки означает, что время передается в UTC-часовом поясе.  При ее отсутствии время считается в часовом поясе МСК (UTC+3). &lt;br&gt;Примеры: &lt;ul&gt; &lt;li&gt; &#x60;2019-06-20&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00Z&#x60; &lt;li&gt; &#x60;2019-06-20T23:59:59&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345Z&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345&#x60; &lt;li&gt; &#x60;2017-03-25T00:00:00&#x60; &lt;/ul&gt; 
         * @param {string} dateTo Конечная дата отчета
         * @param {number} [limit] Максимальное количество строк отчета, возвращаемых методом. Не может быть более 100000.
         * @param {number} [rrdid] Уникальный идентификатор строки отчета. Необходим для получения отчета частями.  &lt;br&gt; Загрузку отчета нужно начинать с &#x60;rrdid &#x3D; 0&#x60; и при последующих вызовах API передавать в запросе значение &#x60;rrd_id&#x60; из последней строки, полученной в результате предыдущего вызова.  &lt;br&gt; Таким образом для загрузки одного отчета может понадобиться вызывать API до тех пор, пока количество возвращаемых строк не станет равным нулю. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SupplierReportDetailByPeriodGet(dateFrom: string, dateTo: string, limit?: number, rrdid?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DetailReportItem>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiV1SupplierReportDetailByPeriodGet(dateFrom, dateTo, limit, rrdid, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Продажи. <br> Важно: гарантируется хранение данных по заказам не более 90 дней от даты заказа. Данные обновляются раз в 30 минут. Точное время обновления информации в сервисе можно увидеть в поле `lastChangeDate`. <br> Для идентификации товаров из одного заказа, а также продаж по ним, следует использовать  поле `gNumber` (строки с одинаковым значением этого поля относятся к одному заказу) и номер  уникальной позиции в заказе `odid` (`rid`).  <br> Для расчета окончательной стоимости (суммы к оплате) следует пользоваться следующей формулой: <br> `priceWithDiscount = totalPrice * (1 - discountPercent/100)` 
         * @summary Продажи
         * @param {string} dateFrom Дата в формате RFC3339. Можно передать дату или дату со временем.  Время можно указывать с точностью до секунд или миллисекунд.  Литера &#x60;Z&#x60; в конце строки означает, что время передается в UTC-часовом поясе.  При ее отсутствии время считается в часовом поясе МСК (UTC+3). &lt;br&gt;Примеры: &lt;ul&gt; &lt;li&gt; &#x60;2019-06-20&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00Z&#x60; &lt;li&gt; &#x60;2019-06-20T23:59:59&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345Z&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345&#x60; &lt;li&gt; &#x60;2017-03-25T00:00:00&#x60; &lt;/ul&gt; 
         * @param {number} [flag] Если параметр &#x60;flag&#x3D;0&#x60; (или не указан в строке запроса), при вызове API возвращаются данные,  у которых значение поля &#x60;lastChangeDate&#x60; (дата время обновления информации в сервисе) больше или равно переданному  значению параметра &#x60;dateFrom&#x60;.  При этом количество возвращенных строк данных варьируется в интервале от 0 до примерно 100 000. &lt;br&gt; Если параметр &#x60;flag&#x3D;1&#x60;, то будет выгружена информация обо всех заказах или продажах с датой,  равной переданному параметру &#x60;dateFrom&#x60; (в данном случае время в дате значения не имеет).  При этом количество возвращенных строк данных будет равно количеству всех заказов или продаж,  сделанных в указанную дату, переданную в параметре &#x60;dateFrom&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SupplierSalesGet(dateFrom: string, flag?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SalesItem>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiV1SupplierSalesGet(dateFrom, flag, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Склад. Данные обновляются раз в сутки. Сервис статистики не хранит историю остатков товаров, поэтому получить данные об остатках товаров на прошедшую, не сегодняшнюю, дату - невозможно.
         * @summary Склад
         * @param {string} dateFrom Дата в формате RFC3339. Можно передать дату или дату со временем.  Время можно указывать с точностью до секунд или миллисекунд.  Литера &#x60;Z&#x60; в конце строки означает, что время передается в UTC-часовом поясе.  При ее отсутствии время считается в часовом поясе МСК (UTC+3). &lt;br&gt;Примеры: &lt;ul&gt; &lt;li&gt; &#x60;2019-06-20&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00Z&#x60; &lt;li&gt; &#x60;2019-06-20T23:59:59&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345Z&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345&#x60; &lt;li&gt; &#x60;2017-03-25T00:00:00&#x60; &lt;/ul&gt; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SupplierStocksGet(dateFrom: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<StocksItem>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiV1SupplierStocksGet(dateFrom, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Получение информации по номенклатурам, их ценам, скидкам и промокодам. Если не указывать фильтры, вернётся весь товар.
         * @summary Получение информации о ценах.
         * @param {number} [quantity] &#x60;1&#x60; - товар с ненулевым остатком, &#x60;0&#x60; - товар с любым остатком
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicApiV1InfoGet(quantity?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).publicApiV1InfoGet(quantity, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Загрузка цен. За раз можно загрузить не более 1000 номенклатур.
         * @summary Загрузка цен
         * @param {Array<V1PricesBody>} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicApiV1PricesPost(body?: Array<V1PricesBody>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).publicApiV1PricesPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Метод позволяет изменить активность предметной группы для рекламы в поиске.<br> Изменение активности доступно только для РК в статусе 9 или 11. 
         * @summary Изменение активности предметной группы для РК в поиске
         * @param {number} id Идентификатор РК
         * @param {number} subjectId Идентификатор предметной группы, для которой меняется активность
         * @param {string} status Новое состояние (&#x60;true&#x60; - сделать группу активной или &#x60;false&#x60; - сделать группу неактивной)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0ActiveGet(id: number, subjectId: number, status: string, options?: any) {
            return DefaultApiFp(configuration).advV0ActiveGet(id, subjectId, status, options)(fetch, basePath);
        },
        /**
         * Получение информации об одной РК
         * @summary Информация о РК
         * @param {number} id Идентификатор РК
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0AdvertGet(id: number, options?: any) {
            return DefaultApiFp(configuration).advV0AdvertGet(id, options)(fetch, basePath);
        },
        /**
         * Метод позволяет получить список РК продавца.
         * @summary Список РК
         * @param {number} [status] &lt;dl&gt; &lt;dt&gt;Статус РК:&lt;/dt&gt; &lt;dd&gt;&lt;code&gt;7&lt;/code&gt; - РК завершена&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;9&lt;/code&gt; - идут показы&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;11&lt;/code&gt; - РК на паузе&lt;/dd&gt; &lt;/dl&gt; 
         * @param {number} [type] &lt;dl&gt; &lt;dt&gt;Тип РК:&lt;/dt&gt; &lt;dd&gt;&lt;code&gt;4&lt;/code&gt; - реклама в каталоге&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;5&lt;/code&gt; - реклама в карточке товара&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;6&lt;/code&gt; - реклама в поиске&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;7&lt;/code&gt; - реклама в рекомендациях на главной странице&lt;/dd&gt; &lt;/dl&gt; 
         * @param {number} [limit] Количество кампаний в ответе
         * @param {number} [offset] Смещение относительно первой РК
         * @param {string} [order] &lt;dl&gt; &lt;dt&gt;Порядок:&lt;/dt&gt; &lt;dd&gt;&lt;code&gt;create&lt;/code&gt; (по времени создания РК)&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;change&lt;/code&gt; (по времени последнего изменения РК)&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;id&lt;/code&gt; (по идентификатору РК)&lt;/dd&gt; &lt;/dl&gt; &lt;br&gt;Например: &lt;code&gt;**_/api/v0/adverts?type&#x3D;6&amp;limit&#x3D;5&amp;offset&#x3D;10&amp;&lt;b&gt;order&#x3D;change&lt;/b&gt;&amp;direction&#x3D;asc**&lt;/code&gt; 
         * @param {string} [direction] &lt;dl&gt; &lt;dt&gt;Направление:&lt;/dt&gt; &lt;dd&gt;&lt;code&gt;desc&lt;/code&gt; (от большего к меньшему)&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;asc&lt;/code&gt; (от меньшего к большему)&lt;/dd&gt; &lt;/dl&gt; &lt;br&gt;Например: &lt;code&gt;**_/api/v0/adverts?type&#x3D;6&amp;limit&#x3D;5&amp;offset&#x3D;10&amp;order&#x3D;change&amp;&lt;b&gt;direction&#x3D;asc&lt;/b&gt;**&lt;/code&gt; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0AdvertsGet(status?: number, type?: number, limit?: number, offset?: number, order?: string, direction?: string, options?: any) {
            return DefaultApiFp(configuration).advV0AdvertsGet(status, type, limit, offset, order, direction, options)(fetch, basePath);
        },
        /**
         * Метод позволяет получить список ставок по типу размещения РК.<br> С помощью этого метода изменить ставку невозможно. 
         * @summary Список ставок по типу размещения РК
         * @param {V0AllcpmBody} body 
         * @param {number} type &lt;dl&gt; &lt;dt&gt;Тип РК:&lt;/dt&gt; &lt;dd&gt;&lt;code&gt;4&lt;/code&gt; - реклама в каталоге&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;5&lt;/code&gt; - реклама в карточке товара&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;6&lt;/code&gt; - реклама в поиске&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;7&lt;/code&gt; - реклама в рекомендациях на главной странице&lt;/dd&gt; &lt;/dl&gt; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0AllcpmPost(body: V0AllcpmBody, type: number, options?: any) {
            return DefaultApiFp(configuration).advV0AllcpmPost(body, type, options)(fetch, basePath);
        },
        /**
         * Получение количества рекламных кампаний (РК) поставщика
         * @summary Получение РК
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0CountGet(options?: any) {
            return DefaultApiFp(configuration).advV0CountGet(options)(fetch, basePath);
        },
        /**
         * Получение списка ставок для типа размещения. <br>Данные в ответе отсортированы по величине ставки от большей к меньшей. 
         * @summary Список ставок
         * @param {number} type &lt;dl&gt; &lt;dt&gt;Тип РК:&lt;/dt&gt; &lt;dd&gt;&lt;code&gt;4&lt;/code&gt; - реклама в каталоге&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;5&lt;/code&gt; - реклама в карточке товара&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;6&lt;/code&gt; - реклама в поиске&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;7&lt;/code&gt; - реклама в рекомендациях на главной странице&lt;/dd&gt; &lt;/dl&gt; 
         * @param {number} param Параметр запроса, по которому будет получен список ставок активных РК. &lt;br&gt;Должен быть значением &#x60;menuId&#x60;, &#x60;subjectId&#x60; или &#x60;setId&#x60; в зависимости от типа РК. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0CpmGet(type: number, param: number, options?: any) {
            return DefaultApiFp(configuration).advV0CpmGet(type, param, options)(fetch, basePath);
        },
        /**
         * Изменение ставки у рекламной кампании <br>Доступно для РК в карточке товара, поиске или рекомендациях 
         * @summary Изменение ставки у РК
         * @param {V0CpmBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0CpmPost(body: V0CpmBody, options?: any) {
            return DefaultApiFp(configuration).advV0CpmPost(body, options)(fetch, basePath);
        },
        /**
         * Метод позволяет изменить временной интервал показа рекламной кампании.
         * @summary Изменение интервалов показа РК
         * @param {V0IntervalsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0IntervalsPost(body?: V0IntervalsBody, options?: any) {
            return DefaultApiFp(configuration).advV0IntervalsPost(body, options)(fetch, basePath);
        },
        /**
         * Метод позволяет изменить активность номенклатур в РК.
         * @summary Изменение активности номенклатур РК
         * @param {V0NmactiveBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0NmactivePost(body?: V0NmactiveBody, options?: any) {
            return DefaultApiFp(configuration).advV0NmactivePost(body, options)(fetch, basePath);
        },
        /**
         * Метод позволяет получить список значений параметра <code>menuId</code>.
         * @summary Словарь значений параметра menuId
         * @param {number} [id] Идентификатор меню, где размещается РК (для РК в каталоге). &lt;br&gt; Принимает значение параметра &#x60;menuId&#x60; из РК. &lt;br&gt; При пустом параметре вернётся весь список существующих значений. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0ParamsMenuGet(id?: number, options?: any) {
            return DefaultApiFp(configuration).advV0ParamsMenuGet(id, options)(fetch, basePath);
        },
        /**
         * Метод позволяет получить список значений параметра <code>setId</code>.
         * @summary Словарь значений параметра setId
         * @param {number} [id] Идентификатор сочетания предмета и пола (для РК в карточке товара). &lt;br&gt; Принимает значение параметра &#x60;setId&#x60; из РК. &lt;br&gt; При пустом параметре вернётся весь список существующих значений. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0ParamsSetGet(id?: number, options?: any) {
            return DefaultApiFp(configuration).advV0ParamsSetGet(id, options)(fetch, basePath);
        },
        /**
         * Метод позволяет получить список значений параметра <code>subjectId</code>.
         * @summary Словарь значений параметра subjectId
         * @param {number} [id] Идентификатор предметной группы, для которой создана РК (для РК в поиске и рекомендациях). &lt;br&gt; Принимает значение параметра &#x60;subjectId&#x60; из РК. &lt;br&gt; При пустом параметре вернётся весь список существующих значений. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0ParamsSubjectGet(id?: number, options?: any) {
            return DefaultApiFp(configuration).advV0ParamsSubjectGet(id, options)(fetch, basePath);
        },
        /**
         * РК в статусе <b>\"9 - идут показы\"</b> - можно запаузить, сделав <b>GET</b> на  `/api/v0/pause?id=***`. 
         * @summary Пауза РК
         * @param {number} id Идентификатор РК
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0PauseGet(id: number, options?: any) {
            return DefaultApiFp(configuration).advV0PauseGet(id, options)(fetch, basePath);
        },
        /**
         * Метод позволяет переименовать рекламную кампанию.
         * @summary Переименование РК
         * @param {V0RenameBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0RenamePost(body?: V0RenameBody, options?: any) {
            return DefaultApiFp(configuration).advV0RenamePost(body, options)(fetch, basePath);
        },
        /**
         * РК в статусе <b>\"11 - на паузе\"</b> - можно снова запустить. <br>Для запуска необходимо, чтобы у РК были активные ставки. <br><b>GET</b> на `/api/v0/start?id=***` - в ответ `200`, если статус изменен, или `400`, если это сделать не удалось. 
         * @summary Запуск РК
         * @param {number} id Идентификатор РК
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0StartGet(id: number, options?: any) {
            return DefaultApiFp(configuration).advV0StartGet(id, options)(fetch, basePath);
        },
        /**
         * Метод позволяет завершить РК, находящиеся в статусе 9 или 11.
         * @summary Завершение РК
         * @param {number} id Идентификатор РК
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advV0StopGet(id: number, options?: any) {
            return DefaultApiFp(configuration).advV0StopGet(id, options)(fetch, basePath);
        },
        /**
         * Метод позволяет удалить рекомендации. <br> `ВАЖНО!` Если запрос прошел успешно (код ответа 200), а рекомендации не удалились, то Вам необходимо проверить корректность отправленных значений. На данный момент в методе не предусмотрена валидация значений параметров. Тщательно проверяйте данные перед отправкой 
         * @summary Удаление рекомендаций
         * @param {Array<V1DelBody>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DelPost(body: Array<V1DelBody>, options?: any) {
            return DefaultApiFp(configuration).apiV1DelPost(body, options)(fetch, basePath);
        },
        /**
         * Метод позволяет получить список архивных отзывов. <br> Отзыв становится архивным если на него предоставлен ответ или ответ не предоставлен в течение 30 дней со дня его публикации. 
         * @summary Список архивных отзывов
         * @param {number} take Количество отзывов
         * @param {number} skip Количество отзывов для пропуска
         * @param {number} [nmId] Артикул WB
         * @param {string} [order] Сортировка отзывов по дате (dateAsc/dateDesc)
         * @param {boolean} [hasSupplierComplaint] Отзывы с жалобой продавца(&#x60;true&#x60;) или без жалобы(&#x60;false&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FeedbacksArchiveGet(take: number, skip: number, nmId?: number, order?: string, hasSupplierComplaint?: boolean, options?: any) {
            return DefaultApiFp(configuration).apiV1FeedbacksArchiveGet(take, skip, nmId, order, hasSupplierComplaint, options)(fetch, basePath);
        },
        /**
         * Метод позволяет получить количество необработанных отзывов за сегодня, за всё время, и среднюю оценку всех отзывов.
         * @summary Необработанные отзывы
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FeedbacksCountUnansweredGet(options?: any) {
            return DefaultApiFp(configuration).apiV1FeedbacksCountUnansweredGet(options)(fetch, basePath);
        },
        /**
         * Метод позволяет получить список отзывов по заданным параметрам с пагинацией и сортировкой.
         * @summary Список отзывов
         * @param {boolean} isAnswered Обработанные отзывы (&#x60;true&#x60;) или необработанные отзывы(&#x60;false&#x60;)
         * @param {number} take Количество отзывов (max. 10 000)
         * @param {number} skip Количество отзывов для пропуска
         * @param {number} [nmId] Артикул WB
         * @param {string} [order] Сортировка отзывов по дате (dateAsc/dateDesc)
         * @param {boolean} [hasSupplierComplaint] Отзывы с жалобой продавца(&#x60;true&#x60;) или без жалобы(&#x60;false&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FeedbacksGet(isAnswered: boolean, take: number, skip: number, nmId?: number, order?: string, hasSupplierComplaint?: boolean, options?: any) {
            return DefaultApiFp(configuration).apiV1FeedbacksGet(isAnswered, take, skip, nmId, order, hasSupplierComplaint, options)(fetch, basePath);
        },
        /**
         * <dl> <dt>В зависимости от тела запроса можно:</dt> <dd>Просмотреть отзыв.</dd> <dd>Ответить на отзыв.</dd> <dd>Создать жалобу на отзыв.</dd> </dl> 
         * @summary Работа с отзывом
         * @param {V1FeedbacksBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FeedbacksPatch(body?: V1FeedbacksBody, options?: any) {
            return DefaultApiFp(configuration).apiV1FeedbacksPatch(body, options)(fetch, basePath);
        },
        /**
         * Метод позволяет получить среднюю оценку товаров по родительской категории.
         * @summary Средняя оценка товаров по родительской категории
         * @param {number} subjectId id категории товара
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FeedbacksProductsRatingGet(subjectId: number, options?: any) {
            return DefaultApiFp(configuration).apiV1FeedbacksProductsRatingGet(subjectId, options)(fetch, basePath);
        },
        /**
         * Метод позволяет получить среднюю оценку товара по его артикулу WB.
         * @summary Средняя оценка товара по артикулу WB
         * @param {number} nmId Артикул WB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FeedbacksProductsRatingNmidGet(nmId: number, options?: any) {
            return DefaultApiFp(configuration).apiV1FeedbacksProductsRatingNmidGet(nmId, options)(fetch, basePath);
        },
        /**
         * Метод позволяет получить список из двух товаров, с наибольшей и наименьшей средней оценкой, по родительской категории.
         * @summary Товары с наибольшей и наименьшей средней оценкой по родительской категории
         * @param {number} subjectId id категории товара
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FeedbacksProductsRatingTopGet(subjectId: number, options?: any) {
            return DefaultApiFp(configuration).apiV1FeedbacksProductsRatingTopGet(subjectId, options)(fetch, basePath);
        },
        /**
         * Метод позволяет получить XLSX файл с отзывами в кодировке BASE64. <br> За один запрос можно получить 5000 отзывов. <br> На данный момент всего можно получить 200 000 последних отзывов. 
         * @summary Получение отзывов в формате XLSX
         * @param {boolean} isAnswered Необработанный(&#x60;false&#x60;) или в архиве(&#x60;true&#x60;)
         * @param {boolean} [hasSupplierComplaint] Отзывы с жалобой продавца(&#x60;true&#x60;) или без жалобы(&#x60;false&#x60;)
         * @param {number} [skip] Параметр пагинации, указывает сколько отзывов пропустить &lt;span class&#x3D;\&quot;new\&quot;&gt;new&lt;/span&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FeedbacksReportGet(isAnswered: boolean, hasSupplierComplaint?: boolean, skip?: number, options?: any) {
            return DefaultApiFp(configuration).apiV1FeedbacksReportGet(isAnswered, hasSupplierComplaint, skip, options)(fetch, basePath);
        },
        /**
         * Метод позволяет добавить рекомендации к товару. <br> `ВАЖНО!` Если запрос прошел успешно (код ответа 200), а рекомендации не добавилась, то Вам необходимо проверить корректность отправленных значений.  <br>На данный момент в методе не предусмотрена валидация значений параметров.  <br>Тщательно проверяйте данные перед отправкой. <br>Ограничение по запросам: 120 запросов в минуту. 
         * @summary Добавление рекомендаций
         * @param {Array<V1InsBody>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1InsPost(body: Array<V1InsBody>, options?: any) {
            return DefaultApiFp(configuration).apiV1InsPost(body, options)(fetch, basePath);
        },
        /**
         * Метод позволяет получить список рекомендаций по нескольким товарам
         * @summary Список рекомендаций
         * @param {number} nm Артикул WB (&#x60;nmId&#x60;), по которому необходимо получить список рекомендаций. &lt;br&gt; (max. 200) 
         * @param {number} [limit] Ограничение количества &#x60;nm&#x60; в ответе. (max. 999)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ListGet(nm: number, limit?: number, options?: any) {
            return DefaultApiFp(configuration).apiV1ListGet(nm, limit, options)(fetch, basePath);
        },
        /**
         * Метод отображает информацию о наличии у продавца непросмотренных отзывов и вопросов.
         * @summary Непросмотренные отзывы и вопросы
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1NewFeedbacksQuestionsGet(options?: any) {
            return DefaultApiFp(configuration).apiV1NewFeedbacksQuestionsGet(options)(fetch, basePath);
        },
        /**
         * Метод позволяет получить список родительских категорий товаров, которые есть у продавца.
         * @summary Родительские категории товаров
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1ParentSubjectsGet(options?: any) {
            return DefaultApiFp(configuration).apiV1ParentSubjectsGet(options)(fetch, basePath);
        },
        /**
         * Метод позволяет получить количество неотвеченных вопросов за сегодня и за всё время.
         * @summary Неотвеченные вопросы
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QuestionsCountUnansweredGet(options?: any) {
            return DefaultApiFp(configuration).apiV1QuestionsCountUnansweredGet(options)(fetch, basePath);
        },
        /**
         * Метод позволяет получить список вопросов по заданным параметрам с пагинацией и сортировкой.
         * @summary Список вопросов
         * @param {boolean} isAnswered Отвеченные вопросы (&#x60;true&#x60;) или неотвеченные вопросы(&#x60;false&#x60;) 
         * @param {number} take Количество вопросов (max. 10 000)
         * @param {number} skip Количество вопросов для пропуска
         * @param {number} [nmId] Артикул WB
         * @param {string} [order] Сортировка вопросов по дате (&#x60;dateAsc&#x60;/&#x60;dateDesc&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QuestionsGet(isAnswered: boolean, take: number, skip: number, nmId?: number, order?: string, options?: any) {
            return DefaultApiFp(configuration).apiV1QuestionsGet(isAnswered, take, skip, nmId, order, options)(fetch, basePath);
        },
        /**
         * <dl> <dt>В зависимости от тела запроса можно:</dt> <dd>Просмотреть вопрос.</dd> <dd>Отклонить вопрос.</dd> <dd>Ответить на вопрос.</dd> </dl> 
         * @summary Работа с вопросами
         * @param {V1QuestionsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QuestionsPatch(body?: V1QuestionsBody, options?: any) {
            return DefaultApiFp(configuration).apiV1QuestionsPatch(body, options)(fetch, basePath);
        },
        /**
         * Метод позволяет получить товары, про которые чаще всего спрашивают.
         * @summary Часто спрашиваемые товары
         * @param {number} size Количество запрашиваемых товаров (max. 100)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QuestionsProductsRatingGet(size: number, options?: any) {
            return DefaultApiFp(configuration).apiV1QuestionsProductsRatingGet(size, options)(fetch, basePath);
        },
        /**
         * Метод позволяет получить XLSX файл с вопросами в кодировке BASE64.
         * @summary Получение вопросов в формате XLSX
         * @param {boolean} isAnswered Обработанные вопросы (&#x60;true&#x60;) или необработанные вопросы(&#x60;false&#x60;) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1QuestionsReportGet(isAnswered: boolean, options?: any) {
            return DefaultApiFp(configuration).apiV1QuestionsReportGet(isAnswered, options)(fetch, basePath);
        },
        /**
         * Метод позволяет добавлять, удалять рекомендации.<br> Работает по принципу перезаписи, все что указано в recom, ставится взамен того, что было ранее.<br> Чтобы удалить рекомендации необходимо передать пустой массив recom.    
         * @summary Управление рекомендациями
         * @param {Array<V1SetBody>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SetPost(body: Array<V1SetBody>, options?: any) {
            return DefaultApiFp(configuration).apiV1SetPost(body, options)(fetch, basePath);
        },
        /**
         * Поставки
         * @summary Поставки
         * @param {string} dateFrom Дата в формате RFC3339. Можно передать дату или дату со временем.  Время можно указывать с точностью до секунд или миллисекунд.  Литера &#x60;Z&#x60; в конце строки означает, что время передается в UTC-часовом поясе.  При ее отсутствии время считается в часовом поясе МСК (UTC+3). &lt;br&gt;Примеры: &lt;ul&gt; &lt;li&gt; &#x60;2019-06-20&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00Z&#x60; &lt;li&gt; &#x60;2019-06-20T23:59:59&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345Z&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345&#x60; &lt;li&gt; &#x60;2017-03-25T00:00:00&#x60; &lt;/ul&gt; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SupplierIncomesGet(dateFrom: string, options?: any) {
            return DefaultApiFp(configuration).apiV1SupplierIncomesGet(dateFrom, options)(fetch, basePath);
        },
        /**
         * Заказы. <br>  Важно: гарантируется хранение данных по заказам не более 90 дней от даты заказа. Данные обновляются раз в 30 минут.  Точное время обновления информации в сервисе можно увидеть в поле `lastChangeDate`. <br> Для идентификации товаров из одного заказа, а также продаж по ним, следует использовать  поле `gNumber` (строки с одинаковым значением этого поля относятся к одному заказу) и номер  уникальной позиции в заказе `odid` (`rid`).  
         * @summary Заказы
         * @param {string} dateFrom Дата в формате RFC3339. Можно передать дату или дату со временем.  Время можно указывать с точностью до секунд или миллисекунд.  Литера &#x60;Z&#x60; в конце строки означает, что время передается в UTC-часовом поясе.  При ее отсутствии время считается в часовом поясе МСК (UTC+3). &lt;br&gt;Примеры: &lt;ul&gt; &lt;li&gt; &#x60;2019-06-20&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00Z&#x60; &lt;li&gt; &#x60;2019-06-20T23:59:59&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345Z&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345&#x60; &lt;li&gt; &#x60;2017-03-25T00:00:00&#x60; &lt;/ul&gt; 
         * @param {number} [flag] Если параметр &#x60;flag&#x3D;0&#x60; (или не указан в строке запроса), при вызове API возвращаются данные,  у которых значение поля &#x60;lastChangeDate&#x60; (дата время обновления информации в сервисе) больше или равно переданному  значению параметра &#x60;dateFrom&#x60;.  При этом количество возвращенных строк данных варьируется в интервале от 0 до примерно 100 000. &lt;br&gt; Если параметр &#x60;flag&#x3D;1&#x60;, то будет выгружена информация обо всех заказах или продажах с датой,  равной переданному параметру &#x60;dateFrom&#x60; (в данном случае время в дате значения не имеет).  При этом количество возвращенных строк данных будет равно количеству всех заказов или продаж,  сделанных в указанную дату, переданную в параметре &#x60;dateFrom&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SupplierOrdersGet(dateFrom: string, flag?: number, options?: any) {
            return DefaultApiFp(configuration).apiV1SupplierOrdersGet(dateFrom, flag, options)(fetch, basePath);
        },
        /**
         * Отчет о продажах по реализации.  <br> В отчете доступны данные за последние 3 месяца. <br> В случае отсутствия данных за указанный период метод вернет `null`. <br> Технический перерыв в работе метода: каждый понедельник с 3:00 до 16:00. <br> <a href=\"./excel/stat-excel.html\">Инструкция: Сохранение статистики в Excel</a> 
         * @summary Отчет о продажах по реализации
         * @param {string} dateFrom Дата в формате RFC3339. Можно передать дату или дату со временем.  Время можно указывать с точностью до секунд или миллисекунд.  Литера &#x60;Z&#x60; в конце строки означает, что время передается в UTC-часовом поясе.  При ее отсутствии время считается в часовом поясе МСК (UTC+3). &lt;br&gt;Примеры: &lt;ul&gt; &lt;li&gt; &#x60;2019-06-20&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00Z&#x60; &lt;li&gt; &#x60;2019-06-20T23:59:59&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345Z&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345&#x60; &lt;li&gt; &#x60;2017-03-25T00:00:00&#x60; &lt;/ul&gt; 
         * @param {string} dateTo Конечная дата отчета
         * @param {number} [limit] Максимальное количество строк отчета, возвращаемых методом. Не может быть более 100000.
         * @param {number} [rrdid] Уникальный идентификатор строки отчета. Необходим для получения отчета частями.  &lt;br&gt; Загрузку отчета нужно начинать с &#x60;rrdid &#x3D; 0&#x60; и при последующих вызовах API передавать в запросе значение &#x60;rrd_id&#x60; из последней строки, полученной в результате предыдущего вызова.  &lt;br&gt; Таким образом для загрузки одного отчета может понадобиться вызывать API до тех пор, пока количество возвращаемых строк не станет равным нулю. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SupplierReportDetailByPeriodGet(dateFrom: string, dateTo: string, limit?: number, rrdid?: number, options?: any) {
            return DefaultApiFp(configuration).apiV1SupplierReportDetailByPeriodGet(dateFrom, dateTo, limit, rrdid, options)(fetch, basePath);
        },
        /**
         * Продажи. <br> Важно: гарантируется хранение данных по заказам не более 90 дней от даты заказа. Данные обновляются раз в 30 минут. Точное время обновления информации в сервисе можно увидеть в поле `lastChangeDate`. <br> Для идентификации товаров из одного заказа, а также продаж по ним, следует использовать  поле `gNumber` (строки с одинаковым значением этого поля относятся к одному заказу) и номер  уникальной позиции в заказе `odid` (`rid`).  <br> Для расчета окончательной стоимости (суммы к оплате) следует пользоваться следующей формулой: <br> `priceWithDiscount = totalPrice * (1 - discountPercent/100)` 
         * @summary Продажи
         * @param {string} dateFrom Дата в формате RFC3339. Можно передать дату или дату со временем.  Время можно указывать с точностью до секунд или миллисекунд.  Литера &#x60;Z&#x60; в конце строки означает, что время передается в UTC-часовом поясе.  При ее отсутствии время считается в часовом поясе МСК (UTC+3). &lt;br&gt;Примеры: &lt;ul&gt; &lt;li&gt; &#x60;2019-06-20&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00Z&#x60; &lt;li&gt; &#x60;2019-06-20T23:59:59&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345Z&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345&#x60; &lt;li&gt; &#x60;2017-03-25T00:00:00&#x60; &lt;/ul&gt; 
         * @param {number} [flag] Если параметр &#x60;flag&#x3D;0&#x60; (или не указан в строке запроса), при вызове API возвращаются данные,  у которых значение поля &#x60;lastChangeDate&#x60; (дата время обновления информации в сервисе) больше или равно переданному  значению параметра &#x60;dateFrom&#x60;.  При этом количество возвращенных строк данных варьируется в интервале от 0 до примерно 100 000. &lt;br&gt; Если параметр &#x60;flag&#x3D;1&#x60;, то будет выгружена информация обо всех заказах или продажах с датой,  равной переданному параметру &#x60;dateFrom&#x60; (в данном случае время в дате значения не имеет).  При этом количество возвращенных строк данных будет равно количеству всех заказов или продаж,  сделанных в указанную дату, переданную в параметре &#x60;dateFrom&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SupplierSalesGet(dateFrom: string, flag?: number, options?: any) {
            return DefaultApiFp(configuration).apiV1SupplierSalesGet(dateFrom, flag, options)(fetch, basePath);
        },
        /**
         * Склад. Данные обновляются раз в сутки. Сервис статистики не хранит историю остатков товаров, поэтому получить данные об остатках товаров на прошедшую, не сегодняшнюю, дату - невозможно.
         * @summary Склад
         * @param {string} dateFrom Дата в формате RFC3339. Можно передать дату или дату со временем.  Время можно указывать с точностью до секунд или миллисекунд.  Литера &#x60;Z&#x60; в конце строки означает, что время передается в UTC-часовом поясе.  При ее отсутствии время считается в часовом поясе МСК (UTC+3). &lt;br&gt;Примеры: &lt;ul&gt; &lt;li&gt; &#x60;2019-06-20&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00Z&#x60; &lt;li&gt; &#x60;2019-06-20T23:59:59&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345Z&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345&#x60; &lt;li&gt; &#x60;2017-03-25T00:00:00&#x60; &lt;/ul&gt; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1SupplierStocksGet(dateFrom: string, options?: any) {
            return DefaultApiFp(configuration).apiV1SupplierStocksGet(dateFrom, options)(fetch, basePath);
        },
        /**
         * Получение информации по номенклатурам, их ценам, скидкам и промокодам. Если не указывать фильтры, вернётся весь товар.
         * @summary Получение информации о ценах.
         * @param {number} [quantity] &#x60;1&#x60; - товар с ненулевым остатком, &#x60;0&#x60; - товар с любым остатком
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicApiV1InfoGet(quantity?: number, options?: any) {
            return DefaultApiFp(configuration).publicApiV1InfoGet(quantity, options)(fetch, basePath);
        },
        /**
         * Загрузка цен. За раз можно загрузить не более 1000 номенклатур.
         * @summary Загрузка цен
         * @param {Array<V1PricesBody>} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicApiV1PricesPost(body?: Array<V1PricesBody>, options?: any) {
            return DefaultApiFp(configuration).publicApiV1PricesPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Метод позволяет изменить активность предметной группы для рекламы в поиске.<br> Изменение активности доступно только для РК в статусе 9 или 11. 
     * @summary Изменение активности предметной группы для РК в поиске
     * @param {number} id Идентификатор РК
     * @param {number} subjectId Идентификатор предметной группы, для которой меняется активность
     * @param {string} status Новое состояние (&#x60;true&#x60; - сделать группу активной или &#x60;false&#x60; - сделать группу неактивной)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public advV0ActiveGet(id: number, subjectId: number, status: string, options?: any) {
        return DefaultApiFp(this.configuration).advV0ActiveGet(id, subjectId, status, options)(this.fetch, this.basePath);
    }

    /**
     * Получение информации об одной РК
     * @summary Информация о РК
     * @param {number} id Идентификатор РК
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public advV0AdvertGet(id: number, options?: any) {
        return DefaultApiFp(this.configuration).advV0AdvertGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет получить список РК продавца.
     * @summary Список РК
     * @param {number} [status] &lt;dl&gt; &lt;dt&gt;Статус РК:&lt;/dt&gt; &lt;dd&gt;&lt;code&gt;7&lt;/code&gt; - РК завершена&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;9&lt;/code&gt; - идут показы&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;11&lt;/code&gt; - РК на паузе&lt;/dd&gt; &lt;/dl&gt; 
     * @param {number} [type] &lt;dl&gt; &lt;dt&gt;Тип РК:&lt;/dt&gt; &lt;dd&gt;&lt;code&gt;4&lt;/code&gt; - реклама в каталоге&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;5&lt;/code&gt; - реклама в карточке товара&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;6&lt;/code&gt; - реклама в поиске&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;7&lt;/code&gt; - реклама в рекомендациях на главной странице&lt;/dd&gt; &lt;/dl&gt; 
     * @param {number} [limit] Количество кампаний в ответе
     * @param {number} [offset] Смещение относительно первой РК
     * @param {string} [order] &lt;dl&gt; &lt;dt&gt;Порядок:&lt;/dt&gt; &lt;dd&gt;&lt;code&gt;create&lt;/code&gt; (по времени создания РК)&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;change&lt;/code&gt; (по времени последнего изменения РК)&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;id&lt;/code&gt; (по идентификатору РК)&lt;/dd&gt; &lt;/dl&gt; &lt;br&gt;Например: &lt;code&gt;**_/api/v0/adverts?type&#x3D;6&amp;limit&#x3D;5&amp;offset&#x3D;10&amp;&lt;b&gt;order&#x3D;change&lt;/b&gt;&amp;direction&#x3D;asc**&lt;/code&gt; 
     * @param {string} [direction] &lt;dl&gt; &lt;dt&gt;Направление:&lt;/dt&gt; &lt;dd&gt;&lt;code&gt;desc&lt;/code&gt; (от большего к меньшему)&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;asc&lt;/code&gt; (от меньшего к большему)&lt;/dd&gt; &lt;/dl&gt; &lt;br&gt;Например: &lt;code&gt;**_/api/v0/adverts?type&#x3D;6&amp;limit&#x3D;5&amp;offset&#x3D;10&amp;order&#x3D;change&amp;&lt;b&gt;direction&#x3D;asc&lt;/b&gt;**&lt;/code&gt; 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public advV0AdvertsGet(status?: number, type?: number, limit?: number, offset?: number, order?: string, direction?: string, options?: any) {
        return DefaultApiFp(this.configuration).advV0AdvertsGet(status, type, limit, offset, order, direction, options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет получить список ставок по типу размещения РК.<br> С помощью этого метода изменить ставку невозможно. 
     * @summary Список ставок по типу размещения РК
     * @param {V0AllcpmBody} body 
     * @param {number} type &lt;dl&gt; &lt;dt&gt;Тип РК:&lt;/dt&gt; &lt;dd&gt;&lt;code&gt;4&lt;/code&gt; - реклама в каталоге&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;5&lt;/code&gt; - реклама в карточке товара&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;6&lt;/code&gt; - реклама в поиске&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;7&lt;/code&gt; - реклама в рекомендациях на главной странице&lt;/dd&gt; &lt;/dl&gt; 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public advV0AllcpmPost(body: V0AllcpmBody, type: number, options?: any) {
        return DefaultApiFp(this.configuration).advV0AllcpmPost(body, type, options)(this.fetch, this.basePath);
    }

    /**
     * Получение количества рекламных кампаний (РК) поставщика
     * @summary Получение РК
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public advV0CountGet(options?: any) {
        return DefaultApiFp(this.configuration).advV0CountGet(options)(this.fetch, this.basePath);
    }

    /**
     * Получение списка ставок для типа размещения. <br>Данные в ответе отсортированы по величине ставки от большей к меньшей. 
     * @summary Список ставок
     * @param {number} type &lt;dl&gt; &lt;dt&gt;Тип РК:&lt;/dt&gt; &lt;dd&gt;&lt;code&gt;4&lt;/code&gt; - реклама в каталоге&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;5&lt;/code&gt; - реклама в карточке товара&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;6&lt;/code&gt; - реклама в поиске&lt;/dd&gt; &lt;dd&gt;&lt;code&gt;7&lt;/code&gt; - реклама в рекомендациях на главной странице&lt;/dd&gt; &lt;/dl&gt; 
     * @param {number} param Параметр запроса, по которому будет получен список ставок активных РК. &lt;br&gt;Должен быть значением &#x60;menuId&#x60;, &#x60;subjectId&#x60; или &#x60;setId&#x60; в зависимости от типа РК. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public advV0CpmGet(type: number, param: number, options?: any) {
        return DefaultApiFp(this.configuration).advV0CpmGet(type, param, options)(this.fetch, this.basePath);
    }

    /**
     * Изменение ставки у рекламной кампании <br>Доступно для РК в карточке товара, поиске или рекомендациях 
     * @summary Изменение ставки у РК
     * @param {V0CpmBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public advV0CpmPost(body: V0CpmBody, options?: any) {
        return DefaultApiFp(this.configuration).advV0CpmPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет изменить временной интервал показа рекламной кампании.
     * @summary Изменение интервалов показа РК
     * @param {V0IntervalsBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public advV0IntervalsPost(body?: V0IntervalsBody, options?: any) {
        return DefaultApiFp(this.configuration).advV0IntervalsPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет изменить активность номенклатур в РК.
     * @summary Изменение активности номенклатур РК
     * @param {V0NmactiveBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public advV0NmactivePost(body?: V0NmactiveBody, options?: any) {
        return DefaultApiFp(this.configuration).advV0NmactivePost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет получить список значений параметра <code>menuId</code>.
     * @summary Словарь значений параметра menuId
     * @param {number} [id] Идентификатор меню, где размещается РК (для РК в каталоге). &lt;br&gt; Принимает значение параметра &#x60;menuId&#x60; из РК. &lt;br&gt; При пустом параметре вернётся весь список существующих значений. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public advV0ParamsMenuGet(id?: number, options?: any) {
        return DefaultApiFp(this.configuration).advV0ParamsMenuGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет получить список значений параметра <code>setId</code>.
     * @summary Словарь значений параметра setId
     * @param {number} [id] Идентификатор сочетания предмета и пола (для РК в карточке товара). &lt;br&gt; Принимает значение параметра &#x60;setId&#x60; из РК. &lt;br&gt; При пустом параметре вернётся весь список существующих значений. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public advV0ParamsSetGet(id?: number, options?: any) {
        return DefaultApiFp(this.configuration).advV0ParamsSetGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет получить список значений параметра <code>subjectId</code>.
     * @summary Словарь значений параметра subjectId
     * @param {number} [id] Идентификатор предметной группы, для которой создана РК (для РК в поиске и рекомендациях). &lt;br&gt; Принимает значение параметра &#x60;subjectId&#x60; из РК. &lt;br&gt; При пустом параметре вернётся весь список существующих значений. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public advV0ParamsSubjectGet(id?: number, options?: any) {
        return DefaultApiFp(this.configuration).advV0ParamsSubjectGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * РК в статусе <b>\"9 - идут показы\"</b> - можно запаузить, сделав <b>GET</b> на  `/api/v0/pause?id=***`. 
     * @summary Пауза РК
     * @param {number} id Идентификатор РК
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public advV0PauseGet(id: number, options?: any) {
        return DefaultApiFp(this.configuration).advV0PauseGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет переименовать рекламную кампанию.
     * @summary Переименование РК
     * @param {V0RenameBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public advV0RenamePost(body?: V0RenameBody, options?: any) {
        return DefaultApiFp(this.configuration).advV0RenamePost(body, options)(this.fetch, this.basePath);
    }

    /**
     * РК в статусе <b>\"11 - на паузе\"</b> - можно снова запустить. <br>Для запуска необходимо, чтобы у РК были активные ставки. <br><b>GET</b> на `/api/v0/start?id=***` - в ответ `200`, если статус изменен, или `400`, если это сделать не удалось. 
     * @summary Запуск РК
     * @param {number} id Идентификатор РК
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public advV0StartGet(id: number, options?: any) {
        return DefaultApiFp(this.configuration).advV0StartGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет завершить РК, находящиеся в статусе 9 или 11.
     * @summary Завершение РК
     * @param {number} id Идентификатор РК
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public advV0StopGet(id: number, options?: any) {
        return DefaultApiFp(this.configuration).advV0StopGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет удалить рекомендации. <br> `ВАЖНО!` Если запрос прошел успешно (код ответа 200), а рекомендации не удалились, то Вам необходимо проверить корректность отправленных значений. На данный момент в методе не предусмотрена валидация значений параметров. Тщательно проверяйте данные перед отправкой 
     * @summary Удаление рекомендаций
     * @param {Array<V1DelBody>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1DelPost(body: Array<V1DelBody>, options?: any) {
        return DefaultApiFp(this.configuration).apiV1DelPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет получить список архивных отзывов. <br> Отзыв становится архивным если на него предоставлен ответ или ответ не предоставлен в течение 30 дней со дня его публикации. 
     * @summary Список архивных отзывов
     * @param {number} take Количество отзывов
     * @param {number} skip Количество отзывов для пропуска
     * @param {number} [nmId] Артикул WB
     * @param {string} [order] Сортировка отзывов по дате (dateAsc/dateDesc)
     * @param {boolean} [hasSupplierComplaint] Отзывы с жалобой продавца(&#x60;true&#x60;) или без жалобы(&#x60;false&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1FeedbacksArchiveGet(take: number, skip: number, nmId?: number, order?: string, hasSupplierComplaint?: boolean, options?: any) {
        return DefaultApiFp(this.configuration).apiV1FeedbacksArchiveGet(take, skip, nmId, order, hasSupplierComplaint, options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет получить количество необработанных отзывов за сегодня, за всё время, и среднюю оценку всех отзывов.
     * @summary Необработанные отзывы
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1FeedbacksCountUnansweredGet(options?: any) {
        return DefaultApiFp(this.configuration).apiV1FeedbacksCountUnansweredGet(options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет получить список отзывов по заданным параметрам с пагинацией и сортировкой.
     * @summary Список отзывов
     * @param {boolean} isAnswered Обработанные отзывы (&#x60;true&#x60;) или необработанные отзывы(&#x60;false&#x60;)
     * @param {number} take Количество отзывов (max. 10 000)
     * @param {number} skip Количество отзывов для пропуска
     * @param {number} [nmId] Артикул WB
     * @param {string} [order] Сортировка отзывов по дате (dateAsc/dateDesc)
     * @param {boolean} [hasSupplierComplaint] Отзывы с жалобой продавца(&#x60;true&#x60;) или без жалобы(&#x60;false&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1FeedbacksGet(isAnswered: boolean, take: number, skip: number, nmId?: number, order?: string, hasSupplierComplaint?: boolean, options?: any) {
        return DefaultApiFp(this.configuration).apiV1FeedbacksGet(isAnswered, take, skip, nmId, order, hasSupplierComplaint, options)(this.fetch, this.basePath);
    }

    /**
     * <dl> <dt>В зависимости от тела запроса можно:</dt> <dd>Просмотреть отзыв.</dd> <dd>Ответить на отзыв.</dd> <dd>Создать жалобу на отзыв.</dd> </dl> 
     * @summary Работа с отзывом
     * @param {V1FeedbacksBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1FeedbacksPatch(body?: V1FeedbacksBody, options?: any) {
        return DefaultApiFp(this.configuration).apiV1FeedbacksPatch(body, options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет получить среднюю оценку товаров по родительской категории.
     * @summary Средняя оценка товаров по родительской категории
     * @param {number} subjectId id категории товара
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1FeedbacksProductsRatingGet(subjectId: number, options?: any) {
        return DefaultApiFp(this.configuration).apiV1FeedbacksProductsRatingGet(subjectId, options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет получить среднюю оценку товара по его артикулу WB.
     * @summary Средняя оценка товара по артикулу WB
     * @param {number} nmId Артикул WB
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1FeedbacksProductsRatingNmidGet(nmId: number, options?: any) {
        return DefaultApiFp(this.configuration).apiV1FeedbacksProductsRatingNmidGet(nmId, options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет получить список из двух товаров, с наибольшей и наименьшей средней оценкой, по родительской категории.
     * @summary Товары с наибольшей и наименьшей средней оценкой по родительской категории
     * @param {number} subjectId id категории товара
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1FeedbacksProductsRatingTopGet(subjectId: number, options?: any) {
        return DefaultApiFp(this.configuration).apiV1FeedbacksProductsRatingTopGet(subjectId, options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет получить XLSX файл с отзывами в кодировке BASE64. <br> За один запрос можно получить 5000 отзывов. <br> На данный момент всего можно получить 200 000 последних отзывов. 
     * @summary Получение отзывов в формате XLSX
     * @param {boolean} isAnswered Необработанный(&#x60;false&#x60;) или в архиве(&#x60;true&#x60;)
     * @param {boolean} [hasSupplierComplaint] Отзывы с жалобой продавца(&#x60;true&#x60;) или без жалобы(&#x60;false&#x60;)
     * @param {number} [skip] Параметр пагинации, указывает сколько отзывов пропустить &lt;span class&#x3D;\&quot;new\&quot;&gt;new&lt;/span&gt;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1FeedbacksReportGet(isAnswered: boolean, hasSupplierComplaint?: boolean, skip?: number, options?: any) {
        return DefaultApiFp(this.configuration).apiV1FeedbacksReportGet(isAnswered, hasSupplierComplaint, skip, options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет добавить рекомендации к товару. <br> `ВАЖНО!` Если запрос прошел успешно (код ответа 200), а рекомендации не добавилась, то Вам необходимо проверить корректность отправленных значений.  <br>На данный момент в методе не предусмотрена валидация значений параметров.  <br>Тщательно проверяйте данные перед отправкой. <br>Ограничение по запросам: 120 запросов в минуту. 
     * @summary Добавление рекомендаций
     * @param {Array<V1InsBody>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1InsPost(body: Array<V1InsBody>, options?: any) {
        return DefaultApiFp(this.configuration).apiV1InsPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет получить список рекомендаций по нескольким товарам
     * @summary Список рекомендаций
     * @param {number} nm Артикул WB (&#x60;nmId&#x60;), по которому необходимо получить список рекомендаций. &lt;br&gt; (max. 200) 
     * @param {number} [limit] Ограничение количества &#x60;nm&#x60; в ответе. (max. 999)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1ListGet(nm: number, limit?: number, options?: any) {
        return DefaultApiFp(this.configuration).apiV1ListGet(nm, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Метод отображает информацию о наличии у продавца непросмотренных отзывов и вопросов.
     * @summary Непросмотренные отзывы и вопросы
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1NewFeedbacksQuestionsGet(options?: any) {
        return DefaultApiFp(this.configuration).apiV1NewFeedbacksQuestionsGet(options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет получить список родительских категорий товаров, которые есть у продавца.
     * @summary Родительские категории товаров
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1ParentSubjectsGet(options?: any) {
        return DefaultApiFp(this.configuration).apiV1ParentSubjectsGet(options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет получить количество неотвеченных вопросов за сегодня и за всё время.
     * @summary Неотвеченные вопросы
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1QuestionsCountUnansweredGet(options?: any) {
        return DefaultApiFp(this.configuration).apiV1QuestionsCountUnansweredGet(options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет получить список вопросов по заданным параметрам с пагинацией и сортировкой.
     * @summary Список вопросов
     * @param {boolean} isAnswered Отвеченные вопросы (&#x60;true&#x60;) или неотвеченные вопросы(&#x60;false&#x60;) 
     * @param {number} take Количество вопросов (max. 10 000)
     * @param {number} skip Количество вопросов для пропуска
     * @param {number} [nmId] Артикул WB
     * @param {string} [order] Сортировка вопросов по дате (&#x60;dateAsc&#x60;/&#x60;dateDesc&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1QuestionsGet(isAnswered: boolean, take: number, skip: number, nmId?: number, order?: string, options?: any) {
        return DefaultApiFp(this.configuration).apiV1QuestionsGet(isAnswered, take, skip, nmId, order, options)(this.fetch, this.basePath);
    }

    /**
     * <dl> <dt>В зависимости от тела запроса можно:</dt> <dd>Просмотреть вопрос.</dd> <dd>Отклонить вопрос.</dd> <dd>Ответить на вопрос.</dd> </dl> 
     * @summary Работа с вопросами
     * @param {V1QuestionsBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1QuestionsPatch(body?: V1QuestionsBody, options?: any) {
        return DefaultApiFp(this.configuration).apiV1QuestionsPatch(body, options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет получить товары, про которые чаще всего спрашивают.
     * @summary Часто спрашиваемые товары
     * @param {number} size Количество запрашиваемых товаров (max. 100)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1QuestionsProductsRatingGet(size: number, options?: any) {
        return DefaultApiFp(this.configuration).apiV1QuestionsProductsRatingGet(size, options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет получить XLSX файл с вопросами в кодировке BASE64.
     * @summary Получение вопросов в формате XLSX
     * @param {boolean} isAnswered Обработанные вопросы (&#x60;true&#x60;) или необработанные вопросы(&#x60;false&#x60;) 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1QuestionsReportGet(isAnswered: boolean, options?: any) {
        return DefaultApiFp(this.configuration).apiV1QuestionsReportGet(isAnswered, options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет добавлять, удалять рекомендации.<br> Работает по принципу перезаписи, все что указано в recom, ставится взамен того, что было ранее.<br> Чтобы удалить рекомендации необходимо передать пустой массив recom.    
     * @summary Управление рекомендациями
     * @param {Array<V1SetBody>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1SetPost(body: Array<V1SetBody>, options?: any) {
        return DefaultApiFp(this.configuration).apiV1SetPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Поставки
     * @summary Поставки
     * @param {string} dateFrom Дата в формате RFC3339. Можно передать дату или дату со временем.  Время можно указывать с точностью до секунд или миллисекунд.  Литера &#x60;Z&#x60; в конце строки означает, что время передается в UTC-часовом поясе.  При ее отсутствии время считается в часовом поясе МСК (UTC+3). &lt;br&gt;Примеры: &lt;ul&gt; &lt;li&gt; &#x60;2019-06-20&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00Z&#x60; &lt;li&gt; &#x60;2019-06-20T23:59:59&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345Z&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345&#x60; &lt;li&gt; &#x60;2017-03-25T00:00:00&#x60; &lt;/ul&gt; 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1SupplierIncomesGet(dateFrom: string, options?: any) {
        return DefaultApiFp(this.configuration).apiV1SupplierIncomesGet(dateFrom, options)(this.fetch, this.basePath);
    }

    /**
     * Заказы. <br>  Важно: гарантируется хранение данных по заказам не более 90 дней от даты заказа. Данные обновляются раз в 30 минут.  Точное время обновления информации в сервисе можно увидеть в поле `lastChangeDate`. <br> Для идентификации товаров из одного заказа, а также продаж по ним, следует использовать  поле `gNumber` (строки с одинаковым значением этого поля относятся к одному заказу) и номер  уникальной позиции в заказе `odid` (`rid`).  
     * @summary Заказы
     * @param {string} dateFrom Дата в формате RFC3339. Можно передать дату или дату со временем.  Время можно указывать с точностью до секунд или миллисекунд.  Литера &#x60;Z&#x60; в конце строки означает, что время передается в UTC-часовом поясе.  При ее отсутствии время считается в часовом поясе МСК (UTC+3). &lt;br&gt;Примеры: &lt;ul&gt; &lt;li&gt; &#x60;2019-06-20&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00Z&#x60; &lt;li&gt; &#x60;2019-06-20T23:59:59&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345Z&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345&#x60; &lt;li&gt; &#x60;2017-03-25T00:00:00&#x60; &lt;/ul&gt; 
     * @param {number} [flag] Если параметр &#x60;flag&#x3D;0&#x60; (или не указан в строке запроса), при вызове API возвращаются данные,  у которых значение поля &#x60;lastChangeDate&#x60; (дата время обновления информации в сервисе) больше или равно переданному  значению параметра &#x60;dateFrom&#x60;.  При этом количество возвращенных строк данных варьируется в интервале от 0 до примерно 100 000. &lt;br&gt; Если параметр &#x60;flag&#x3D;1&#x60;, то будет выгружена информация обо всех заказах или продажах с датой,  равной переданному параметру &#x60;dateFrom&#x60; (в данном случае время в дате значения не имеет).  При этом количество возвращенных строк данных будет равно количеству всех заказов или продаж,  сделанных в указанную дату, переданную в параметре &#x60;dateFrom&#x60;. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1SupplierOrdersGet(dateFrom: string, flag?: number, options?: any) {
        return DefaultApiFp(this.configuration).apiV1SupplierOrdersGet(dateFrom, flag, options)(this.fetch, this.basePath);
    }

    /**
     * Отчет о продажах по реализации.  <br> В отчете доступны данные за последние 3 месяца. <br> В случае отсутствия данных за указанный период метод вернет `null`. <br> Технический перерыв в работе метода: каждый понедельник с 3:00 до 16:00. <br> <a href=\"./excel/stat-excel.html\">Инструкция: Сохранение статистики в Excel</a> 
     * @summary Отчет о продажах по реализации
     * @param {string} dateFrom Дата в формате RFC3339. Можно передать дату или дату со временем.  Время можно указывать с точностью до секунд или миллисекунд.  Литера &#x60;Z&#x60; в конце строки означает, что время передается в UTC-часовом поясе.  При ее отсутствии время считается в часовом поясе МСК (UTC+3). &lt;br&gt;Примеры: &lt;ul&gt; &lt;li&gt; &#x60;2019-06-20&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00Z&#x60; &lt;li&gt; &#x60;2019-06-20T23:59:59&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345Z&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345&#x60; &lt;li&gt; &#x60;2017-03-25T00:00:00&#x60; &lt;/ul&gt; 
     * @param {string} dateTo Конечная дата отчета
     * @param {number} [limit] Максимальное количество строк отчета, возвращаемых методом. Не может быть более 100000.
     * @param {number} [rrdid] Уникальный идентификатор строки отчета. Необходим для получения отчета частями.  &lt;br&gt; Загрузку отчета нужно начинать с &#x60;rrdid &#x3D; 0&#x60; и при последующих вызовах API передавать в запросе значение &#x60;rrd_id&#x60; из последней строки, полученной в результате предыдущего вызова.  &lt;br&gt; Таким образом для загрузки одного отчета может понадобиться вызывать API до тех пор, пока количество возвращаемых строк не станет равным нулю. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1SupplierReportDetailByPeriodGet(dateFrom: string, dateTo: string, limit?: number, rrdid?: number, options?: any) {
        return DefaultApiFp(this.configuration).apiV1SupplierReportDetailByPeriodGet(dateFrom, dateTo, limit, rrdid, options)(this.fetch, this.basePath);
    }

    /**
     * Продажи. <br> Важно: гарантируется хранение данных по заказам не более 90 дней от даты заказа. Данные обновляются раз в 30 минут. Точное время обновления информации в сервисе можно увидеть в поле `lastChangeDate`. <br> Для идентификации товаров из одного заказа, а также продаж по ним, следует использовать  поле `gNumber` (строки с одинаковым значением этого поля относятся к одному заказу) и номер  уникальной позиции в заказе `odid` (`rid`).  <br> Для расчета окончательной стоимости (суммы к оплате) следует пользоваться следующей формулой: <br> `priceWithDiscount = totalPrice * (1 - discountPercent/100)` 
     * @summary Продажи
     * @param {string} dateFrom Дата в формате RFC3339. Можно передать дату или дату со временем.  Время можно указывать с точностью до секунд или миллисекунд.  Литера &#x60;Z&#x60; в конце строки означает, что время передается в UTC-часовом поясе.  При ее отсутствии время считается в часовом поясе МСК (UTC+3). &lt;br&gt;Примеры: &lt;ul&gt; &lt;li&gt; &#x60;2019-06-20&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00Z&#x60; &lt;li&gt; &#x60;2019-06-20T23:59:59&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345Z&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345&#x60; &lt;li&gt; &#x60;2017-03-25T00:00:00&#x60; &lt;/ul&gt; 
     * @param {number} [flag] Если параметр &#x60;flag&#x3D;0&#x60; (или не указан в строке запроса), при вызове API возвращаются данные,  у которых значение поля &#x60;lastChangeDate&#x60; (дата время обновления информации в сервисе) больше или равно переданному  значению параметра &#x60;dateFrom&#x60;.  При этом количество возвращенных строк данных варьируется в интервале от 0 до примерно 100 000. &lt;br&gt; Если параметр &#x60;flag&#x3D;1&#x60;, то будет выгружена информация обо всех заказах или продажах с датой,  равной переданному параметру &#x60;dateFrom&#x60; (в данном случае время в дате значения не имеет).  При этом количество возвращенных строк данных будет равно количеству всех заказов или продаж,  сделанных в указанную дату, переданную в параметре &#x60;dateFrom&#x60;. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1SupplierSalesGet(dateFrom: string, flag?: number, options?: any) {
        return DefaultApiFp(this.configuration).apiV1SupplierSalesGet(dateFrom, flag, options)(this.fetch, this.basePath);
    }

    /**
     * Склад. Данные обновляются раз в сутки. Сервис статистики не хранит историю остатков товаров, поэтому получить данные об остатках товаров на прошедшую, не сегодняшнюю, дату - невозможно.
     * @summary Склад
     * @param {string} dateFrom Дата в формате RFC3339. Можно передать дату или дату со временем.  Время можно указывать с точностью до секунд или миллисекунд.  Литера &#x60;Z&#x60; в конце строки означает, что время передается в UTC-часовом поясе.  При ее отсутствии время считается в часовом поясе МСК (UTC+3). &lt;br&gt;Примеры: &lt;ul&gt; &lt;li&gt; &#x60;2019-06-20&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00Z&#x60; &lt;li&gt; &#x60;2019-06-20T23:59:59&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345Z&#x60; &lt;li&gt; &#x60;2019-06-20T00:00:00.12345&#x60; &lt;li&gt; &#x60;2017-03-25T00:00:00&#x60; &lt;/ul&gt; 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1SupplierStocksGet(dateFrom: string, options?: any) {
        return DefaultApiFp(this.configuration).apiV1SupplierStocksGet(dateFrom, options)(this.fetch, this.basePath);
    }

    /**
     * Получение информации по номенклатурам, их ценам, скидкам и промокодам. Если не указывать фильтры, вернётся весь товар.
     * @summary Получение информации о ценах.
     * @param {number} [quantity] &#x60;1&#x60; - товар с ненулевым остатком, &#x60;0&#x60; - товар с любым остатком
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public publicApiV1InfoGet(quantity?: number, options?: any) {
        return DefaultApiFp(this.configuration).publicApiV1InfoGet(quantity, options)(this.fetch, this.basePath);
    }

    /**
     * Загрузка цен. За раз можно загрузить не более 1000 номенклатур.
     * @summary Загрузка цен
     * @param {Array<V1PricesBody>} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public publicApiV1PricesPost(body?: Array<V1PricesBody>, options?: any) {
        return DefaultApiFp(this.configuration).publicApiV1PricesPost(body, options)(this.fetch, this.basePath);
    }

}
/**
 * Marketplace_Api - fetch parameter creator
 * @export
 */
export const Marketplace_ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cписок складов продавца.
         * @summary Cписок складов
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WarehousesGet(options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/warehouses`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию по сборочным заданиям без их актуального статуса.  Данные по сборочному заданию, возвращающиеся в данном методе, не меняются. Рекомендуется использовать для получения исторических данных. 
         * @summary Получить информацию по сборочным заданиям
         * @param {number} limit Параметр пагинации. Устанавливает предельное количество возвращаемых данных.
         * @param {number} next Параметр пагинации. Устанавливает значение, с которого надо получить следующий пакет данных. Для получения полного списка данных должен быть равен 0 в первом запросе. Для следующих запросов необходимо брать значения из одноимённого поля в ответе.
         * @param {number} [dateFrom] Дата начала периода в формате Unix timestamp. Необязательный параметр.
         * @param {number} [dateTo] Дата конца периода в формате Unix timestamp. Необязательный параметр.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3OrdersGet(limit: number, next: number, dateFrom?: number, dateTo?: number, options: any = {}): FetchArgs {
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling apiV3OrdersGet.');
            }
            // verify required parameter 'next' is not null or undefined
            if (next === null || next === undefined) {
                throw new RequiredError('next','Required parameter next was null or undefined when calling apiV3OrdersGet.');
            }
            const localVarPath = `/api/v3/orders`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['dateTo'] = dateTo;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список всех новых сборочных заданий у продавца на данный момент. 
         * @summary Получить список новых сборочных заданий
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3OrdersNewGet(options: any = {}): FetchArgs {
            const localVarPath = `/api/v3/orders/new`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Переводит сборочное задание в статус **cancel** (\"Отменено продавцом\").
         * @summary Отменить сборочное задание
         * @param {number} order Идентификатор сборочного задания
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3OrdersOrderCancelPatch(order: number, options: any = {}): FetchArgs {
            // verify required parameter 'order' is not null or undefined
            if (order === null || order === undefined) {
                throw new RequiredError('order','Required parameter order was null or undefined when calling apiV3OrdersOrderCancelPatch.');
            }
            const localVarPath = `/api/v3/orders/{order}/cancel`
                .replace(`{${"order"}}`, encodeURIComponent(String(order)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет закрепить за сборочным заданием КиЗ (маркировку Честного знака). У одного сборочного задания не может быть больше 24 маркировок. <br> <br> Параметры `sid`, `numerator`, `denominator` опциональны. Заполняются в зависимости от специфики товара. <br> <br> `Важно!` Получить загруженные КиЗ можно только в личном кабинете. Для этого необходимо: <ol>  <li>Зайти в раздел Маркетплейс - Сборочные задания</li>  <li>Пройти в любую из перечисленных вкладок (<code>На сборке</code>, <code>В доставке</code>, <code>Архив</code>)</li>  <li>Зайти в детализацию поставки</li>  <li>Нажать кнопку \"Выгрузить в Excel\"</li>  <li>В полученном файле открыть лист КИЗы</li> </ol> Получить загруженные КиЗ можно по всем заказам, кроме: <code>Новые</code>, <code>Отменено продавцом</code>.<br> <br> С правилами работы с КиЗ можно ознакомиться тут: https://честныйзнак.рф <br> <br> О реализации API-функционала для получения загруженных КиЗ будет сообщено в разделе Новости, на портале продавцов. 
         * @summary Закрепить за сборочным заданием КиЗ (маркировку Честного знака)
         * @param {number} order Идентификатор сборочного задания
         * @param {MetaSgtinBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3OrdersOrderMetaSgtinPost(order: number, body?: MetaSgtinBody, options: any = {}): FetchArgs {
            // verify required parameter 'order' is not null or undefined
            if (order === null || order === undefined) {
                throw new RequiredError('order','Required parameter order was null or undefined when calling apiV3OrdersOrderMetaSgtinPost.');
            }
            const localVarPath = `/api/v3/orders/{order}/meta/sgtin`
                .replace(`{${"order"}}`, encodeURIComponent(String(order)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MetaSgtinBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает статусы сборочных заданий по переданному списку идентификаторов сборочных заданий.  **supplierStatus** - статус сборочного задания, триггером изменения которого является сам продавец.<br> Возможны следующие значения данного поля: | Статус   | Описание            | Как перевести сборочное задание в данный статус | | -------  | ---------           | --------------------------------------| | new      | Новое сборочное задание |           | confirm  | На сборке            | При добавлении сборочного задания к поставке **PATCH** *_/api/v3/supplies/{supply}/orders/{order}* | complete | В доставке           | При переводе в доставку соответствующей поставки **PATCH** *_/api/v3/supplies/{supply}/deliver* | cancel   | Отменено продавцом   | **PATCH** *_/api/v3/orders/{order}/cancel*   **wbStatus** - статус сборочного задания в системе Wildberries.<br> Возможны следующие значения данного поля: - **waiting** - сборочное задание в работе - **sorted** - сборочное задание отсортировано - **sold** - сборочное задание получено покупателем - **canceled** - отмена сборочного задания - **canceled_by_client** - отмена сборочного задания покупателем - **defect** - отмена сборочного задания по причине брака - **ready_for_pickup** - сборочное задание прибыло на ПВЗ <span class=\"new\">new</span> 
         * @summary Получить статусы сборочных заданий
         * @param {OrdersStatusBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3OrdersStatusPost(body?: OrdersStatusBody, options: any = {}): FetchArgs {
            const localVarPath = `/api/v3/orders/status`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrdersStatusBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список этикеток по переданному массиву сборочных заданий. Можно запросить этикетку в формате svg, zplv (вертикальный), zplh (горизонтальный), png.  **Ограничения при работе с методом**: - Нельзя запросить больше 100 этикеток за раз (не более 100 идентификаторов сборочных заданий в запросе). - Метод возвращает этикетки только для сборочных заданий, находящихся на сборке (в статусе **confirm**). - Доступные размеры: <dd>580x400 пикселей, при параметрах width = 58, height = 40</dd> <dd>400x300 пикселей, при параметрах width = 40, height = 30</dd> 
         * @summary Получить этикетки для сборочных заданий
         * @param {string} type Тип этикетки
         * @param {number} width Ширина этикетки
         * @param {number} height Высота этикетки
         * @param {OrdersStickersBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3OrdersStickersPost(type: string, width: number, height: number, body?: OrdersStickersBody, options: any = {}): FetchArgs {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling apiV3OrdersStickersPost.');
            }
            // verify required parameter 'width' is not null or undefined
            if (width === null || width === undefined) {
                throw new RequiredError('width','Required parameter width was null or undefined when calling apiV3OrdersStickersPost.');
            }
            // verify required parameter 'height' is not null or undefined
            if (height === null || height === undefined) {
                throw new RequiredError('height','Required parameter height was null or undefined when calling apiV3OrdersStickersPost.');
            }
            const localVarPath = `/api/v3/orders/stickers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrdersStickersBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Удаляет остатки товаров. **Внимание! Действие необратимо**. Удаленный остаток будет необходимо загрузить повторно для возобновления продаж.
         * @summary Удалить остатки товаров
         * @param {StocksWarehouseBody2} body 
         * @param {number} warehouse Идентификатор склада продавца
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3StocksWarehouseDelete(body: StocksWarehouseBody2, warehouse: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV3StocksWarehouseDelete.');
            }
            // verify required parameter 'warehouse' is not null or undefined
            if (warehouse === null || warehouse === undefined) {
                throw new RequiredError('warehouse','Required parameter warehouse was null or undefined when calling apiV3StocksWarehouseDelete.');
            }
            const localVarPath = `/api/v3/stocks/{warehouse}`
                .replace(`{${"warehouse"}}`, encodeURIComponent(String(warehouse)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StocksWarehouseBody2" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает остатки товаров.
         * @summary Получить остатки товаров
         * @param {StocksWarehouseBody1} body 
         * @param {number} warehouse Идентификатор склада продавца
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3StocksWarehousePost(body: StocksWarehouseBody1, warehouse: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV3StocksWarehousePost.');
            }
            // verify required parameter 'warehouse' is not null or undefined
            if (warehouse === null || warehouse === undefined) {
                throw new RequiredError('warehouse','Required parameter warehouse was null or undefined when calling apiV3StocksWarehousePost.');
            }
            const localVarPath = `/api/v3/stocks/{warehouse}`
                .replace(`{${"warehouse"}}`, encodeURIComponent(String(warehouse)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StocksWarehouseBody1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Обновляет остатки товаров.
         * @summary Обновить остатки товаров
         * @param {number} warehouse Идентификатор склада продавца
         * @param {StocksWarehouseBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3StocksWarehousePut(warehouse: number, body?: StocksWarehouseBody, options: any = {}): FetchArgs {
            // verify required parameter 'warehouse' is not null or undefined
            if (warehouse === null || warehouse === undefined) {
                throw new RequiredError('warehouse','Required parameter warehouse was null or undefined when calling apiV3StocksWarehousePut.');
            }
            const localVarPath = `/api/v3/stocks/{warehouse}`
                .replace(`{${"warehouse"}}`, encodeURIComponent(String(warehouse)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StocksWarehouseBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает список поставок
         * @summary Получить список поставок
         * @param {number} limit Параметр пагинации. Устанавливает предельное количество возвращаемых данных.
         * @param {number} next Параметр пагинации. Устанавливает значение, с которого надо получить следующий пакет данных. Для получения полного списка данных должен быть равен 0 в первом запросе. Для следующих запросов необходимо брать значения из одноимённого поля в ответе.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SuppliesGet(limit: number, next: number, options: any = {}): FetchArgs {
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling apiV3SuppliesGet.');
            }
            // verify required parameter 'next' is not null or undefined
            if (next === null || next === undefined) {
                throw new RequiredError('next','Required parameter next was null or undefined when calling apiV3SuppliesGet.');
            }
            const localVarPath = `/api/v3/supplies`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (next !== undefined) {
                localVarQueryParameter['next'] = next;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Ограничения работы с поставками**:  - Только для сборочных заданий по схеме \"Везу на склад WB\" - При добавлении в поставку все передаваемые сборочные задания в статусе **new** (\"Новое\") будут автоматически переведены в статус **confirm** (\"На сборке\"). - Обратите внимание, что если вы переведёте сборочное задание в статус **cancel** (\"Отмена продавцом\"), то сборочное задание автоматически удалится из поставки, если было прикреплено к ней. - Поставку можно собрать только из одного типа сборочных заданий: сКГТ (isLargeCargo = true) или обычный (isLargeCargo = false). Новая поставка не обладает сКГТ-признаком. При добавлении первого заказа в поставку она приобретает сКГТ-признак добавляемого товара в заказе. 
         * @summary Создать новую поставку
         * @param {V3SuppliesBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SuppliesPost(body: V3SuppliesBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV3SuppliesPost.');
            }
            const localVarPath = `/api/v3/supplies`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V3SuppliesBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает QR в svg, zplv (вертикальный), zplh (горизонтальный), png. <br> Можно получить, только если поставка передана в доставку. <dt>Доступные размеры:</dt> <dd>580x400 пикселей 
         * @summary Получить QR поставки
         * @param {string} supply Идентификатор поставки
         * @param {string} type Тип этикетки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SuppliesSupplyBarcodeGet(supply: string, type: string, options: any = {}): FetchArgs {
            // verify required parameter 'supply' is not null or undefined
            if (supply === null || supply === undefined) {
                throw new RequiredError('supply','Required parameter supply was null or undefined when calling apiV3SuppliesSupplyBarcodeGet.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling apiV3SuppliesSupplyBarcodeGet.');
            }
            const localVarPath = `/api/v3/supplies/{supply}/barcode`
                .replace(`{${"supply"}}`, encodeURIComponent(String(supply)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Удаляет поставку, если она активна и за ней не закреплено ни одно сборочное задание.
         * @summary Удалить поставку
         * @param {string} supply Идентификатор поставки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SuppliesSupplyDelete(supply: string, options: any = {}): FetchArgs {
            // verify required parameter 'supply' is not null or undefined
            if (supply === null || supply === undefined) {
                throw new RequiredError('supply','Required parameter supply was null or undefined when calling apiV3SuppliesSupplyDelete.');
            }
            const localVarPath = `/api/v3/supplies/{supply}`
                .replace(`{${"supply"}}`, encodeURIComponent(String(supply)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Закрывает поставку и переводит все сборочные задания в ней в статус **complete** (\"В доставке\"). После закрытия поставки новые сборочные задания к ней добавить будет невозможно. Передать поставку в доставку можно только при наличии в ней хотя бы одного сборочного задания. 
         * @summary Передать поставку в доставку
         * @param {string} supply Идентификатор поставки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SuppliesSupplyDeliverPatch(supply: string, options: any = {}): FetchArgs {
            // verify required parameter 'supply' is not null or undefined
            if (supply === null || supply === undefined) {
                throw new RequiredError('supply','Required parameter supply was null or undefined when calling apiV3SuppliesSupplyDeliverPatch.');
            }
            const localVarPath = `/api/v3/supplies/{supply}/deliver`
                .replace(`{${"supply"}}`, encodeURIComponent(String(supply)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает информацию о поставке
         * @summary Получить информацию о поставке
         * @param {string} supply Идентификатор поставки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SuppliesSupplyGet(supply: string, options: any = {}): FetchArgs {
            // verify required parameter 'supply' is not null or undefined
            if (supply === null || supply === undefined) {
                throw new RequiredError('supply','Required parameter supply was null or undefined when calling apiV3SuppliesSupplyGet.');
            }
            const localVarPath = `/api/v3/supplies/{supply}`
                .replace(`{${"supply"}}`, encodeURIComponent(String(supply)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает сборочные задания, закреплённые за поставкой.
         * @summary Получить сборочные задания в поставке
         * @param {string} supply Идентификатор поставки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SuppliesSupplyOrdersGet(supply: string, options: any = {}): FetchArgs {
            // verify required parameter 'supply' is not null or undefined
            if (supply === null || supply === undefined) {
                throw new RequiredError('supply','Required parameter supply was null or undefined when calling apiV3SuppliesSupplyOrdersGet.');
            }
            const localVarPath = `/api/v3/supplies/{supply}/orders`
                .replace(`{${"supply"}}`, encodeURIComponent(String(supply)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Добавляет к поставке сборочное задание и переводит его в статус **confirm** (\"На сборке\").  Также может перемещать сборочное задание между активными поставками, либо из закрытой в активную при условии, что сборочное задание требует повторной отгрузки. Добавить в поставку возможно только задания с соответствующим сКГТ-признаком (isLargeCargo), либо если поставке ещё не присвоен сКГТ-признак (isLargeCargo = null). 
         * @summary Добавить к поставке сборочное задание
         * @param {string} supply Идентификатор поставки
         * @param {number} order Идентификатор сборочного задания
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SuppliesSupplyOrdersOrderPatch(supply: string, order: number, options: any = {}): FetchArgs {
            // verify required parameter 'supply' is not null or undefined
            if (supply === null || supply === undefined) {
                throw new RequiredError('supply','Required parameter supply was null or undefined when calling apiV3SuppliesSupplyOrdersOrderPatch.');
            }
            // verify required parameter 'order' is not null or undefined
            if (order === null || order === undefined) {
                throw new RequiredError('order','Required parameter order was null or undefined when calling apiV3SuppliesSupplyOrdersOrderPatch.');
            }
            const localVarPath = `/api/v3/supplies/{supply}/orders/{order}`
                .replace(`{${"supply"}}`, encodeURIComponent(String(supply)))
                .replace(`{${"order"}}`, encodeURIComponent(String(order)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Marketplace_Api - functional programming interface
 * @export
 */
export const Marketplace_ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Cписок складов продавца.
         * @summary Cписок складов
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WarehousesGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse20023>> {
            const localVarFetchArgs = Marketplace_ApiFetchParamCreator(configuration).apiV2WarehousesGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Возвращает информацию по сборочным заданиям без их актуального статуса.  Данные по сборочному заданию, возвращающиеся в данном методе, не меняются. Рекомендуется использовать для получения исторических данных. 
         * @summary Получить информацию по сборочным заданиям
         * @param {number} limit Параметр пагинации. Устанавливает предельное количество возвращаемых данных.
         * @param {number} next Параметр пагинации. Устанавливает значение, с которого надо получить следующий пакет данных. Для получения полного списка данных должен быть равен 0 в первом запросе. Для следующих запросов необходимо брать значения из одноимённого поля в ответе.
         * @param {number} [dateFrom] Дата начала периода в формате Unix timestamp. Необязательный параметр.
         * @param {number} [dateTo] Дата конца периода в формате Unix timestamp. Необязательный параметр.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3OrdersGet(limit: number, next: number, dateFrom?: number, dateTo?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20029> {
            const localVarFetchArgs = Marketplace_ApiFetchParamCreator(configuration).apiV3OrdersGet(limit, next, dateFrom, dateTo, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Возвращает список всех новых сборочных заданий у продавца на данный момент. 
         * @summary Получить список новых сборочных заданий
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3OrdersNewGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20030> {
            const localVarFetchArgs = Marketplace_ApiFetchParamCreator(configuration).apiV3OrdersNewGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Переводит сборочное задание в статус **cancel** (\"Отменено продавцом\").
         * @summary Отменить сборочное задание
         * @param {number} order Идентификатор сборочного задания
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3OrdersOrderCancelPatch(order: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = Marketplace_ApiFetchParamCreator(configuration).apiV3OrdersOrderCancelPatch(order, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет закрепить за сборочным заданием КиЗ (маркировку Честного знака). У одного сборочного задания не может быть больше 24 маркировок. <br> <br> Параметры `sid`, `numerator`, `denominator` опциональны. Заполняются в зависимости от специфики товара. <br> <br> `Важно!` Получить загруженные КиЗ можно только в личном кабинете. Для этого необходимо: <ol>  <li>Зайти в раздел Маркетплейс - Сборочные задания</li>  <li>Пройти в любую из перечисленных вкладок (<code>На сборке</code>, <code>В доставке</code>, <code>Архив</code>)</li>  <li>Зайти в детализацию поставки</li>  <li>Нажать кнопку \"Выгрузить в Excel\"</li>  <li>В полученном файле открыть лист КИЗы</li> </ol> Получить загруженные КиЗ можно по всем заказам, кроме: <code>Новые</code>, <code>Отменено продавцом</code>.<br> <br> С правилами работы с КиЗ можно ознакомиться тут: https://честныйзнак.рф <br> <br> О реализации API-функционала для получения загруженных КиЗ будет сообщено в разделе Новости, на портале продавцов. 
         * @summary Закрепить за сборочным заданием КиЗ (маркировку Честного знака)
         * @param {number} order Идентификатор сборочного задания
         * @param {MetaSgtinBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3OrdersOrderMetaSgtinPost(order: number, body?: MetaSgtinBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = Marketplace_ApiFetchParamCreator(configuration).apiV3OrdersOrderMetaSgtinPost(order, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Возвращает статусы сборочных заданий по переданному списку идентификаторов сборочных заданий.  **supplierStatus** - статус сборочного задания, триггером изменения которого является сам продавец.<br> Возможны следующие значения данного поля: | Статус   | Описание            | Как перевести сборочное задание в данный статус | | -------  | ---------           | --------------------------------------| | new      | Новое сборочное задание |           | confirm  | На сборке            | При добавлении сборочного задания к поставке **PATCH** *_/api/v3/supplies/{supply}/orders/{order}* | complete | В доставке           | При переводе в доставку соответствующей поставки **PATCH** *_/api/v3/supplies/{supply}/deliver* | cancel   | Отменено продавцом   | **PATCH** *_/api/v3/orders/{order}/cancel*   **wbStatus** - статус сборочного задания в системе Wildberries.<br> Возможны следующие значения данного поля: - **waiting** - сборочное задание в работе - **sorted** - сборочное задание отсортировано - **sold** - сборочное задание получено покупателем - **canceled** - отмена сборочного задания - **canceled_by_client** - отмена сборочного задания покупателем - **defect** - отмена сборочного задания по причине брака - **ready_for_pickup** - сборочное задание прибыло на ПВЗ <span class=\"new\">new</span> 
         * @summary Получить статусы сборочных заданий
         * @param {OrdersStatusBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3OrdersStatusPost(body?: OrdersStatusBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20028> {
            const localVarFetchArgs = Marketplace_ApiFetchParamCreator(configuration).apiV3OrdersStatusPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Возвращает список этикеток по переданному массиву сборочных заданий. Можно запросить этикетку в формате svg, zplv (вертикальный), zplh (горизонтальный), png.  **Ограничения при работе с методом**: - Нельзя запросить больше 100 этикеток за раз (не более 100 идентификаторов сборочных заданий в запросе). - Метод возвращает этикетки только для сборочных заданий, находящихся на сборке (в статусе **confirm**). - Доступные размеры: <dd>580x400 пикселей, при параметрах width = 58, height = 40</dd> <dd>400x300 пикселей, при параметрах width = 40, height = 30</dd> 
         * @summary Получить этикетки для сборочных заданий
         * @param {string} type Тип этикетки
         * @param {number} width Ширина этикетки
         * @param {number} height Высота этикетки
         * @param {OrdersStickersBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3OrdersStickersPost(type: string, width: number, height: number, body?: OrdersStickersBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20031> {
            const localVarFetchArgs = Marketplace_ApiFetchParamCreator(configuration).apiV3OrdersStickersPost(type, width, height, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Удаляет остатки товаров. **Внимание! Действие необратимо**. Удаленный остаток будет необходимо загрузить повторно для возобновления продаж.
         * @summary Удалить остатки товаров
         * @param {StocksWarehouseBody2} body 
         * @param {number} warehouse Идентификатор склада продавца
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3StocksWarehouseDelete(body: StocksWarehouseBody2, warehouse: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = Marketplace_ApiFetchParamCreator(configuration).apiV3StocksWarehouseDelete(body, warehouse, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Возвращает остатки товаров.
         * @summary Получить остатки товаров
         * @param {StocksWarehouseBody1} body 
         * @param {number} warehouse Идентификатор склада продавца
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3StocksWarehousePost(body: StocksWarehouseBody1, warehouse: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20024> {
            const localVarFetchArgs = Marketplace_ApiFetchParamCreator(configuration).apiV3StocksWarehousePost(body, warehouse, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Обновляет остатки товаров.
         * @summary Обновить остатки товаров
         * @param {number} warehouse Идентификатор склада продавца
         * @param {StocksWarehouseBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3StocksWarehousePut(warehouse: number, body?: StocksWarehouseBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = Marketplace_ApiFetchParamCreator(configuration).apiV3StocksWarehousePut(warehouse, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Возвращает список поставок
         * @summary Получить список поставок
         * @param {number} limit Параметр пагинации. Устанавливает предельное количество возвращаемых данных.
         * @param {number} next Параметр пагинации. Устанавливает значение, с которого надо получить следующий пакет данных. Для получения полного списка данных должен быть равен 0 в первом запросе. Для следующих запросов необходимо брать значения из одноимённого поля в ответе.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SuppliesGet(limit: number, next: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20025> {
            const localVarFetchArgs = Marketplace_ApiFetchParamCreator(configuration).apiV3SuppliesGet(limit, next, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Ограничения работы с поставками**:  - Только для сборочных заданий по схеме \"Везу на склад WB\" - При добавлении в поставку все передаваемые сборочные задания в статусе **new** (\"Новое\") будут автоматически переведены в статус **confirm** (\"На сборке\"). - Обратите внимание, что если вы переведёте сборочное задание в статус **cancel** (\"Отмена продавцом\"), то сборочное задание автоматически удалится из поставки, если было прикреплено к ней. - Поставку можно собрать только из одного типа сборочных заданий: сКГТ (isLargeCargo = true) или обычный (isLargeCargo = false). Новая поставка не обладает сКГТ-признаком. При добавлении первого заказа в поставку она приобретает сКГТ-признак добавляемого товара в заказе. 
         * @summary Создать новую поставку
         * @param {V3SuppliesBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SuppliesPost(body: V3SuppliesBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse201> {
            const localVarFetchArgs = Marketplace_ApiFetchParamCreator(configuration).apiV3SuppliesPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Возвращает QR в svg, zplv (вертикальный), zplh (горизонтальный), png. <br> Можно получить, только если поставка передана в доставку. <dt>Доступные размеры:</dt> <dd>580x400 пикселей 
         * @summary Получить QR поставки
         * @param {string} supply Идентификатор поставки
         * @param {string} type Тип этикетки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SuppliesSupplyBarcodeGet(supply: string, type: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20027> {
            const localVarFetchArgs = Marketplace_ApiFetchParamCreator(configuration).apiV3SuppliesSupplyBarcodeGet(supply, type, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Удаляет поставку, если она активна и за ней не закреплено ни одно сборочное задание.
         * @summary Удалить поставку
         * @param {string} supply Идентификатор поставки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SuppliesSupplyDelete(supply: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = Marketplace_ApiFetchParamCreator(configuration).apiV3SuppliesSupplyDelete(supply, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Закрывает поставку и переводит все сборочные задания в ней в статус **complete** (\"В доставке\"). После закрытия поставки новые сборочные задания к ней добавить будет невозможно. Передать поставку в доставку можно только при наличии в ней хотя бы одного сборочного задания. 
         * @summary Передать поставку в доставку
         * @param {string} supply Идентификатор поставки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SuppliesSupplyDeliverPatch(supply: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = Marketplace_ApiFetchParamCreator(configuration).apiV3SuppliesSupplyDeliverPatch(supply, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Возвращает информацию о поставке
         * @summary Получить информацию о поставке
         * @param {string} supply Идентификатор поставки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SuppliesSupplyGet(supply: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Supply> {
            const localVarFetchArgs = Marketplace_ApiFetchParamCreator(configuration).apiV3SuppliesSupplyGet(supply, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Возвращает сборочные задания, закреплённые за поставкой.
         * @summary Получить сборочные задания в поставке
         * @param {string} supply Идентификатор поставки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SuppliesSupplyOrdersGet(supply: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20026> {
            const localVarFetchArgs = Marketplace_ApiFetchParamCreator(configuration).apiV3SuppliesSupplyOrdersGet(supply, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Добавляет к поставке сборочное задание и переводит его в статус **confirm** (\"На сборке\").  Также может перемещать сборочное задание между активными поставками, либо из закрытой в активную при условии, что сборочное задание требует повторной отгрузки. Добавить в поставку возможно только задания с соответствующим сКГТ-признаком (isLargeCargo), либо если поставке ещё не присвоен сКГТ-признак (isLargeCargo = null). 
         * @summary Добавить к поставке сборочное задание
         * @param {string} supply Идентификатор поставки
         * @param {number} order Идентификатор сборочного задания
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SuppliesSupplyOrdersOrderPatch(supply: string, order: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = Marketplace_ApiFetchParamCreator(configuration).apiV3SuppliesSupplyOrdersOrderPatch(supply, order, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * Marketplace_Api - factory interface
 * @export
 */
export const Marketplace_ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Cписок складов продавца.
         * @summary Cписок складов
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2WarehousesGet(options?: any) {
            return Marketplace_ApiFp(configuration).apiV2WarehousesGet(options)(fetch, basePath);
        },
        /**
         * Возвращает информацию по сборочным заданиям без их актуального статуса.  Данные по сборочному заданию, возвращающиеся в данном методе, не меняются. Рекомендуется использовать для получения исторических данных. 
         * @summary Получить информацию по сборочным заданиям
         * @param {number} limit Параметр пагинации. Устанавливает предельное количество возвращаемых данных.
         * @param {number} next Параметр пагинации. Устанавливает значение, с которого надо получить следующий пакет данных. Для получения полного списка данных должен быть равен 0 в первом запросе. Для следующих запросов необходимо брать значения из одноимённого поля в ответе.
         * @param {number} [dateFrom] Дата начала периода в формате Unix timestamp. Необязательный параметр.
         * @param {number} [dateTo] Дата конца периода в формате Unix timestamp. Необязательный параметр.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3OrdersGet(limit: number, next: number, dateFrom?: number, dateTo?: number, options?: any) {
            return Marketplace_ApiFp(configuration).apiV3OrdersGet(limit, next, dateFrom, dateTo, options)(fetch, basePath);
        },
        /**
         * Возвращает список всех новых сборочных заданий у продавца на данный момент. 
         * @summary Получить список новых сборочных заданий
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3OrdersNewGet(options?: any) {
            return Marketplace_ApiFp(configuration).apiV3OrdersNewGet(options)(fetch, basePath);
        },
        /**
         * Переводит сборочное задание в статус **cancel** (\"Отменено продавцом\").
         * @summary Отменить сборочное задание
         * @param {number} order Идентификатор сборочного задания
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3OrdersOrderCancelPatch(order: number, options?: any) {
            return Marketplace_ApiFp(configuration).apiV3OrdersOrderCancelPatch(order, options)(fetch, basePath);
        },
        /**
         * Метод позволяет закрепить за сборочным заданием КиЗ (маркировку Честного знака). У одного сборочного задания не может быть больше 24 маркировок. <br> <br> Параметры `sid`, `numerator`, `denominator` опциональны. Заполняются в зависимости от специфики товара. <br> <br> `Важно!` Получить загруженные КиЗ можно только в личном кабинете. Для этого необходимо: <ol>  <li>Зайти в раздел Маркетплейс - Сборочные задания</li>  <li>Пройти в любую из перечисленных вкладок (<code>На сборке</code>, <code>В доставке</code>, <code>Архив</code>)</li>  <li>Зайти в детализацию поставки</li>  <li>Нажать кнопку \"Выгрузить в Excel\"</li>  <li>В полученном файле открыть лист КИЗы</li> </ol> Получить загруженные КиЗ можно по всем заказам, кроме: <code>Новые</code>, <code>Отменено продавцом</code>.<br> <br> С правилами работы с КиЗ можно ознакомиться тут: https://честныйзнак.рф <br> <br> О реализации API-функционала для получения загруженных КиЗ будет сообщено в разделе Новости, на портале продавцов. 
         * @summary Закрепить за сборочным заданием КиЗ (маркировку Честного знака)
         * @param {number} order Идентификатор сборочного задания
         * @param {MetaSgtinBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3OrdersOrderMetaSgtinPost(order: number, body?: MetaSgtinBody, options?: any) {
            return Marketplace_ApiFp(configuration).apiV3OrdersOrderMetaSgtinPost(order, body, options)(fetch, basePath);
        },
        /**
         * Возвращает статусы сборочных заданий по переданному списку идентификаторов сборочных заданий.  **supplierStatus** - статус сборочного задания, триггером изменения которого является сам продавец.<br> Возможны следующие значения данного поля: | Статус   | Описание            | Как перевести сборочное задание в данный статус | | -------  | ---------           | --------------------------------------| | new      | Новое сборочное задание |           | confirm  | На сборке            | При добавлении сборочного задания к поставке **PATCH** *_/api/v3/supplies/{supply}/orders/{order}* | complete | В доставке           | При переводе в доставку соответствующей поставки **PATCH** *_/api/v3/supplies/{supply}/deliver* | cancel   | Отменено продавцом   | **PATCH** *_/api/v3/orders/{order}/cancel*   **wbStatus** - статус сборочного задания в системе Wildberries.<br> Возможны следующие значения данного поля: - **waiting** - сборочное задание в работе - **sorted** - сборочное задание отсортировано - **sold** - сборочное задание получено покупателем - **canceled** - отмена сборочного задания - **canceled_by_client** - отмена сборочного задания покупателем - **defect** - отмена сборочного задания по причине брака - **ready_for_pickup** - сборочное задание прибыло на ПВЗ <span class=\"new\">new</span> 
         * @summary Получить статусы сборочных заданий
         * @param {OrdersStatusBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3OrdersStatusPost(body?: OrdersStatusBody, options?: any) {
            return Marketplace_ApiFp(configuration).apiV3OrdersStatusPost(body, options)(fetch, basePath);
        },
        /**
         * Возвращает список этикеток по переданному массиву сборочных заданий. Можно запросить этикетку в формате svg, zplv (вертикальный), zplh (горизонтальный), png.  **Ограничения при работе с методом**: - Нельзя запросить больше 100 этикеток за раз (не более 100 идентификаторов сборочных заданий в запросе). - Метод возвращает этикетки только для сборочных заданий, находящихся на сборке (в статусе **confirm**). - Доступные размеры: <dd>580x400 пикселей, при параметрах width = 58, height = 40</dd> <dd>400x300 пикселей, при параметрах width = 40, height = 30</dd> 
         * @summary Получить этикетки для сборочных заданий
         * @param {string} type Тип этикетки
         * @param {number} width Ширина этикетки
         * @param {number} height Высота этикетки
         * @param {OrdersStickersBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3OrdersStickersPost(type: string, width: number, height: number, body?: OrdersStickersBody, options?: any) {
            return Marketplace_ApiFp(configuration).apiV3OrdersStickersPost(type, width, height, body, options)(fetch, basePath);
        },
        /**
         * Удаляет остатки товаров. **Внимание! Действие необратимо**. Удаленный остаток будет необходимо загрузить повторно для возобновления продаж.
         * @summary Удалить остатки товаров
         * @param {StocksWarehouseBody2} body 
         * @param {number} warehouse Идентификатор склада продавца
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3StocksWarehouseDelete(body: StocksWarehouseBody2, warehouse: number, options?: any) {
            return Marketplace_ApiFp(configuration).apiV3StocksWarehouseDelete(body, warehouse, options)(fetch, basePath);
        },
        /**
         * Возвращает остатки товаров.
         * @summary Получить остатки товаров
         * @param {StocksWarehouseBody1} body 
         * @param {number} warehouse Идентификатор склада продавца
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3StocksWarehousePost(body: StocksWarehouseBody1, warehouse: number, options?: any) {
            return Marketplace_ApiFp(configuration).apiV3StocksWarehousePost(body, warehouse, options)(fetch, basePath);
        },
        /**
         * Обновляет остатки товаров.
         * @summary Обновить остатки товаров
         * @param {number} warehouse Идентификатор склада продавца
         * @param {StocksWarehouseBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3StocksWarehousePut(warehouse: number, body?: StocksWarehouseBody, options?: any) {
            return Marketplace_ApiFp(configuration).apiV3StocksWarehousePut(warehouse, body, options)(fetch, basePath);
        },
        /**
         * Возвращает список поставок
         * @summary Получить список поставок
         * @param {number} limit Параметр пагинации. Устанавливает предельное количество возвращаемых данных.
         * @param {number} next Параметр пагинации. Устанавливает значение, с которого надо получить следующий пакет данных. Для получения полного списка данных должен быть равен 0 в первом запросе. Для следующих запросов необходимо брать значения из одноимённого поля в ответе.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SuppliesGet(limit: number, next: number, options?: any) {
            return Marketplace_ApiFp(configuration).apiV3SuppliesGet(limit, next, options)(fetch, basePath);
        },
        /**
         * **Ограничения работы с поставками**:  - Только для сборочных заданий по схеме \"Везу на склад WB\" - При добавлении в поставку все передаваемые сборочные задания в статусе **new** (\"Новое\") будут автоматически переведены в статус **confirm** (\"На сборке\"). - Обратите внимание, что если вы переведёте сборочное задание в статус **cancel** (\"Отмена продавцом\"), то сборочное задание автоматически удалится из поставки, если было прикреплено к ней. - Поставку можно собрать только из одного типа сборочных заданий: сКГТ (isLargeCargo = true) или обычный (isLargeCargo = false). Новая поставка не обладает сКГТ-признаком. При добавлении первого заказа в поставку она приобретает сКГТ-признак добавляемого товара в заказе. 
         * @summary Создать новую поставку
         * @param {V3SuppliesBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SuppliesPost(body: V3SuppliesBody, options?: any) {
            return Marketplace_ApiFp(configuration).apiV3SuppliesPost(body, options)(fetch, basePath);
        },
        /**
         * Возвращает QR в svg, zplv (вертикальный), zplh (горизонтальный), png. <br> Можно получить, только если поставка передана в доставку. <dt>Доступные размеры:</dt> <dd>580x400 пикселей 
         * @summary Получить QR поставки
         * @param {string} supply Идентификатор поставки
         * @param {string} type Тип этикетки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SuppliesSupplyBarcodeGet(supply: string, type: string, options?: any) {
            return Marketplace_ApiFp(configuration).apiV3SuppliesSupplyBarcodeGet(supply, type, options)(fetch, basePath);
        },
        /**
         * Удаляет поставку, если она активна и за ней не закреплено ни одно сборочное задание.
         * @summary Удалить поставку
         * @param {string} supply Идентификатор поставки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SuppliesSupplyDelete(supply: string, options?: any) {
            return Marketplace_ApiFp(configuration).apiV3SuppliesSupplyDelete(supply, options)(fetch, basePath);
        },
        /**
         * Закрывает поставку и переводит все сборочные задания в ней в статус **complete** (\"В доставке\"). После закрытия поставки новые сборочные задания к ней добавить будет невозможно. Передать поставку в доставку можно только при наличии в ней хотя бы одного сборочного задания. 
         * @summary Передать поставку в доставку
         * @param {string} supply Идентификатор поставки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SuppliesSupplyDeliverPatch(supply: string, options?: any) {
            return Marketplace_ApiFp(configuration).apiV3SuppliesSupplyDeliverPatch(supply, options)(fetch, basePath);
        },
        /**
         * Возвращает информацию о поставке
         * @summary Получить информацию о поставке
         * @param {string} supply Идентификатор поставки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SuppliesSupplyGet(supply: string, options?: any) {
            return Marketplace_ApiFp(configuration).apiV3SuppliesSupplyGet(supply, options)(fetch, basePath);
        },
        /**
         * Возвращает сборочные задания, закреплённые за поставкой.
         * @summary Получить сборочные задания в поставке
         * @param {string} supply Идентификатор поставки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SuppliesSupplyOrdersGet(supply: string, options?: any) {
            return Marketplace_ApiFp(configuration).apiV3SuppliesSupplyOrdersGet(supply, options)(fetch, basePath);
        },
        /**
         * Добавляет к поставке сборочное задание и переводит его в статус **confirm** (\"На сборке\").  Также может перемещать сборочное задание между активными поставками, либо из закрытой в активную при условии, что сборочное задание требует повторной отгрузки. Добавить в поставку возможно только задания с соответствующим сКГТ-признаком (isLargeCargo), либо если поставке ещё не присвоен сКГТ-признак (isLargeCargo = null). 
         * @summary Добавить к поставке сборочное задание
         * @param {string} supply Идентификатор поставки
         * @param {number} order Идентификатор сборочного задания
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV3SuppliesSupplyOrdersOrderPatch(supply: string, order: number, options?: any) {
            return Marketplace_ApiFp(configuration).apiV3SuppliesSupplyOrdersOrderPatch(supply, order, options)(fetch, basePath);
        },
    };
};

/**
 * Marketplace_Api - object-oriented interface
 * @export
 * @class Marketplace_Api
 * @extends {BaseAPI}
 */
export class Marketplace_Api extends BaseAPI {
    /**
     * Cписок складов продавца.
     * @summary Cписок складов
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Marketplace_Api
     */
    public apiV2WarehousesGet(options?: any) {
        return Marketplace_ApiFp(this.configuration).apiV2WarehousesGet(options)(this.fetch, this.basePath);
    }

    /**
     * Возвращает информацию по сборочным заданиям без их актуального статуса.  Данные по сборочному заданию, возвращающиеся в данном методе, не меняются. Рекомендуется использовать для получения исторических данных. 
     * @summary Получить информацию по сборочным заданиям
     * @param {number} limit Параметр пагинации. Устанавливает предельное количество возвращаемых данных.
     * @param {number} next Параметр пагинации. Устанавливает значение, с которого надо получить следующий пакет данных. Для получения полного списка данных должен быть равен 0 в первом запросе. Для следующих запросов необходимо брать значения из одноимённого поля в ответе.
     * @param {number} [dateFrom] Дата начала периода в формате Unix timestamp. Необязательный параметр.
     * @param {number} [dateTo] Дата конца периода в формате Unix timestamp. Необязательный параметр.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Marketplace_Api
     */
    public apiV3OrdersGet(limit: number, next: number, dateFrom?: number, dateTo?: number, options?: any) {
        return Marketplace_ApiFp(this.configuration).apiV3OrdersGet(limit, next, dateFrom, dateTo, options)(this.fetch, this.basePath);
    }

    /**
     * Возвращает список всех новых сборочных заданий у продавца на данный момент. 
     * @summary Получить список новых сборочных заданий
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Marketplace_Api
     */
    public apiV3OrdersNewGet(options?: any) {
        return Marketplace_ApiFp(this.configuration).apiV3OrdersNewGet(options)(this.fetch, this.basePath);
    }

    /**
     * Переводит сборочное задание в статус **cancel** (\"Отменено продавцом\").
     * @summary Отменить сборочное задание
     * @param {number} order Идентификатор сборочного задания
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Marketplace_Api
     */
    public apiV3OrdersOrderCancelPatch(order: number, options?: any) {
        return Marketplace_ApiFp(this.configuration).apiV3OrdersOrderCancelPatch(order, options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет закрепить за сборочным заданием КиЗ (маркировку Честного знака). У одного сборочного задания не может быть больше 24 маркировок. <br> <br> Параметры `sid`, `numerator`, `denominator` опциональны. Заполняются в зависимости от специфики товара. <br> <br> `Важно!` Получить загруженные КиЗ можно только в личном кабинете. Для этого необходимо: <ol>  <li>Зайти в раздел Маркетплейс - Сборочные задания</li>  <li>Пройти в любую из перечисленных вкладок (<code>На сборке</code>, <code>В доставке</code>, <code>Архив</code>)</li>  <li>Зайти в детализацию поставки</li>  <li>Нажать кнопку \"Выгрузить в Excel\"</li>  <li>В полученном файле открыть лист КИЗы</li> </ol> Получить загруженные КиЗ можно по всем заказам, кроме: <code>Новые</code>, <code>Отменено продавцом</code>.<br> <br> С правилами работы с КиЗ можно ознакомиться тут: https://честныйзнак.рф <br> <br> О реализации API-функционала для получения загруженных КиЗ будет сообщено в разделе Новости, на портале продавцов. 
     * @summary Закрепить за сборочным заданием КиЗ (маркировку Честного знака)
     * @param {number} order Идентификатор сборочного задания
     * @param {MetaSgtinBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Marketplace_Api
     */
    public apiV3OrdersOrderMetaSgtinPost(order: number, body?: MetaSgtinBody, options?: any) {
        return Marketplace_ApiFp(this.configuration).apiV3OrdersOrderMetaSgtinPost(order, body, options)(this.fetch, this.basePath);
    }

    /**
     * Возвращает статусы сборочных заданий по переданному списку идентификаторов сборочных заданий.  **supplierStatus** - статус сборочного задания, триггером изменения которого является сам продавец.<br> Возможны следующие значения данного поля: | Статус   | Описание            | Как перевести сборочное задание в данный статус | | -------  | ---------           | --------------------------------------| | new      | Новое сборочное задание |           | confirm  | На сборке            | При добавлении сборочного задания к поставке **PATCH** *_/api/v3/supplies/{supply}/orders/{order}* | complete | В доставке           | При переводе в доставку соответствующей поставки **PATCH** *_/api/v3/supplies/{supply}/deliver* | cancel   | Отменено продавцом   | **PATCH** *_/api/v3/orders/{order}/cancel*   **wbStatus** - статус сборочного задания в системе Wildberries.<br> Возможны следующие значения данного поля: - **waiting** - сборочное задание в работе - **sorted** - сборочное задание отсортировано - **sold** - сборочное задание получено покупателем - **canceled** - отмена сборочного задания - **canceled_by_client** - отмена сборочного задания покупателем - **defect** - отмена сборочного задания по причине брака - **ready_for_pickup** - сборочное задание прибыло на ПВЗ <span class=\"new\">new</span> 
     * @summary Получить статусы сборочных заданий
     * @param {OrdersStatusBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Marketplace_Api
     */
    public apiV3OrdersStatusPost(body?: OrdersStatusBody, options?: any) {
        return Marketplace_ApiFp(this.configuration).apiV3OrdersStatusPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Возвращает список этикеток по переданному массиву сборочных заданий. Можно запросить этикетку в формате svg, zplv (вертикальный), zplh (горизонтальный), png.  **Ограничения при работе с методом**: - Нельзя запросить больше 100 этикеток за раз (не более 100 идентификаторов сборочных заданий в запросе). - Метод возвращает этикетки только для сборочных заданий, находящихся на сборке (в статусе **confirm**). - Доступные размеры: <dd>580x400 пикселей, при параметрах width = 58, height = 40</dd> <dd>400x300 пикселей, при параметрах width = 40, height = 30</dd> 
     * @summary Получить этикетки для сборочных заданий
     * @param {string} type Тип этикетки
     * @param {number} width Ширина этикетки
     * @param {number} height Высота этикетки
     * @param {OrdersStickersBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Marketplace_Api
     */
    public apiV3OrdersStickersPost(type: string, width: number, height: number, body?: OrdersStickersBody, options?: any) {
        return Marketplace_ApiFp(this.configuration).apiV3OrdersStickersPost(type, width, height, body, options)(this.fetch, this.basePath);
    }

    /**
     * Удаляет остатки товаров. **Внимание! Действие необратимо**. Удаленный остаток будет необходимо загрузить повторно для возобновления продаж.
     * @summary Удалить остатки товаров
     * @param {StocksWarehouseBody2} body 
     * @param {number} warehouse Идентификатор склада продавца
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Marketplace_Api
     */
    public apiV3StocksWarehouseDelete(body: StocksWarehouseBody2, warehouse: number, options?: any) {
        return Marketplace_ApiFp(this.configuration).apiV3StocksWarehouseDelete(body, warehouse, options)(this.fetch, this.basePath);
    }

    /**
     * Возвращает остатки товаров.
     * @summary Получить остатки товаров
     * @param {StocksWarehouseBody1} body 
     * @param {number} warehouse Идентификатор склада продавца
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Marketplace_Api
     */
    public apiV3StocksWarehousePost(body: StocksWarehouseBody1, warehouse: number, options?: any) {
        return Marketplace_ApiFp(this.configuration).apiV3StocksWarehousePost(body, warehouse, options)(this.fetch, this.basePath);
    }

    /**
     * Обновляет остатки товаров.
     * @summary Обновить остатки товаров
     * @param {number} warehouse Идентификатор склада продавца
     * @param {StocksWarehouseBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Marketplace_Api
     */
    public apiV3StocksWarehousePut(warehouse: number, body?: StocksWarehouseBody, options?: any) {
        return Marketplace_ApiFp(this.configuration).apiV3StocksWarehousePut(warehouse, body, options)(this.fetch, this.basePath);
    }

    /**
     * Возвращает список поставок
     * @summary Получить список поставок
     * @param {number} limit Параметр пагинации. Устанавливает предельное количество возвращаемых данных.
     * @param {number} next Параметр пагинации. Устанавливает значение, с которого надо получить следующий пакет данных. Для получения полного списка данных должен быть равен 0 в первом запросе. Для следующих запросов необходимо брать значения из одноимённого поля в ответе.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Marketplace_Api
     */
    public apiV3SuppliesGet(limit: number, next: number, options?: any) {
        return Marketplace_ApiFp(this.configuration).apiV3SuppliesGet(limit, next, options)(this.fetch, this.basePath);
    }

    /**
     * **Ограничения работы с поставками**:  - Только для сборочных заданий по схеме \"Везу на склад WB\" - При добавлении в поставку все передаваемые сборочные задания в статусе **new** (\"Новое\") будут автоматически переведены в статус **confirm** (\"На сборке\"). - Обратите внимание, что если вы переведёте сборочное задание в статус **cancel** (\"Отмена продавцом\"), то сборочное задание автоматически удалится из поставки, если было прикреплено к ней. - Поставку можно собрать только из одного типа сборочных заданий: сКГТ (isLargeCargo = true) или обычный (isLargeCargo = false). Новая поставка не обладает сКГТ-признаком. При добавлении первого заказа в поставку она приобретает сКГТ-признак добавляемого товара в заказе. 
     * @summary Создать новую поставку
     * @param {V3SuppliesBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Marketplace_Api
     */
    public apiV3SuppliesPost(body: V3SuppliesBody, options?: any) {
        return Marketplace_ApiFp(this.configuration).apiV3SuppliesPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Возвращает QR в svg, zplv (вертикальный), zplh (горизонтальный), png. <br> Можно получить, только если поставка передана в доставку. <dt>Доступные размеры:</dt> <dd>580x400 пикселей 
     * @summary Получить QR поставки
     * @param {string} supply Идентификатор поставки
     * @param {string} type Тип этикетки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Marketplace_Api
     */
    public apiV3SuppliesSupplyBarcodeGet(supply: string, type: string, options?: any) {
        return Marketplace_ApiFp(this.configuration).apiV3SuppliesSupplyBarcodeGet(supply, type, options)(this.fetch, this.basePath);
    }

    /**
     * Удаляет поставку, если она активна и за ней не закреплено ни одно сборочное задание.
     * @summary Удалить поставку
     * @param {string} supply Идентификатор поставки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Marketplace_Api
     */
    public apiV3SuppliesSupplyDelete(supply: string, options?: any) {
        return Marketplace_ApiFp(this.configuration).apiV3SuppliesSupplyDelete(supply, options)(this.fetch, this.basePath);
    }

    /**
     * Закрывает поставку и переводит все сборочные задания в ней в статус **complete** (\"В доставке\"). После закрытия поставки новые сборочные задания к ней добавить будет невозможно. Передать поставку в доставку можно только при наличии в ней хотя бы одного сборочного задания. 
     * @summary Передать поставку в доставку
     * @param {string} supply Идентификатор поставки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Marketplace_Api
     */
    public apiV3SuppliesSupplyDeliverPatch(supply: string, options?: any) {
        return Marketplace_ApiFp(this.configuration).apiV3SuppliesSupplyDeliverPatch(supply, options)(this.fetch, this.basePath);
    }

    /**
     * Возвращает информацию о поставке
     * @summary Получить информацию о поставке
     * @param {string} supply Идентификатор поставки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Marketplace_Api
     */
    public apiV3SuppliesSupplyGet(supply: string, options?: any) {
        return Marketplace_ApiFp(this.configuration).apiV3SuppliesSupplyGet(supply, options)(this.fetch, this.basePath);
    }

    /**
     * Возвращает сборочные задания, закреплённые за поставкой.
     * @summary Получить сборочные задания в поставке
     * @param {string} supply Идентификатор поставки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Marketplace_Api
     */
    public apiV3SuppliesSupplyOrdersGet(supply: string, options?: any) {
        return Marketplace_ApiFp(this.configuration).apiV3SuppliesSupplyOrdersGet(supply, options)(this.fetch, this.basePath);
    }

    /**
     * Добавляет к поставке сборочное задание и переводит его в статус **confirm** (\"На сборке\").  Также может перемещать сборочное задание между активными поставками, либо из закрытой в активную при условии, что сборочное задание требует повторной отгрузки. Добавить в поставку возможно только задания с соответствующим сКГТ-признаком (isLargeCargo), либо если поставке ещё не присвоен сКГТ-признак (isLargeCargo = null). 
     * @summary Добавить к поставке сборочное задание
     * @param {string} supply Идентификатор поставки
     * @param {number} order Идентификатор сборочного задания
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Marketplace_Api
     */
    public apiV3SuppliesSupplyOrdersOrderPatch(supply: string, order: number, options?: any) {
        return Marketplace_ApiFp(this.configuration).apiV3SuppliesSupplyOrdersOrderPatch(supply, order, options)(this.fetch, this.basePath);
    }

}
/**
 * _Api - fetch parameter creator
 * @export
 */
export const _ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Метод позволяет сгенерировать массив уникальных баркодов для создания размера НМ в КТ.
         * @summary Генерация баркодов
         * @param {V1BarcodesBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1BarcodesPost(body: V1BarcodesBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling contentV1BarcodesPost.');
            }
            const localVarPath = `/content/v1/barcodes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1BarcodesBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет получить список созданых НМ по фильтру (баркод, артикул продавца, артикул WB (nmId), тег) с пагинацией и сортировкой. <br> <br>Порядок работы с `cursor/list`: <br> Чтобы получить полный список номенклатур, <b>если их > 1000</b>, необходимо воспользоваться пагинацией.   <ol>     <li>Cделать первый запрос (все указанные ниже параметры обязательны): <br>       <pre style=\"background-color: rgb(38 50 56 / 5%); color: #e53935\">         {           \"sort\": {               \"cursor\": {                   \"limit\": 1000               },               \"filter\": {                   \"withPhoto\": -1               }           }         }</pre>       По желанию можно добавить поиск по <code>\"textSearch\"</code> и сортировку.       <pre style=\"background-color: rgb(38 50 56 / 5%); color: #e53935\">         \"sort\": {           \"sortColumn\": \"\",           \"ascending\": false         }</pre>     </li>     <li>Пройти в конец полученного списка номенклатур, скопировать из <code>cursor</code> две строки:       <ul>         <li><code>\"updatedAt\": \"***\"</code>,</li>         <li><code>\"nmID\": ***</code>,</li>       </ul>     <li>Вставить скопированные строки в <code>cursor</code> запроса, повторить вызов метода. </li>     <li>Повторять пункты <b>2</b> и <b>3</b>, пока <code>total</code> в ответе не станет меньше чем <code>limit</code> в запросе.       <br>Это будет означать, что Вы получили все карточки.   </ol> 
         * @summary Список НМ
         * @param {CursorListBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1CardsCursorListPost(body: CursorListBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling contentV1CardsCursorListPost.');
            }
            const localVarPath = `/content/v1/cards/cursor/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CursorListBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет получить список НМ и список ошибок которые произошли во время создания КТ. <br>`ВАЖНО`: Для того чтобы убрать НМ из ошибочных, надо повторно сделать запрос с исправленными ошибками на создание КТ. 
         * @summary Список несозданных НМ с ошибками
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1CardsErrorListGet(options: any = {}): FetchArgs {
            const localVarPath = `/content/v1/cards/error/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет получить полную информацию по КТ с помощью артикула(-ов) продавца. 
         * @summary Получение КТ по артикулам продавца
         * @param {CardsFilterBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1CardsFilterPost(body: CardsFilterBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling contentV1CardsFilterPost.');
            }
            const localVarPath = `/content/v1/cards/filter`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CardsFilterBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет получить отдельно бесплатные и платные лимиты продавца на создание карточек товаров.
         * @summary Лимиты по КТ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1CardsLimitsGet(options: any = {}): FetchArgs {
            const localVarPath = `/content/v1/cards/limits`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет получить список НМ, находящихся в корзине.<br> Метод позволяет получить список НМ, которые находятся в корзине по фильтру (баркод (<code>skus</code>), артикул продавца(<code>vendorCode</code>), артикул WB(<code>nmID</code>)) с пагинацией и сортировкой. 
         * @summary Список НМ, находящихся в корзине
         * @param {TrashListBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1CardsTrashListPost(body: TrashListBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling contentV1CardsTrashListPost.');
            }
            const localVarPath = `/content/v1/cards/trash/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TrashListBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет отредактировать несколько карточек за раз. <br> Редактирование КТ происходит асинхронно, после отправки запрос становится в очередь на обработку. <br> `Важно`: Баркоды (skus) не подлежат удалению или замене. Попытка заменить существующий баркод приведет к добавлению нового баркода к существующему. <br> Если запрос прошел успешно, а информация в карточке не обновилась, значит были допущены ошибки и карточка попала в \"Черновики\" (метод `cards/error/list`) с описанием ошибок. <br>Необходимо исправить ошибки в запросе и отправить его повторно. <br> <br> Для успешного обновления карточки рекомендуем Вам придерживаться следующего порядка действий: <br> 1. Сначала существующую карточку необходимо запросить методом cards/filter. <br> 2. Забираем из ответа массив data. <br> 3. В этом массиве вносим необходимые изменения и отправляем его в cards/update <br> <br>За раз можно отредактировать 1000 КТ по 5 НМ в каждой. <br> <br> `Важно`: Изменение цен данным методом невозможно, используйте метод Загрузка цен, раздел документации Цены. 
         * @summary Редактирование КТ
         * @param {Array<CardsUpdateBody>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1CardsUpdatePost(body: Array<CardsUpdateBody>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling contentV1CardsUpdatePost.');
            }
            const localVarPath = `/content/v1/cards/update`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;CardsUpdateBody&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет добавить к карточке товара новую номенклатуру. <br>Добавление НМ к КТ происходит асинхронно, после отправки запрос становится в очередь на обработку. <br>`Важно`: Если после успешной отправки запроса номенклатура не создалась, то необходимо проверить раздел \"Список несозданных НМ с ошибками\". Для того чтобы убрать НМ из ошибочных, необходимо повторно сделать запрос с исправленными ошибками. 
         * @summary Добавление НМ к КТ
         * @param {UploadAddBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1CardsUploadAddPost(body: UploadAddBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling contentV1CardsUploadAddPost.');
            }
            const localVarPath = `/content/v1/cards/upload/add`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UploadAddBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Создание карточки товара происходит асинхронно, при отправке запроса на создание КТ ваш запрос становится в очередь на создание КТ. <br>`ПРИМЕЧАНИЕ`: Карточка товара считается `созданной`, если успешно создалась хотя бы одна `НМ`. <br>`ВАЖНО`: Если во время обработки запроса в очереди выявляются ошибки, то НМ считается ошибочной. <br>Если запрос на создание прошел успешно, а карточка не создалась, то необходимо в первую очередь проверить наличие карточки в методе `cards/error/list`. Если карточка попала в ответ к этому методу, то необходимо исправить описанные ошибки в запросе на создание карточки и отправить его повторно. <br>За раз можно создать 1000 КТ по 5 НМ в каждой.  <br>Если Вам требуется больше 5 НМ в КТ, то после создания карточки Вы можете добавить их методом \"Добавление НМ к КТ\". 
         * @summary Создание  КТ
         * @param {CardsUploadBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1CardsUploadPost(body: CardsUploadBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling contentV1CardsUploadPost.');
            }
            const localVarPath = `/content/v1/cards/upload`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CardsUploadBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение значения характеристики Бренд.
         * @summary Бренд
         * @param {number} [top] Количество запрашиваемых значений (максимум 5000)
         * @param {string} [pattern] Поиск по наименованию значения характеристики
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1DirectoryBrandsGet(top?: number, pattern?: string, options: any = {}): FetchArgs {
            const localVarPath = `/content/v1/directory/brands`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (top !== undefined) {
                localVarQueryParameter['top'] = top;
            }

            if (pattern !== undefined) {
                localVarQueryParameter['pattern'] = pattern;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение значения характеристики цвет.
         * @summary Цвет
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1DirectoryColorsGet(options: any = {}): FetchArgs {
            const localVarPath = `/content/v1/directory/colors`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение значения характеристики Страна Производства.
         * @summary Страна Производства
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1DirectoryCountriesGet(options: any = {}): FetchArgs {
            const localVarPath = `/content/v1/directory/countries`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение значения характеристики пол.
         * @summary Пол
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1DirectoryKindsGet(options: any = {}): FetchArgs {
            const localVarPath = `/content/v1/directory/kinds`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение значения характеристики Сезон.
         * @summary Сезон
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1DirectorySeasonsGet(options: any = {}): FetchArgs {
            const localVarPath = `/content/v1/directory/seasons`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * С помощью данного метода можно получить список ТНВЭД кодов по имени категории и фильтру по тнвэд коду.
         * @summary ТНВЭД код
         * @param {string} [objectName] Поиск по наименованию категории
         * @param {string} [tnvedsLike] Поиск по коду ТНВЭД
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1DirectoryTnvedGet(objectName?: string, tnvedsLike?: string, options: any = {}): FetchArgs {
            const localVarPath = `/content/v1/directory/tnved`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (objectName !== undefined) {
                localVarQueryParameter['objectName'] = objectName;
            }

            if (tnvedsLike !== undefined) {
                localVarQueryParameter['tnvedsLike'] = tnvedsLike;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет загрузить и добавить один медиафайл за запрос, к НМ в КТ. <br>Требования к медиафайлам: <br>`Фото`: минимальное разрешение – 450х450. <br>Максимально допустимое количество фото в КТ 30. <br>Допустимые форматы изображений - jpg и png. <br>`Видео`: максимальный размер 50 мб. Форматы MOV, MP4. <br>Максимально допустимое количество видео в КТ 1. 
         * @summary Добавление медиа контента в КТ
         * @param {Blob} uploadfile 
         * @param {string} xVendorCode Артикул продавца
         * @param {number} xPhotoNumber Номер медиафайла на загрузку. &lt;b&gt;Начинать с 1&lt;/b&gt;. &lt;br&gt;Чтобы добавить фото к уже загруженным в НМ, номер медиафайла должен быть больше кол-ва загруженных в НМ медиафайлов. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1MediaFilePost(uploadfile: Blob, xVendorCode: string, xPhotoNumber: number, options: any = {}): FetchArgs {
            // verify required parameter 'uploadfile' is not null or undefined
            if (uploadfile === null || uploadfile === undefined) {
                throw new RequiredError('uploadfile','Required parameter uploadfile was null or undefined when calling contentV1MediaFilePost.');
            }
            // verify required parameter 'xVendorCode' is not null or undefined
            if (xVendorCode === null || xVendorCode === undefined) {
                throw new RequiredError('xVendorCode','Required parameter xVendorCode was null or undefined when calling contentV1MediaFilePost.');
            }
            // verify required parameter 'xPhotoNumber' is not null or undefined
            if (xPhotoNumber === null || xPhotoNumber === undefined) {
                throw new RequiredError('xPhotoNumber','Required parameter xPhotoNumber was null or undefined when calling contentV1MediaFilePost.');
            }
            const localVarPath = `/content/v1/media/file`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (xVendorCode !== undefined && xVendorCode !== null) {
                localVarHeaderParameter['X-Vendor-Code'] = String(xVendorCode);
            }

            if (xPhotoNumber !== undefined && xPhotoNumber !== null) {
                localVarHeaderParameter['X-Photo-Number'] = String(xPhotoNumber);
            }

            if (uploadfile !== undefined) {
                localVarFormParams.set('uploadfile', uploadfile as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет изменить порядок изображений или удалить медиафайлы с НМ в КТ, а также загрузить изображения в НМ со сторонних ресурсов по URL. <br>Текущие изображения заменяются на переданные в массиве data. <br> <br>Требования к медиафайлам: <br>`Фото`: минимальное разрешение – 450х450. <br>Максимально допустимое количество фото в КТ 30.  <br>Допустимые форматы изображений - jpg и png. <br> <br>Если хотя бы одно изображение в запросе не соответствует требованиям к медиафайлам, то даже при коде ответа 200 ни одно изображение не загрузится в КТ. 
         * @summary Изменение медиа контента КТ
         * @param {MediaSaveBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1MediaSavePost(body: MediaSaveBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling contentV1MediaSavePost.');
            }
            const localVarPath = `/content/v1/media/save`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MediaSaveBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * С помощью данного метода можно получить список категорий товаров по текстовому фильтру (названию категории). <br> <br> Чтобы получить список всех категорий необходимо указать `top=8000`, к примеру. <br> <br> По состоянию на `27.03.2023` в списке `7440` категорий. Количество доступных категорий может меняться.       
         * @summary Категория товаров
         * @param {string} [name] Поиск по названию категории
         * @param {number} [top] Количество запрашиваемых значений
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1ObjectAllGet(name?: string, top?: number, options: any = {}): FetchArgs {
            const localVarPath = `/content/v1/object/all`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (top !== undefined) {
                localVarQueryParameter['top'] = top;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * С помощью данного метода можно получить список характеристик, которые можно или нужно заполнить при создании КТ в подкатегории определенной родительской категории.   <br>   <br>Характеристики с  `charcType=4`, имеющие единственное значение, <b>указывать строго без массива</b>, в противном случае карточка не будет создана:   <br><b>Правильно:</b>       <br>`{\"Высота упаковки\": 4}`   <br><b>Не правильно:</b>       <br>`{\"Высота упаковки\": [4]}` 
         * @summary Характеристики для создания КТ по всем подкатегориям
         * @param {string} [name] Поиск по родительской категории.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1ObjectCharacteristicsListFilterGet(name?: string, options: any = {}): FetchArgs {
            const localVarPath = `/content/v1/object/characteristics/list/filter`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * С помощью данного метода можно получить список характеристик, которые можно или нужно заполнить при создании КТ для определенной категории товаров. <br> <br> `Важно`: обязательная к заполнению характеристика при создании карточки любого товара - `Предмет`. <br>Значение характеристики `Предмет` соответствует значению параметра `objectName` в запросе. <br> <br>Характеристики с  `charcType=4`, имеющие единственное значение, <b>указывать строго без массива</b>, в противном случае карточка не будет создана: <br><b>Правильно:</b>     <br>`{\"Высота упаковки\": 4}` <br><b>Не правильно:</b>     <br>`{\"Высота упаковки\": [4]}` 
         * @summary Характеристики для создания КТ для категории товара
         * @param {string} objectName Поиск по наименованию категории
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1ObjectCharacteristicsObjectNameGet(objectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling contentV1ObjectCharacteristicsObjectNameGet.');
            }
            const localVarPath = `/content/v1/object/characteristics/{objectName}`
                .replace(`{${"objectName"}}`, encodeURIComponent(String(objectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * С помощью данного метода можно получить список всех родительских категорий товаров.
         * @summary Родительские категории товаров
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1ObjectParentAllGet(options: any = {}): FetchArgs {
            const localVarPath = `/content/v1/object/parent/all`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет удалить тег.
         * @summary Удаление тега
         * @param {number} id Числовой идентификатор тега
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1TagIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling contentV1TagIdDelete.');
            }
            const localVarPath = `/content/v1/tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет изменять информацию о теге (имя и цвет).
         * @summary Изменение тега
         * @param {TagIdBody} body 
         * @param {number} id Числовой идентификатор тега
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1TagIdPatch(body: TagIdBody, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling contentV1TagIdPatch.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling contentV1TagIdPatch.');
            }
            const localVarPath = `/content/v1/tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TagIdBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет добавить теги к КТ и снять их с КТ.<br> При снятии тега с КТ сам тег не удаляется.<br> К карточке можно добавить 8 тегов. 
         * @summary Управление тегами в КТ
         * @param {NomenclatureLinkBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1TagNomenclatureLinkPost(body: NomenclatureLinkBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling contentV1TagNomenclatureLinkPost.');
            }
            const localVarPath = `/content/v1/tag/nomenclature/link`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NomenclatureLinkBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет создать тег.<br> Завести можно 8 тегов.<br> Максимальная длина тега 15 символов. 
         * @summary Создание тега
         * @param {V1TagBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1TagPost(body: V1TagBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling contentV1TagPost.');
            }
            const localVarPath = `/content/v1/tag`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1TagBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Метод позволяет получить список существующих тегов продавца.
         * @summary Список тегов
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1TagsGet(options: any = {}): FetchArgs {
            const localVarPath = `/content/v1/tags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Сброс скидок для номенклатур. При первом запросе ответ будет пустым. При повторной попытке сбросить скидку вернет JSON с id первичного запроса.
         * @summary Сброс скидок для номенклатур
         * @param {Array<number>} body Перечень номенклатур к отмене скидок
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicApiV1RevokeDiscountsPost(body: Array<number>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling publicApiV1RevokeDiscountsPost.');
            }
            const localVarPath = `/public/api/v1/revokeDiscounts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;number&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Сброс промокодов для номенклатур
         * @summary Сброс промокодов для номенклатур
         * @param {Array<number>} body Перечень номенклатур к отмене промокодов
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicApiV1RevokePromocodesPost(body: Array<number>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling publicApiV1RevokePromocodesPost.');
            }
            const localVarPath = `/public/api/v1/revokePromocodes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;number&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Установка скидок для номенклатур. Максимальное количество номенклатур на запрос - 1000
         * @summary Установка скидок
         * @param {Array<any>} body Перечень номенклатур
         * @param {string} [activateFrom] Дата активации скидки в формате &#x60;YYYY-MM-DD&#x60; или &#x60;YYYY-MM-DD HH:MM:SS&#x60;. Если не указывать, скидка начнет действовать сразу.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicApiV1UpdateDiscountsPost(body: Array<any>, activateFrom?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling publicApiV1UpdateDiscountsPost.');
            }
            const localVarPath = `/public/api/v1/updateDiscounts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (activateFrom !== undefined) {
                localVarQueryParameter['activateFrom'] = activateFrom;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;any&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Установка промокодов для номенклатур. Максимальное количество номенклатур на запрос - 1000
         * @summary Установка промокодов для номенклатур
         * @param {Array<any>} body Перечень номенклатур
         * @param {string} [activateFrom] Дата активации промокада в формате &#x60;YYYY-MM-DD&#x60; или &#x60;YYYY-MM-DD HH:MM:SS&#x60;. Если не указывать, промокод начнет действовать сразу
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicApiV1UpdatePromocodesPost(body: Array<any>, activateFrom?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling publicApiV1UpdatePromocodesPost.');
            }
            const localVarPath = `/public/api/v1/updatePromocodes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HeaderApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (activateFrom !== undefined) {
                localVarQueryParameter['activateFrom'] = activateFrom;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;any&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * _Api - functional programming interface
 * @export
 */
export const _ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Метод позволяет сгенерировать массив уникальных баркодов для создания размера НМ в КТ.
         * @summary Генерация баркодов
         * @param {V1BarcodesBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1BarcodesPost(body: V1BarcodesBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
            const localVarFetchArgs = _ApiFetchParamCreator(configuration).contentV1BarcodesPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет получить список созданых НМ по фильтру (баркод, артикул продавца, артикул WB (nmId), тег) с пагинацией и сортировкой. <br> <br>Порядок работы с `cursor/list`: <br> Чтобы получить полный список номенклатур, <b>если их > 1000</b>, необходимо воспользоваться пагинацией.   <ol>     <li>Cделать первый запрос (все указанные ниже параметры обязательны): <br>       <pre style=\"background-color: rgb(38 50 56 / 5%); color: #e53935\">         {           \"sort\": {               \"cursor\": {                   \"limit\": 1000               },               \"filter\": {                   \"withPhoto\": -1               }           }         }</pre>       По желанию можно добавить поиск по <code>\"textSearch\"</code> и сортировку.       <pre style=\"background-color: rgb(38 50 56 / 5%); color: #e53935\">         \"sort\": {           \"sortColumn\": \"\",           \"ascending\": false         }</pre>     </li>     <li>Пройти в конец полученного списка номенклатур, скопировать из <code>cursor</code> две строки:       <ul>         <li><code>\"updatedAt\": \"***\"</code>,</li>         <li><code>\"nmID\": ***</code>,</li>       </ul>     <li>Вставить скопированные строки в <code>cursor</code> запроса, повторить вызов метода. </li>     <li>Повторять пункты <b>2</b> и <b>3</b>, пока <code>total</code> в ответе не станет меньше чем <code>limit</code> в запросе.       <br>Это будет означать, что Вы получили все карточки.   </ol> 
         * @summary Список НМ
         * @param {CursorListBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1CardsCursorListPost(body: CursorListBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = _ApiFetchParamCreator(configuration).contentV1CardsCursorListPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет получить список НМ и список ошибок которые произошли во время создания КТ. <br>`ВАЖНО`: Для того чтобы убрать НМ из ошибочных, надо повторно сделать запрос с исправленными ошибками на создание КТ. 
         * @summary Список несозданных НМ с ошибками
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1CardsErrorListGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2005> {
            const localVarFetchArgs = _ApiFetchParamCreator(configuration).contentV1CardsErrorListGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет получить полную информацию по КТ с помощью артикула(-ов) продавца. 
         * @summary Получение КТ по артикулам продавца
         * @param {CardsFilterBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1CardsFilterPost(body: CardsFilterBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2006> {
            const localVarFetchArgs = _ApiFetchParamCreator(configuration).contentV1CardsFilterPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет получить отдельно бесплатные и платные лимиты продавца на создание карточек товаров.
         * @summary Лимиты по КТ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1CardsLimitsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2007> {
            const localVarFetchArgs = _ApiFetchParamCreator(configuration).contentV1CardsLimitsGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет получить список НМ, находящихся в корзине.<br> Метод позволяет получить список НМ, которые находятся в корзине по фильтру (баркод (<code>skus</code>), артикул продавца(<code>vendorCode</code>), артикул WB(<code>nmID</code>)) с пагинацией и сортировкой. 
         * @summary Список НМ, находящихся в корзине
         * @param {TrashListBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1CardsTrashListPost(body: TrashListBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20022> {
            const localVarFetchArgs = _ApiFetchParamCreator(configuration).contentV1CardsTrashListPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет отредактировать несколько карточек за раз. <br> Редактирование КТ происходит асинхронно, после отправки запрос становится в очередь на обработку. <br> `Важно`: Баркоды (skus) не подлежат удалению или замене. Попытка заменить существующий баркод приведет к добавлению нового баркода к существующему. <br> Если запрос прошел успешно, а информация в карточке не обновилась, значит были допущены ошибки и карточка попала в \"Черновики\" (метод `cards/error/list`) с описанием ошибок. <br>Необходимо исправить ошибки в запросе и отправить его повторно. <br> <br> Для успешного обновления карточки рекомендуем Вам придерживаться следующего порядка действий: <br> 1. Сначала существующую карточку необходимо запросить методом cards/filter. <br> 2. Забираем из ответа массив data. <br> 3. В этом массиве вносим необходимые изменения и отправляем его в cards/update <br> <br>За раз можно отредактировать 1000 КТ по 5 НМ в каждой. <br> <br> `Важно`: Изменение цен данным методом невозможно, используйте метод Загрузка цен, раздел документации Цены. 
         * @summary Редактирование КТ
         * @param {Array<CardsUpdateBody>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1CardsUpdatePost(body: Array<CardsUpdateBody>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = _ApiFetchParamCreator(configuration).contentV1CardsUpdatePost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет добавить к карточке товара новую номенклатуру. <br>Добавление НМ к КТ происходит асинхронно, после отправки запрос становится в очередь на обработку. <br>`Важно`: Если после успешной отправки запроса номенклатура не создалась, то необходимо проверить раздел \"Список несозданных НМ с ошибками\". Для того чтобы убрать НМ из ошибочных, необходимо повторно сделать запрос с исправленными ошибками. 
         * @summary Добавление НМ к КТ
         * @param {UploadAddBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1CardsUploadAddPost(body: UploadAddBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = _ApiFetchParamCreator(configuration).contentV1CardsUploadAddPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Создание карточки товара происходит асинхронно, при отправке запроса на создание КТ ваш запрос становится в очередь на создание КТ. <br>`ПРИМЕЧАНИЕ`: Карточка товара считается `созданной`, если успешно создалась хотя бы одна `НМ`. <br>`ВАЖНО`: Если во время обработки запроса в очереди выявляются ошибки, то НМ считается ошибочной. <br>Если запрос на создание прошел успешно, а карточка не создалась, то необходимо в первую очередь проверить наличие карточки в методе `cards/error/list`. Если карточка попала в ответ к этому методу, то необходимо исправить описанные ошибки в запросе на создание карточки и отправить его повторно. <br>За раз можно создать 1000 КТ по 5 НМ в каждой.  <br>Если Вам требуется больше 5 НМ в КТ, то после создания карточки Вы можете добавить их методом \"Добавление НМ к КТ\". 
         * @summary Создание  КТ
         * @param {CardsUploadBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1CardsUploadPost(body: CardsUploadBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = _ApiFetchParamCreator(configuration).contentV1CardsUploadPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Получение значения характеристики Бренд.
         * @summary Бренд
         * @param {number} [top] Количество запрашиваемых значений (максимум 5000)
         * @param {string} [pattern] Поиск по наименованию значения характеристики
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1DirectoryBrandsGet(top?: number, pattern?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20016> {
            const localVarFetchArgs = _ApiFetchParamCreator(configuration).contentV1DirectoryBrandsGet(top, pattern, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Получение значения характеристики цвет.
         * @summary Цвет
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1DirectoryColorsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20012> {
            const localVarFetchArgs = _ApiFetchParamCreator(configuration).contentV1DirectoryColorsGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Получение значения характеристики Страна Производства.
         * @summary Страна Производства
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1DirectoryCountriesGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20014> {
            const localVarFetchArgs = _ApiFetchParamCreator(configuration).contentV1DirectoryCountriesGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Получение значения характеристики пол.
         * @summary Пол
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1DirectoryKindsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20013> {
            const localVarFetchArgs = _ApiFetchParamCreator(configuration).contentV1DirectoryKindsGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Получение значения характеристики Сезон.
         * @summary Сезон
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1DirectorySeasonsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20015> {
            const localVarFetchArgs = _ApiFetchParamCreator(configuration).contentV1DirectorySeasonsGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * С помощью данного метода можно получить список ТНВЭД кодов по имени категории и фильтру по тнвэд коду.
         * @summary ТНВЭД код
         * @param {string} [objectName] Поиск по наименованию категории
         * @param {string} [tnvedsLike] Поиск по коду ТНВЭД
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1DirectoryTnvedGet(objectName?: string, tnvedsLike?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20017> {
            const localVarFetchArgs = _ApiFetchParamCreator(configuration).contentV1DirectoryTnvedGet(objectName, tnvedsLike, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет загрузить и добавить один медиафайл за запрос, к НМ в КТ. <br>Требования к медиафайлам: <br>`Фото`: минимальное разрешение – 450х450. <br>Максимально допустимое количество фото в КТ 30. <br>Допустимые форматы изображений - jpg и png. <br>`Видео`: максимальный размер 50 мб. Форматы MOV, MP4. <br>Максимально допустимое количество видео в КТ 1. 
         * @summary Добавление медиа контента в КТ
         * @param {Blob} uploadfile 
         * @param {string} xVendorCode Артикул продавца
         * @param {number} xPhotoNumber Номер медиафайла на загрузку. &lt;b&gt;Начинать с 1&lt;/b&gt;. &lt;br&gt;Чтобы добавить фото к уже загруженным в НМ, номер медиафайла должен быть больше кол-ва загруженных в НМ медиафайлов. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1MediaFilePost(uploadfile: Blob, xVendorCode: string, xPhotoNumber: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20018> {
            const localVarFetchArgs = _ApiFetchParamCreator(configuration).contentV1MediaFilePost(uploadfile, xVendorCode, xPhotoNumber, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет изменить порядок изображений или удалить медиафайлы с НМ в КТ, а также загрузить изображения в НМ со сторонних ресурсов по URL. <br>Текущие изображения заменяются на переданные в массиве data. <br> <br>Требования к медиафайлам: <br>`Фото`: минимальное разрешение – 450х450. <br>Максимально допустимое количество фото в КТ 30.  <br>Допустимые форматы изображений - jpg и png. <br> <br>Если хотя бы одно изображение в запросе не соответствует требованиям к медиафайлам, то даже при коде ответа 200 ни одно изображение не загрузится в КТ. 
         * @summary Изменение медиа контента КТ
         * @param {MediaSaveBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1MediaSavePost(body: MediaSaveBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20018> {
            const localVarFetchArgs = _ApiFetchParamCreator(configuration).contentV1MediaSavePost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * С помощью данного метода можно получить список категорий товаров по текстовому фильтру (названию категории). <br> <br> Чтобы получить список всех категорий необходимо указать `top=8000`, к примеру. <br> <br> По состоянию на `27.03.2023` в списке `7440` категорий. Количество доступных категорий может меняться.       
         * @summary Категория товаров
         * @param {string} [name] Поиск по названию категории
         * @param {number} [top] Количество запрашиваемых значений
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1ObjectAllGet(name?: string, top?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2008> {
            const localVarFetchArgs = _ApiFetchParamCreator(configuration).contentV1ObjectAllGet(name, top, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * С помощью данного метода можно получить список характеристик, которые можно или нужно заполнить при создании КТ в подкатегории определенной родительской категории.   <br>   <br>Характеристики с  `charcType=4`, имеющие единственное значение, <b>указывать строго без массива</b>, в противном случае карточка не будет создана:   <br><b>Правильно:</b>       <br>`{\"Высота упаковки\": 4}`   <br><b>Не правильно:</b>       <br>`{\"Высота упаковки\": [4]}` 
         * @summary Характеристики для создания КТ по всем подкатегориям
         * @param {string} [name] Поиск по родительской категории.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1ObjectCharacteristicsListFilterGet(name?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20010> {
            const localVarFetchArgs = _ApiFetchParamCreator(configuration).contentV1ObjectCharacteristicsListFilterGet(name, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * С помощью данного метода можно получить список характеристик, которые можно или нужно заполнить при создании КТ для определенной категории товаров. <br> <br> `Важно`: обязательная к заполнению характеристика при создании карточки любого товара - `Предмет`. <br>Значение характеристики `Предмет` соответствует значению параметра `objectName` в запросе. <br> <br>Характеристики с  `charcType=4`, имеющие единственное значение, <b>указывать строго без массива</b>, в противном случае карточка не будет создана: <br><b>Правильно:</b>     <br>`{\"Высота упаковки\": 4}` <br><b>Не правильно:</b>     <br>`{\"Высота упаковки\": [4]}` 
         * @summary Характеристики для создания КТ для категории товара
         * @param {string} objectName Поиск по наименованию категории
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1ObjectCharacteristicsObjectNameGet(objectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20011> {
            const localVarFetchArgs = _ApiFetchParamCreator(configuration).contentV1ObjectCharacteristicsObjectNameGet(objectName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * С помощью данного метода можно получить список всех родительских категорий товаров.
         * @summary Родительские категории товаров
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1ObjectParentAllGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2009> {
            const localVarFetchArgs = _ApiFetchParamCreator(configuration).contentV1ObjectParentAllGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет удалить тег.
         * @summary Удаление тега
         * @param {number} id Числовой идентификатор тега
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1TagIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20020> {
            const localVarFetchArgs = _ApiFetchParamCreator(configuration).contentV1TagIdDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет изменять информацию о теге (имя и цвет).
         * @summary Изменение тега
         * @param {TagIdBody} body 
         * @param {number} id Числовой идентификатор тега
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1TagIdPatch(body: TagIdBody, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20021> {
            const localVarFetchArgs = _ApiFetchParamCreator(configuration).contentV1TagIdPatch(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет добавить теги к КТ и снять их с КТ.<br> При снятии тега с КТ сам тег не удаляется.<br> К карточке можно добавить 8 тегов. 
         * @summary Управление тегами в КТ
         * @param {NomenclatureLinkBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1TagNomenclatureLinkPost(body: NomenclatureLinkBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseOK200> {
            const localVarFetchArgs = _ApiFetchParamCreator(configuration).contentV1TagNomenclatureLinkPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет создать тег.<br> Завести можно 8 тегов.<br> Максимальная длина тега 15 символов. 
         * @summary Создание тега
         * @param {V1TagBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1TagPost(body: V1TagBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseOK200> {
            const localVarFetchArgs = _ApiFetchParamCreator(configuration).contentV1TagPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Метод позволяет получить список существующих тегов продавца.
         * @summary Список тегов
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1TagsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20019> {
            const localVarFetchArgs = _ApiFetchParamCreator(configuration).contentV1TagsGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Сброс скидок для номенклатур. При первом запросе ответ будет пустым. При повторной попытке сбросить скидку вернет JSON с id первичного запроса.
         * @summary Сброс скидок для номенклатур
         * @param {Array<number>} body Перечень номенклатур к отмене скидок
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicApiV1RevokeDiscountsPost(body: Array<number>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = _ApiFetchParamCreator(configuration).publicApiV1RevokeDiscountsPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Сброс промокодов для номенклатур
         * @summary Сброс промокодов для номенклатур
         * @param {Array<number>} body Перечень номенклатур к отмене промокодов
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicApiV1RevokePromocodesPost(body: Array<number>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = _ApiFetchParamCreator(configuration).publicApiV1RevokePromocodesPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Установка скидок для номенклатур. Максимальное количество номенклатур на запрос - 1000
         * @summary Установка скидок
         * @param {Array<any>} body Перечень номенклатур
         * @param {string} [activateFrom] Дата активации скидки в формате &#x60;YYYY-MM-DD&#x60; или &#x60;YYYY-MM-DD HH:MM:SS&#x60;. Если не указывать, скидка начнет действовать сразу.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicApiV1UpdateDiscountsPost(body: Array<any>, activateFrom?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = _ApiFetchParamCreator(configuration).publicApiV1UpdateDiscountsPost(body, activateFrom, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Установка промокодов для номенклатур. Максимальное количество номенклатур на запрос - 1000
         * @summary Установка промокодов для номенклатур
         * @param {Array<any>} body Перечень номенклатур
         * @param {string} [activateFrom] Дата активации промокада в формате &#x60;YYYY-MM-DD&#x60; или &#x60;YYYY-MM-DD HH:MM:SS&#x60;. Если не указывать, промокод начнет действовать сразу
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicApiV1UpdatePromocodesPost(body: Array<any>, activateFrom?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = _ApiFetchParamCreator(configuration).publicApiV1UpdatePromocodesPost(body, activateFrom, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * _Api - factory interface
 * @export
 */
export const _ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Метод позволяет сгенерировать массив уникальных баркодов для создания размера НМ в КТ.
         * @summary Генерация баркодов
         * @param {V1BarcodesBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1BarcodesPost(body: V1BarcodesBody, options?: any) {
            return _ApiFp(configuration).contentV1BarcodesPost(body, options)(fetch, basePath);
        },
        /**
         * Метод позволяет получить список созданых НМ по фильтру (баркод, артикул продавца, артикул WB (nmId), тег) с пагинацией и сортировкой. <br> <br>Порядок работы с `cursor/list`: <br> Чтобы получить полный список номенклатур, <b>если их > 1000</b>, необходимо воспользоваться пагинацией.   <ol>     <li>Cделать первый запрос (все указанные ниже параметры обязательны): <br>       <pre style=\"background-color: rgb(38 50 56 / 5%); color: #e53935\">         {           \"sort\": {               \"cursor\": {                   \"limit\": 1000               },               \"filter\": {                   \"withPhoto\": -1               }           }         }</pre>       По желанию можно добавить поиск по <code>\"textSearch\"</code> и сортировку.       <pre style=\"background-color: rgb(38 50 56 / 5%); color: #e53935\">         \"sort\": {           \"sortColumn\": \"\",           \"ascending\": false         }</pre>     </li>     <li>Пройти в конец полученного списка номенклатур, скопировать из <code>cursor</code> две строки:       <ul>         <li><code>\"updatedAt\": \"***\"</code>,</li>         <li><code>\"nmID\": ***</code>,</li>       </ul>     <li>Вставить скопированные строки в <code>cursor</code> запроса, повторить вызов метода. </li>     <li>Повторять пункты <b>2</b> и <b>3</b>, пока <code>total</code> в ответе не станет меньше чем <code>limit</code> в запросе.       <br>Это будет означать, что Вы получили все карточки.   </ol> 
         * @summary Список НМ
         * @param {CursorListBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1CardsCursorListPost(body: CursorListBody, options?: any) {
            return _ApiFp(configuration).contentV1CardsCursorListPost(body, options)(fetch, basePath);
        },
        /**
         * Метод позволяет получить список НМ и список ошибок которые произошли во время создания КТ. <br>`ВАЖНО`: Для того чтобы убрать НМ из ошибочных, надо повторно сделать запрос с исправленными ошибками на создание КТ. 
         * @summary Список несозданных НМ с ошибками
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1CardsErrorListGet(options?: any) {
            return _ApiFp(configuration).contentV1CardsErrorListGet(options)(fetch, basePath);
        },
        /**
         * Метод позволяет получить полную информацию по КТ с помощью артикула(-ов) продавца. 
         * @summary Получение КТ по артикулам продавца
         * @param {CardsFilterBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1CardsFilterPost(body: CardsFilterBody, options?: any) {
            return _ApiFp(configuration).contentV1CardsFilterPost(body, options)(fetch, basePath);
        },
        /**
         * Метод позволяет получить отдельно бесплатные и платные лимиты продавца на создание карточек товаров.
         * @summary Лимиты по КТ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1CardsLimitsGet(options?: any) {
            return _ApiFp(configuration).contentV1CardsLimitsGet(options)(fetch, basePath);
        },
        /**
         * Метод позволяет получить список НМ, находящихся в корзине.<br> Метод позволяет получить список НМ, которые находятся в корзине по фильтру (баркод (<code>skus</code>), артикул продавца(<code>vendorCode</code>), артикул WB(<code>nmID</code>)) с пагинацией и сортировкой. 
         * @summary Список НМ, находящихся в корзине
         * @param {TrashListBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1CardsTrashListPost(body: TrashListBody, options?: any) {
            return _ApiFp(configuration).contentV1CardsTrashListPost(body, options)(fetch, basePath);
        },
        /**
         * Метод позволяет отредактировать несколько карточек за раз. <br> Редактирование КТ происходит асинхронно, после отправки запрос становится в очередь на обработку. <br> `Важно`: Баркоды (skus) не подлежат удалению или замене. Попытка заменить существующий баркод приведет к добавлению нового баркода к существующему. <br> Если запрос прошел успешно, а информация в карточке не обновилась, значит были допущены ошибки и карточка попала в \"Черновики\" (метод `cards/error/list`) с описанием ошибок. <br>Необходимо исправить ошибки в запросе и отправить его повторно. <br> <br> Для успешного обновления карточки рекомендуем Вам придерживаться следующего порядка действий: <br> 1. Сначала существующую карточку необходимо запросить методом cards/filter. <br> 2. Забираем из ответа массив data. <br> 3. В этом массиве вносим необходимые изменения и отправляем его в cards/update <br> <br>За раз можно отредактировать 1000 КТ по 5 НМ в каждой. <br> <br> `Важно`: Изменение цен данным методом невозможно, используйте метод Загрузка цен, раздел документации Цены. 
         * @summary Редактирование КТ
         * @param {Array<CardsUpdateBody>} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1CardsUpdatePost(body: Array<CardsUpdateBody>, options?: any) {
            return _ApiFp(configuration).contentV1CardsUpdatePost(body, options)(fetch, basePath);
        },
        /**
         * Метод позволяет добавить к карточке товара новую номенклатуру. <br>Добавление НМ к КТ происходит асинхронно, после отправки запрос становится в очередь на обработку. <br>`Важно`: Если после успешной отправки запроса номенклатура не создалась, то необходимо проверить раздел \"Список несозданных НМ с ошибками\". Для того чтобы убрать НМ из ошибочных, необходимо повторно сделать запрос с исправленными ошибками. 
         * @summary Добавление НМ к КТ
         * @param {UploadAddBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1CardsUploadAddPost(body: UploadAddBody, options?: any) {
            return _ApiFp(configuration).contentV1CardsUploadAddPost(body, options)(fetch, basePath);
        },
        /**
         * Создание карточки товара происходит асинхронно, при отправке запроса на создание КТ ваш запрос становится в очередь на создание КТ. <br>`ПРИМЕЧАНИЕ`: Карточка товара считается `созданной`, если успешно создалась хотя бы одна `НМ`. <br>`ВАЖНО`: Если во время обработки запроса в очереди выявляются ошибки, то НМ считается ошибочной. <br>Если запрос на создание прошел успешно, а карточка не создалась, то необходимо в первую очередь проверить наличие карточки в методе `cards/error/list`. Если карточка попала в ответ к этому методу, то необходимо исправить описанные ошибки в запросе на создание карточки и отправить его повторно. <br>За раз можно создать 1000 КТ по 5 НМ в каждой.  <br>Если Вам требуется больше 5 НМ в КТ, то после создания карточки Вы можете добавить их методом \"Добавление НМ к КТ\". 
         * @summary Создание  КТ
         * @param {CardsUploadBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1CardsUploadPost(body: CardsUploadBody, options?: any) {
            return _ApiFp(configuration).contentV1CardsUploadPost(body, options)(fetch, basePath);
        },
        /**
         * Получение значения характеристики Бренд.
         * @summary Бренд
         * @param {number} [top] Количество запрашиваемых значений (максимум 5000)
         * @param {string} [pattern] Поиск по наименованию значения характеристики
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1DirectoryBrandsGet(top?: number, pattern?: string, options?: any) {
            return _ApiFp(configuration).contentV1DirectoryBrandsGet(top, pattern, options)(fetch, basePath);
        },
        /**
         * Получение значения характеристики цвет.
         * @summary Цвет
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1DirectoryColorsGet(options?: any) {
            return _ApiFp(configuration).contentV1DirectoryColorsGet(options)(fetch, basePath);
        },
        /**
         * Получение значения характеристики Страна Производства.
         * @summary Страна Производства
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1DirectoryCountriesGet(options?: any) {
            return _ApiFp(configuration).contentV1DirectoryCountriesGet(options)(fetch, basePath);
        },
        /**
         * Получение значения характеристики пол.
         * @summary Пол
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1DirectoryKindsGet(options?: any) {
            return _ApiFp(configuration).contentV1DirectoryKindsGet(options)(fetch, basePath);
        },
        /**
         * Получение значения характеристики Сезон.
         * @summary Сезон
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1DirectorySeasonsGet(options?: any) {
            return _ApiFp(configuration).contentV1DirectorySeasonsGet(options)(fetch, basePath);
        },
        /**
         * С помощью данного метода можно получить список ТНВЭД кодов по имени категории и фильтру по тнвэд коду.
         * @summary ТНВЭД код
         * @param {string} [objectName] Поиск по наименованию категории
         * @param {string} [tnvedsLike] Поиск по коду ТНВЭД
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1DirectoryTnvedGet(objectName?: string, tnvedsLike?: string, options?: any) {
            return _ApiFp(configuration).contentV1DirectoryTnvedGet(objectName, tnvedsLike, options)(fetch, basePath);
        },
        /**
         * Метод позволяет загрузить и добавить один медиафайл за запрос, к НМ в КТ. <br>Требования к медиафайлам: <br>`Фото`: минимальное разрешение – 450х450. <br>Максимально допустимое количество фото в КТ 30. <br>Допустимые форматы изображений - jpg и png. <br>`Видео`: максимальный размер 50 мб. Форматы MOV, MP4. <br>Максимально допустимое количество видео в КТ 1. 
         * @summary Добавление медиа контента в КТ
         * @param {Blob} uploadfile 
         * @param {string} xVendorCode Артикул продавца
         * @param {number} xPhotoNumber Номер медиафайла на загрузку. &lt;b&gt;Начинать с 1&lt;/b&gt;. &lt;br&gt;Чтобы добавить фото к уже загруженным в НМ, номер медиафайла должен быть больше кол-ва загруженных в НМ медиафайлов. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1MediaFilePost(uploadfile: Blob, xVendorCode: string, xPhotoNumber: number, options?: any) {
            return _ApiFp(configuration).contentV1MediaFilePost(uploadfile, xVendorCode, xPhotoNumber, options)(fetch, basePath);
        },
        /**
         * Метод позволяет изменить порядок изображений или удалить медиафайлы с НМ в КТ, а также загрузить изображения в НМ со сторонних ресурсов по URL. <br>Текущие изображения заменяются на переданные в массиве data. <br> <br>Требования к медиафайлам: <br>`Фото`: минимальное разрешение – 450х450. <br>Максимально допустимое количество фото в КТ 30.  <br>Допустимые форматы изображений - jpg и png. <br> <br>Если хотя бы одно изображение в запросе не соответствует требованиям к медиафайлам, то даже при коде ответа 200 ни одно изображение не загрузится в КТ. 
         * @summary Изменение медиа контента КТ
         * @param {MediaSaveBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1MediaSavePost(body: MediaSaveBody, options?: any) {
            return _ApiFp(configuration).contentV1MediaSavePost(body, options)(fetch, basePath);
        },
        /**
         * С помощью данного метода можно получить список категорий товаров по текстовому фильтру (названию категории). <br> <br> Чтобы получить список всех категорий необходимо указать `top=8000`, к примеру. <br> <br> По состоянию на `27.03.2023` в списке `7440` категорий. Количество доступных категорий может меняться.       
         * @summary Категория товаров
         * @param {string} [name] Поиск по названию категории
         * @param {number} [top] Количество запрашиваемых значений
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1ObjectAllGet(name?: string, top?: number, options?: any) {
            return _ApiFp(configuration).contentV1ObjectAllGet(name, top, options)(fetch, basePath);
        },
        /**
         * С помощью данного метода можно получить список характеристик, которые можно или нужно заполнить при создании КТ в подкатегории определенной родительской категории.   <br>   <br>Характеристики с  `charcType=4`, имеющие единственное значение, <b>указывать строго без массива</b>, в противном случае карточка не будет создана:   <br><b>Правильно:</b>       <br>`{\"Высота упаковки\": 4}`   <br><b>Не правильно:</b>       <br>`{\"Высота упаковки\": [4]}` 
         * @summary Характеристики для создания КТ по всем подкатегориям
         * @param {string} [name] Поиск по родительской категории.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1ObjectCharacteristicsListFilterGet(name?: string, options?: any) {
            return _ApiFp(configuration).contentV1ObjectCharacteristicsListFilterGet(name, options)(fetch, basePath);
        },
        /**
         * С помощью данного метода можно получить список характеристик, которые можно или нужно заполнить при создании КТ для определенной категории товаров. <br> <br> `Важно`: обязательная к заполнению характеристика при создании карточки любого товара - `Предмет`. <br>Значение характеристики `Предмет` соответствует значению параметра `objectName` в запросе. <br> <br>Характеристики с  `charcType=4`, имеющие единственное значение, <b>указывать строго без массива</b>, в противном случае карточка не будет создана: <br><b>Правильно:</b>     <br>`{\"Высота упаковки\": 4}` <br><b>Не правильно:</b>     <br>`{\"Высота упаковки\": [4]}` 
         * @summary Характеристики для создания КТ для категории товара
         * @param {string} objectName Поиск по наименованию категории
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1ObjectCharacteristicsObjectNameGet(objectName: string, options?: any) {
            return _ApiFp(configuration).contentV1ObjectCharacteristicsObjectNameGet(objectName, options)(fetch, basePath);
        },
        /**
         * С помощью данного метода можно получить список всех родительских категорий товаров.
         * @summary Родительские категории товаров
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1ObjectParentAllGet(options?: any) {
            return _ApiFp(configuration).contentV1ObjectParentAllGet(options)(fetch, basePath);
        },
        /**
         * Метод позволяет удалить тег.
         * @summary Удаление тега
         * @param {number} id Числовой идентификатор тега
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1TagIdDelete(id: number, options?: any) {
            return _ApiFp(configuration).contentV1TagIdDelete(id, options)(fetch, basePath);
        },
        /**
         * Метод позволяет изменять информацию о теге (имя и цвет).
         * @summary Изменение тега
         * @param {TagIdBody} body 
         * @param {number} id Числовой идентификатор тега
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1TagIdPatch(body: TagIdBody, id: number, options?: any) {
            return _ApiFp(configuration).contentV1TagIdPatch(body, id, options)(fetch, basePath);
        },
        /**
         * Метод позволяет добавить теги к КТ и снять их с КТ.<br> При снятии тега с КТ сам тег не удаляется.<br> К карточке можно добавить 8 тегов. 
         * @summary Управление тегами в КТ
         * @param {NomenclatureLinkBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1TagNomenclatureLinkPost(body: NomenclatureLinkBody, options?: any) {
            return _ApiFp(configuration).contentV1TagNomenclatureLinkPost(body, options)(fetch, basePath);
        },
        /**
         * Метод позволяет создать тег.<br> Завести можно 8 тегов.<br> Максимальная длина тега 15 символов. 
         * @summary Создание тега
         * @param {V1TagBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1TagPost(body: V1TagBody, options?: any) {
            return _ApiFp(configuration).contentV1TagPost(body, options)(fetch, basePath);
        },
        /**
         * Метод позволяет получить список существующих тегов продавца.
         * @summary Список тегов
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contentV1TagsGet(options?: any) {
            return _ApiFp(configuration).contentV1TagsGet(options)(fetch, basePath);
        },
        /**
         * Сброс скидок для номенклатур. При первом запросе ответ будет пустым. При повторной попытке сбросить скидку вернет JSON с id первичного запроса.
         * @summary Сброс скидок для номенклатур
         * @param {Array<number>} body Перечень номенклатур к отмене скидок
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicApiV1RevokeDiscountsPost(body: Array<number>, options?: any) {
            return _ApiFp(configuration).publicApiV1RevokeDiscountsPost(body, options)(fetch, basePath);
        },
        /**
         * Сброс промокодов для номенклатур
         * @summary Сброс промокодов для номенклатур
         * @param {Array<number>} body Перечень номенклатур к отмене промокодов
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicApiV1RevokePromocodesPost(body: Array<number>, options?: any) {
            return _ApiFp(configuration).publicApiV1RevokePromocodesPost(body, options)(fetch, basePath);
        },
        /**
         * Установка скидок для номенклатур. Максимальное количество номенклатур на запрос - 1000
         * @summary Установка скидок
         * @param {Array<any>} body Перечень номенклатур
         * @param {string} [activateFrom] Дата активации скидки в формате &#x60;YYYY-MM-DD&#x60; или &#x60;YYYY-MM-DD HH:MM:SS&#x60;. Если не указывать, скидка начнет действовать сразу.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicApiV1UpdateDiscountsPost(body: Array<any>, activateFrom?: string, options?: any) {
            return _ApiFp(configuration).publicApiV1UpdateDiscountsPost(body, activateFrom, options)(fetch, basePath);
        },
        /**
         * Установка промокодов для номенклатур. Максимальное количество номенклатур на запрос - 1000
         * @summary Установка промокодов для номенклатур
         * @param {Array<any>} body Перечень номенклатур
         * @param {string} [activateFrom] Дата активации промокада в формате &#x60;YYYY-MM-DD&#x60; или &#x60;YYYY-MM-DD HH:MM:SS&#x60;. Если не указывать, промокод начнет действовать сразу
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicApiV1UpdatePromocodesPost(body: Array<any>, activateFrom?: string, options?: any) {
            return _ApiFp(configuration).publicApiV1UpdatePromocodesPost(body, activateFrom, options)(fetch, basePath);
        },
    };
};

/**
 * _Api - object-oriented interface
 * @export
 * @class _Api
 * @extends {BaseAPI}
 */
export class _Api extends BaseAPI {
    /**
     * Метод позволяет сгенерировать массив уникальных баркодов для создания размера НМ в КТ.
     * @summary Генерация баркодов
     * @param {V1BarcodesBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof _Api
     */
    public contentV1BarcodesPost(body: V1BarcodesBody, options?: any) {
        return _ApiFp(this.configuration).contentV1BarcodesPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет получить список созданых НМ по фильтру (баркод, артикул продавца, артикул WB (nmId), тег) с пагинацией и сортировкой. <br> <br>Порядок работы с `cursor/list`: <br> Чтобы получить полный список номенклатур, <b>если их > 1000</b>, необходимо воспользоваться пагинацией.   <ol>     <li>Cделать первый запрос (все указанные ниже параметры обязательны): <br>       <pre style=\"background-color: rgb(38 50 56 / 5%); color: #e53935\">         {           \"sort\": {               \"cursor\": {                   \"limit\": 1000               },               \"filter\": {                   \"withPhoto\": -1               }           }         }</pre>       По желанию можно добавить поиск по <code>\"textSearch\"</code> и сортировку.       <pre style=\"background-color: rgb(38 50 56 / 5%); color: #e53935\">         \"sort\": {           \"sortColumn\": \"\",           \"ascending\": false         }</pre>     </li>     <li>Пройти в конец полученного списка номенклатур, скопировать из <code>cursor</code> две строки:       <ul>         <li><code>\"updatedAt\": \"***\"</code>,</li>         <li><code>\"nmID\": ***</code>,</li>       </ul>     <li>Вставить скопированные строки в <code>cursor</code> запроса, повторить вызов метода. </li>     <li>Повторять пункты <b>2</b> и <b>3</b>, пока <code>total</code> в ответе не станет меньше чем <code>limit</code> в запросе.       <br>Это будет означать, что Вы получили все карточки.   </ol> 
     * @summary Список НМ
     * @param {CursorListBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof _Api
     */
    public contentV1CardsCursorListPost(body: CursorListBody, options?: any) {
        return _ApiFp(this.configuration).contentV1CardsCursorListPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет получить список НМ и список ошибок которые произошли во время создания КТ. <br>`ВАЖНО`: Для того чтобы убрать НМ из ошибочных, надо повторно сделать запрос с исправленными ошибками на создание КТ. 
     * @summary Список несозданных НМ с ошибками
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof _Api
     */
    public contentV1CardsErrorListGet(options?: any) {
        return _ApiFp(this.configuration).contentV1CardsErrorListGet(options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет получить полную информацию по КТ с помощью артикула(-ов) продавца. 
     * @summary Получение КТ по артикулам продавца
     * @param {CardsFilterBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof _Api
     */
    public contentV1CardsFilterPost(body: CardsFilterBody, options?: any) {
        return _ApiFp(this.configuration).contentV1CardsFilterPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет получить отдельно бесплатные и платные лимиты продавца на создание карточек товаров.
     * @summary Лимиты по КТ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof _Api
     */
    public contentV1CardsLimitsGet(options?: any) {
        return _ApiFp(this.configuration).contentV1CardsLimitsGet(options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет получить список НМ, находящихся в корзине.<br> Метод позволяет получить список НМ, которые находятся в корзине по фильтру (баркод (<code>skus</code>), артикул продавца(<code>vendorCode</code>), артикул WB(<code>nmID</code>)) с пагинацией и сортировкой. 
     * @summary Список НМ, находящихся в корзине
     * @param {TrashListBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof _Api
     */
    public contentV1CardsTrashListPost(body: TrashListBody, options?: any) {
        return _ApiFp(this.configuration).contentV1CardsTrashListPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет отредактировать несколько карточек за раз. <br> Редактирование КТ происходит асинхронно, после отправки запрос становится в очередь на обработку. <br> `Важно`: Баркоды (skus) не подлежат удалению или замене. Попытка заменить существующий баркод приведет к добавлению нового баркода к существующему. <br> Если запрос прошел успешно, а информация в карточке не обновилась, значит были допущены ошибки и карточка попала в \"Черновики\" (метод `cards/error/list`) с описанием ошибок. <br>Необходимо исправить ошибки в запросе и отправить его повторно. <br> <br> Для успешного обновления карточки рекомендуем Вам придерживаться следующего порядка действий: <br> 1. Сначала существующую карточку необходимо запросить методом cards/filter. <br> 2. Забираем из ответа массив data. <br> 3. В этом массиве вносим необходимые изменения и отправляем его в cards/update <br> <br>За раз можно отредактировать 1000 КТ по 5 НМ в каждой. <br> <br> `Важно`: Изменение цен данным методом невозможно, используйте метод Загрузка цен, раздел документации Цены. 
     * @summary Редактирование КТ
     * @param {Array<CardsUpdateBody>} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof _Api
     */
    public contentV1CardsUpdatePost(body: Array<CardsUpdateBody>, options?: any) {
        return _ApiFp(this.configuration).contentV1CardsUpdatePost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет добавить к карточке товара новую номенклатуру. <br>Добавление НМ к КТ происходит асинхронно, после отправки запрос становится в очередь на обработку. <br>`Важно`: Если после успешной отправки запроса номенклатура не создалась, то необходимо проверить раздел \"Список несозданных НМ с ошибками\". Для того чтобы убрать НМ из ошибочных, необходимо повторно сделать запрос с исправленными ошибками. 
     * @summary Добавление НМ к КТ
     * @param {UploadAddBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof _Api
     */
    public contentV1CardsUploadAddPost(body: UploadAddBody, options?: any) {
        return _ApiFp(this.configuration).contentV1CardsUploadAddPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Создание карточки товара происходит асинхронно, при отправке запроса на создание КТ ваш запрос становится в очередь на создание КТ. <br>`ПРИМЕЧАНИЕ`: Карточка товара считается `созданной`, если успешно создалась хотя бы одна `НМ`. <br>`ВАЖНО`: Если во время обработки запроса в очереди выявляются ошибки, то НМ считается ошибочной. <br>Если запрос на создание прошел успешно, а карточка не создалась, то необходимо в первую очередь проверить наличие карточки в методе `cards/error/list`. Если карточка попала в ответ к этому методу, то необходимо исправить описанные ошибки в запросе на создание карточки и отправить его повторно. <br>За раз можно создать 1000 КТ по 5 НМ в каждой.  <br>Если Вам требуется больше 5 НМ в КТ, то после создания карточки Вы можете добавить их методом \"Добавление НМ к КТ\". 
     * @summary Создание  КТ
     * @param {CardsUploadBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof _Api
     */
    public contentV1CardsUploadPost(body: CardsUploadBody, options?: any) {
        return _ApiFp(this.configuration).contentV1CardsUploadPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Получение значения характеристики Бренд.
     * @summary Бренд
     * @param {number} [top] Количество запрашиваемых значений (максимум 5000)
     * @param {string} [pattern] Поиск по наименованию значения характеристики
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof _Api
     */
    public contentV1DirectoryBrandsGet(top?: number, pattern?: string, options?: any) {
        return _ApiFp(this.configuration).contentV1DirectoryBrandsGet(top, pattern, options)(this.fetch, this.basePath);
    }

    /**
     * Получение значения характеристики цвет.
     * @summary Цвет
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof _Api
     */
    public contentV1DirectoryColorsGet(options?: any) {
        return _ApiFp(this.configuration).contentV1DirectoryColorsGet(options)(this.fetch, this.basePath);
    }

    /**
     * Получение значения характеристики Страна Производства.
     * @summary Страна Производства
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof _Api
     */
    public contentV1DirectoryCountriesGet(options?: any) {
        return _ApiFp(this.configuration).contentV1DirectoryCountriesGet(options)(this.fetch, this.basePath);
    }

    /**
     * Получение значения характеристики пол.
     * @summary Пол
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof _Api
     */
    public contentV1DirectoryKindsGet(options?: any) {
        return _ApiFp(this.configuration).contentV1DirectoryKindsGet(options)(this.fetch, this.basePath);
    }

    /**
     * Получение значения характеристики Сезон.
     * @summary Сезон
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof _Api
     */
    public contentV1DirectorySeasonsGet(options?: any) {
        return _ApiFp(this.configuration).contentV1DirectorySeasonsGet(options)(this.fetch, this.basePath);
    }

    /**
     * С помощью данного метода можно получить список ТНВЭД кодов по имени категории и фильтру по тнвэд коду.
     * @summary ТНВЭД код
     * @param {string} [objectName] Поиск по наименованию категории
     * @param {string} [tnvedsLike] Поиск по коду ТНВЭД
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof _Api
     */
    public contentV1DirectoryTnvedGet(objectName?: string, tnvedsLike?: string, options?: any) {
        return _ApiFp(this.configuration).contentV1DirectoryTnvedGet(objectName, tnvedsLike, options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет загрузить и добавить один медиафайл за запрос, к НМ в КТ. <br>Требования к медиафайлам: <br>`Фото`: минимальное разрешение – 450х450. <br>Максимально допустимое количество фото в КТ 30. <br>Допустимые форматы изображений - jpg и png. <br>`Видео`: максимальный размер 50 мб. Форматы MOV, MP4. <br>Максимально допустимое количество видео в КТ 1. 
     * @summary Добавление медиа контента в КТ
     * @param {Blob} uploadfile 
     * @param {string} xVendorCode Артикул продавца
     * @param {number} xPhotoNumber Номер медиафайла на загрузку. &lt;b&gt;Начинать с 1&lt;/b&gt;. &lt;br&gt;Чтобы добавить фото к уже загруженным в НМ, номер медиафайла должен быть больше кол-ва загруженных в НМ медиафайлов. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof _Api
     */
    public contentV1MediaFilePost(uploadfile: Blob, xVendorCode: string, xPhotoNumber: number, options?: any) {
        return _ApiFp(this.configuration).contentV1MediaFilePost(uploadfile, xVendorCode, xPhotoNumber, options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет изменить порядок изображений или удалить медиафайлы с НМ в КТ, а также загрузить изображения в НМ со сторонних ресурсов по URL. <br>Текущие изображения заменяются на переданные в массиве data. <br> <br>Требования к медиафайлам: <br>`Фото`: минимальное разрешение – 450х450. <br>Максимально допустимое количество фото в КТ 30.  <br>Допустимые форматы изображений - jpg и png. <br> <br>Если хотя бы одно изображение в запросе не соответствует требованиям к медиафайлам, то даже при коде ответа 200 ни одно изображение не загрузится в КТ. 
     * @summary Изменение медиа контента КТ
     * @param {MediaSaveBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof _Api
     */
    public contentV1MediaSavePost(body: MediaSaveBody, options?: any) {
        return _ApiFp(this.configuration).contentV1MediaSavePost(body, options)(this.fetch, this.basePath);
    }

    /**
     * С помощью данного метода можно получить список категорий товаров по текстовому фильтру (названию категории). <br> <br> Чтобы получить список всех категорий необходимо указать `top=8000`, к примеру. <br> <br> По состоянию на `27.03.2023` в списке `7440` категорий. Количество доступных категорий может меняться.       
     * @summary Категория товаров
     * @param {string} [name] Поиск по названию категории
     * @param {number} [top] Количество запрашиваемых значений
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof _Api
     */
    public contentV1ObjectAllGet(name?: string, top?: number, options?: any) {
        return _ApiFp(this.configuration).contentV1ObjectAllGet(name, top, options)(this.fetch, this.basePath);
    }

    /**
     * С помощью данного метода можно получить список характеристик, которые можно или нужно заполнить при создании КТ в подкатегории определенной родительской категории.   <br>   <br>Характеристики с  `charcType=4`, имеющие единственное значение, <b>указывать строго без массива</b>, в противном случае карточка не будет создана:   <br><b>Правильно:</b>       <br>`{\"Высота упаковки\": 4}`   <br><b>Не правильно:</b>       <br>`{\"Высота упаковки\": [4]}` 
     * @summary Характеристики для создания КТ по всем подкатегориям
     * @param {string} [name] Поиск по родительской категории.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof _Api
     */
    public contentV1ObjectCharacteristicsListFilterGet(name?: string, options?: any) {
        return _ApiFp(this.configuration).contentV1ObjectCharacteristicsListFilterGet(name, options)(this.fetch, this.basePath);
    }

    /**
     * С помощью данного метода можно получить список характеристик, которые можно или нужно заполнить при создании КТ для определенной категории товаров. <br> <br> `Важно`: обязательная к заполнению характеристика при создании карточки любого товара - `Предмет`. <br>Значение характеристики `Предмет` соответствует значению параметра `objectName` в запросе. <br> <br>Характеристики с  `charcType=4`, имеющие единственное значение, <b>указывать строго без массива</b>, в противном случае карточка не будет создана: <br><b>Правильно:</b>     <br>`{\"Высота упаковки\": 4}` <br><b>Не правильно:</b>     <br>`{\"Высота упаковки\": [4]}` 
     * @summary Характеристики для создания КТ для категории товара
     * @param {string} objectName Поиск по наименованию категории
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof _Api
     */
    public contentV1ObjectCharacteristicsObjectNameGet(objectName: string, options?: any) {
        return _ApiFp(this.configuration).contentV1ObjectCharacteristicsObjectNameGet(objectName, options)(this.fetch, this.basePath);
    }

    /**
     * С помощью данного метода можно получить список всех родительских категорий товаров.
     * @summary Родительские категории товаров
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof _Api
     */
    public contentV1ObjectParentAllGet(options?: any) {
        return _ApiFp(this.configuration).contentV1ObjectParentAllGet(options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет удалить тег.
     * @summary Удаление тега
     * @param {number} id Числовой идентификатор тега
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof _Api
     */
    public contentV1TagIdDelete(id: number, options?: any) {
        return _ApiFp(this.configuration).contentV1TagIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет изменять информацию о теге (имя и цвет).
     * @summary Изменение тега
     * @param {TagIdBody} body 
     * @param {number} id Числовой идентификатор тега
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof _Api
     */
    public contentV1TagIdPatch(body: TagIdBody, id: number, options?: any) {
        return _ApiFp(this.configuration).contentV1TagIdPatch(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет добавить теги к КТ и снять их с КТ.<br> При снятии тега с КТ сам тег не удаляется.<br> К карточке можно добавить 8 тегов. 
     * @summary Управление тегами в КТ
     * @param {NomenclatureLinkBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof _Api
     */
    public contentV1TagNomenclatureLinkPost(body: NomenclatureLinkBody, options?: any) {
        return _ApiFp(this.configuration).contentV1TagNomenclatureLinkPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет создать тег.<br> Завести можно 8 тегов.<br> Максимальная длина тега 15 символов. 
     * @summary Создание тега
     * @param {V1TagBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof _Api
     */
    public contentV1TagPost(body: V1TagBody, options?: any) {
        return _ApiFp(this.configuration).contentV1TagPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Метод позволяет получить список существующих тегов продавца.
     * @summary Список тегов
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof _Api
     */
    public contentV1TagsGet(options?: any) {
        return _ApiFp(this.configuration).contentV1TagsGet(options)(this.fetch, this.basePath);
    }

    /**
     * Сброс скидок для номенклатур. При первом запросе ответ будет пустым. При повторной попытке сбросить скидку вернет JSON с id первичного запроса.
     * @summary Сброс скидок для номенклатур
     * @param {Array<number>} body Перечень номенклатур к отмене скидок
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof _Api
     */
    public publicApiV1RevokeDiscountsPost(body: Array<number>, options?: any) {
        return _ApiFp(this.configuration).publicApiV1RevokeDiscountsPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Сброс промокодов для номенклатур
     * @summary Сброс промокодов для номенклатур
     * @param {Array<number>} body Перечень номенклатур к отмене промокодов
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof _Api
     */
    public publicApiV1RevokePromocodesPost(body: Array<number>, options?: any) {
        return _ApiFp(this.configuration).publicApiV1RevokePromocodesPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Установка скидок для номенклатур. Максимальное количество номенклатур на запрос - 1000
     * @summary Установка скидок
     * @param {Array<any>} body Перечень номенклатур
     * @param {string} [activateFrom] Дата активации скидки в формате &#x60;YYYY-MM-DD&#x60; или &#x60;YYYY-MM-DD HH:MM:SS&#x60;. Если не указывать, скидка начнет действовать сразу.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof _Api
     */
    public publicApiV1UpdateDiscountsPost(body: Array<any>, activateFrom?: string, options?: any) {
        return _ApiFp(this.configuration).publicApiV1UpdateDiscountsPost(body, activateFrom, options)(this.fetch, this.basePath);
    }

    /**
     * Установка промокодов для номенклатур. Максимальное количество номенклатур на запрос - 1000
     * @summary Установка промокодов для номенклатур
     * @param {Array<any>} body Перечень номенклатур
     * @param {string} [activateFrom] Дата активации промокада в формате &#x60;YYYY-MM-DD&#x60; или &#x60;YYYY-MM-DD HH:MM:SS&#x60;. Если не указывать, промокод начнет действовать сразу
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof _Api
     */
    public publicApiV1UpdatePromocodesPost(body: Array<any>, activateFrom?: string, options?: any) {
        return _ApiFp(this.configuration).publicApiV1UpdatePromocodesPost(body, activateFrom, options)(this.fetch, this.basePath);
    }

}
